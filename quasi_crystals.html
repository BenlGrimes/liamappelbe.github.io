<!DOCTYPE html>
<html>
<head>
<title>Quasi Crystals</title>
<link rel="icon" href="res/favicon.ico">
<script src="slide_show.js"></script>
<script type="text/javascript">

// Config
const mainViewSize = 10;
const mainViewZoomRate = 1.1;
const mainDotInitSize = 0.03;
const mainLineSize = 1;
const cellViewSize = 1;
const cellDotSize = 0.01;
const cellLineSize = 2;
const cellRayLength = 4;
const contFracTerms = 10;  // Max is around 30 before float errors.
const visibleContFracTerms = 6;
const approxContFracTerms = visibleContFracTerms;  // +1??
const epsilon = 1e-6;
const alwaysRedraw = false;
const maxSeqLength = 1000;  // Way more than what we display.
const genSeqLength = 100;

const tau = 2 * Math.PI;

function randInt(n) {
  return Math.floor(n * Math.random());
}

function fmod(x, y = 1) {
  const z = x / y;
  return (z - Math.floor(z)) * y;
}

function clamp(x, lo = 0, hi = 1) {
  return Math.max(Math.min(x, hi), lo);
}

function squish(x) {
  return (1 - Math.cos(x * Math.PI)) / 4 + x / 2;
}

function squishy(x, n) {
  for (let i = 0; i < n; ++i) x = squish(x);
  return x;
}

function isInt(x) {
  return Math.floor(x) == x;
}

function unit(x, y) {
  const d = Math.sqrt(x * x + y * y);
  if (d == 0) return [0, 0];
  return [x / d, y / d];
}

function getContFracTerms(x, maxTerms) {
  const terms = [];
  for (let i = 0; i < maxTerms; ++i) {
    const c = Math.floor(x);
    terms.push(c);
    const r = x - c;
    if (r < epsilon) {
      if (c == 1 && terms.length > 1) {
        terms.pop();
        terms[terms.length - 1] += 1;
      }
      break;
    }
    x = 1 / r;
  }
  return terms;
}

function getApproxFrac(terms, maxTerms, zn = 0, zd = 1) {
  const first = Math.min(terms.length, maxTerms) - 1;
  const frac = [zd, zn];
  for (let i = first; i >= 0; --i) {
    const y = frac[0];
    frac[0] = terms[i] * y + frac[1];
    frac[1] = y;
  }
  return frac;
}

function getContFracValue(terms) {
  let x = Infinity;
  for (let i = terms.length - 1; i >= 0; --i) {
    x = terms[i] + 1 / x;
  }
  return x;
}

function repeatStr(s, n, max) {
  let t = '';
  while (n > 0) {
    if (n & 1) t += s;
    s += s;
    n >>>= 1;
    if (t.length >= max) break;
  }
  return t;
}

function wordFromContFracTerms(terms) {
  let w = '';
  let w1 = 'S';
  let w2 = 'L';
  for (let i = 0; i < terms.length; ++i) {
    const wr = repeatStr(w1, terms[i], maxSeqLength);
    w = (i % 2 == 0) ? wr + w2 : w2 + wr;
    if (w.length >= maxSeqLength) return w.substr(0, maxSeqLength);
    w2 = w1;
    w1 = w;
  }
  return w;
}

function sequenceFromGrad(x, o, len) {
  let m = o;
  let n = 1;
  const a = [];
  for (let i = 0; i < len; ++i) {
    if (n * x > m) {
      ++m;
      a.push(true);
    } else {
      ++n;
      a.push(false);
    }
  }
  return a;
}

function safeGet(node, defaultValue, isValid = (x => true)) {
  const value = parseFloat(node.value);
  if (isNaN(value) || !isValid(value)) return defaultValue;
  return value;
}

function newElement(type, parent, classes = [], text = null) {
  const n = document.createElement(type);
  if (text != null) n.innerText = text;
  for (const cls of classes) n.classList.add(cls);
  if (parent != null) parent.appendChild(n);
  return n;
}

function newDiv(parent, classes = [], text = null) {
  return newElement('div', parent, classes, text);
}

function emptyDiv(n) {
  while (n.hasChildNodes()) n.removeChild(n.lastChild);
}

function runUnitTests() {
  let anyFails = false;
  const testWord = (terms, expectedWord) => {
    const word = wordFromContFracTerms(terms);
    if (word != expectedWord) {
      console.error(`wordFromContFracTerms([${terms}]) produced ${word} instead of ${expectedWord}`);
      anyFails = true;
    }
  };

  testWord([], '');
  testWord([1], 'SL');
  testWord([1, 1], 'SSL');
  testWord([1, 1, 1], 'SSLSL');
  testWord([1, 1, 1, 1], 'SSLSSLSL');
  testWord([1, 1, 1, 1, 1], 'SSLSSLSLSSLSL');
  testWord([1, 1, 1, 1, 1, 1], 'SSLSSLSLSSLSSLSLSSLSL');
  testWord([1, 6, 2, 3, 1, 2], 'SSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSL');
  testWord([0, 2, 2], 'SLLSLLL');

  const testContFrac = (x) => {
    const y = getContFracValue(getContFracTerms(x, 100));
    if (Math.abs(x - y) > 1e-12) {
      console.error(`getContFracValue(getContFracTerms(${x}, 100)) produced ${y} instead of ${x}`);
      anyFails = true;
    }
  };

  for (let i = 0; i < 1000; ++i) {
    testContFrac(10 * Math.random());
    testContFrac(randInt(10000) / (randInt(10000) + 1));
  }

  if (!anyFails) {
    console.log('All tests passed :)');
  }
}

function getRayCellCrossingsDist(gx, ox, len) {
  if (gx == 0) return null;
  const k = (1 - ox) / gx;
  if (k >= len) return null
  return k;
}

function getRayCellCrossings(gx, gy, ox, oy, len) {
  let d = 0;
  let x = ox;
  let y = oy;
  const a = [];
  for (let i = 0; i < 100; ++i) {
    const l = len - d;
    const kx = getRayCellCrossingsDist(gx, x, l);
    const ky = getRayCellCrossingsDist(gy, y, l);
    const stop = kx == null && ky == null;

    let k = 0;
    let px = null;
    let py = null;
    let nx = null;
    let ny = null;
    if (stop) {
      k = l;
    } else if (ky == null || (kx != null && kx < ky)) {
      k = kx;
      px = 1;
      nx = 0;
    } else {
      k = ky;
      py = 1;
      ny = 0;
    }
    if (ny == null) ny = py = y + k * gy;
    if (nx == null) nx = px = x + k * gx;

    const nd = d + k;
    a.push([x, y, d / len, px, py, nd / len]);
    x = nx;
    y = ny;
    d = nd;

    if (stop) break;
  }
  return a;
}

function setupCanvas(canvas, viewWidth, lineWidthMul = 1) {
  const ctx = canvas.getContext('2d');
  ctx.setTransform(
      canvas.width / viewWidth, 0,
      0, -canvas.width / viewWidth,
      0, canvas.height);
  ctx.lineWidth = lineWidthMul * viewWidth / canvas.width;
  return ctx;
}

function onLoad() {
  runUnitTests();

  let forceRedraw = true;
  const onFrameCallbacks = [];

  const liveValue = (ids, init = 0, validate = x => x, onchange = () => {}) => {
    // Does a few things:
    // - Maintains the invariant that each dom element has the same value.
    // - Whenever the value changes, sets forceRedraw to true.
    // - Uses validate to sanitize, a function from float to nullable float.
    // - Returns an object with a value field that is kept up to date.
    // - Changes to that field are also reflected on the elements.
    const elements = ids.map(id => document.getElementById(id));
    const oldValues = [];  // One for each element, and one for obj.value.
    for (const e of elements) {
      e.value = init;
      oldValues.push(e.value);
    }
    const obj = { value: init };
    oldValues.push(obj.value);
    onFrameCallbacks.push(() => {
      let anyChange = obj.value != oldValues[elements.length];
      let cause = null;
      if (!anyChange) {
        for (let i = 0; i < elements.length; ++i) {
          const e = elements[i];
          if (e.value != oldValues[i]) {
            const px = parseFloat(e.value);
            const x = isNaN(px) ? null : validate(px);
            if (x != null) {
              anyChange = true;
              obj.value = x;
              cause = i;
              break;
            }
          }
        }
      }
      if (anyChange) {
        forceRedraw = true;
        oldValues[elements.length] = obj.value;
        for (let i = 0; i < elements.length; ++i) {
          const e = elements[i];
          if (i != cause) {
            e.value = obj.value;
          }
          oldValues[i] = e.value;
        }
        onchange();
      }
    });
    return obj;
  };

  let targKeep = false;
  let targX = null;
  let targY = null;
  const grad = liveValue(
      ['in_grad', 'ins_grad'], 0.618033988749894, x => x >= 0 ? x : 0, () => {
    if (targKeep) {
      targKeep = false;
    } else {
      targX = null;
      targY = null;
    }
  });
  const off = liveValue(['in_off', 'ins_off'], 0, x => fmod(x));
  let targCoeff = 0;
  const coeffterm = liveValue(['coeff_slider'], 1, x => Math.floor(x), () => {
    const terms = getContFracTerms(grad.value, contFracTerms);
    const x = coeffterm.value;
    if (x == terms[targCoeff]) return;
    const terms_ = terms.slice(0);
    terms_[targCoeff] = x;
    grad.value = getContFracValue(terms_);
  });
  const rawzterm = liveValue(['z_slider'], 0, x => clamp(x, 0, 1));

  const canvas = document.getElementById('view');
  const crystalCanvas = document.getElementById('crystal_view');
  const domContFrac = document.getElementById('cont_frac');
  const domApproxEqual = document.getElementById('approx_equal');
  const domApproxFrac = document.getElementById('approx_frac');
  const domWord = document.getElementById('word');
  const domZSliderWrap = document.getElementById('z_slider_wrap');
  const domCoeffSliderWrap = document.getElementById('coeff_slider_wrap');

  const domAdvancedOptions = document.getElementById('advanced_options');
  const domFlagAdvanced = document.getElementById('flag_advanced');
  domFlagAdvanced.addEventListener('change', () => {
    if (domFlagAdvanced.checked) {
      domAdvancedOptions.classList.remove('hidden');
    } else {
      domAdvancedOptions.classList.add('hidden');
    }
  });

  const makeFlag = (name, initValue = false) => {
    const flag = { value: initValue };
    const div = newDiv(domAdvancedOptions, ['flag']);
    const check = newElement('input', div);
    check.setAttribute('type', 'checkbox');
    if (initValue) check.setAttribute('checked', true);
    check.addEventListener('change', () => {
      forceRedraw = true;
      flag.value = check.checked;
    });
    const label = newElement('span', div, [], name);
    return flag;
  };

  const flagShowConvergents = makeFlag('Show convergents');
  const flagShowSteps = makeFlag('Show steps');
  const flagShowCrystal = makeFlag('Show crystal');
  const flagUnitCellMode = makeFlag('Unit cell mode');
  const flagContFracEdit = makeFlag('Editable fraction');
  const flagShowZ = makeFlag('Show Z term');

  const isInZMode = () => flagShowZ.value && !flagContFracEdit.value;
  const getZ = () => {
    const x = isInZMode() ? rawzterm.value : 0;
    if (x == 0) return [0, 1];
    if (x == 1) return [1, 0];
    if (x == 0.5) return [1, 1];
    const y = squishy(x, 8);
    const z = (1 / (1 - y)) - 1;
    return x < 0.5 ? [1, Math.floor(1 / z)] : [Math.floor(z), 1];
  };

  const fillContFracDom = (terms, zn, zd) => {
    emptyDiv(domContFrac);
    let n = terms.length;
    const trunc = n > visibleContFracTerms;
    if (trunc) n = visibleContFracTerms;
    --n;
    let node = domContFrac;
    const termDivs = [];

    const addTerm = (i, suffix, cls) => {
      const termWrap = newDiv(node, [cls]);
      const term = newDiv(termWrap, [], terms[i]);
      if (flagContFracEdit.value) {
        termWrap.classList.add('cont-frac-term-wrap');
        term.classList.add('cont-frac-term-clickable');
        if (targCoeff == i) {
          termWrap.classList.add('selected');
        }
        term.addEventListener('click', () => {
          for (const t of termDivs) {
            t.classList.remove('selected');
          }
          termWrap.classList.add('selected');
          targCoeff = i;
          coeffterm.value = terms[i];
        });
        newDiv(termWrap, ['cont-frac-term-line']);
      }
      termDivs.push(termWrap);
      if (suffix != '') newDiv(node, [cls], suffix);
    };

    for (let i = 0; i < n; ++i) {
      if (flagContFracEdit.value || !(i == 0 && terms[i] == 0)) {
        addTerm(i, ' + ', 'cont-frac-term');
      }
      const frac = newDiv(node, ['cont-frac-frac']);
      newDiv(frac, ['cont-frac-num'], '1');
      node = newDiv(frac, ['cont-frac-den']);
    }

    if (flagContFracEdit.value) {
      domCoeffSliderWrap.classList.remove('hidden');
    } else {
      domCoeffSliderWrap.classList.add('hidden');
      targCoeff = 0;
    }

    if (isInZMode()) {
      domZSliderWrap.classList.remove('hidden');
      const haszd = zd > 1;
      addTerm(n, ' + ', haszd ? 'cont-frac-term' : 'cont-frac-term-end');
      const frac = newDiv(node, ['cont-frac-frac']);
      newDiv(frac, ['cont-frac-num'], zd == 0 ? '∞' : zn);
      if (haszd) newDiv(frac, ['cont-frac-den'], zd);
    } else {
      addTerm(n, trunc ? ' ...' : '', 'cont-frac-term-end');
      domZSliderWrap.classList.add('hidden');
    }
  }

  const fillApproxFracDom = (terms, zn, zd) => {
    const [y, x] = getApproxFrac(terms, approxContFracTerms, zn, zd);
    emptyDiv(domApproxFrac);
    newDiv(domApproxFrac, ['approx-frac-num'], y);
    if (x != 1) newDiv(domApproxFrac, ['approx-frac-den'], x);
    domApproxEqual.innerText = approxContFracTerms < terms.length ? '≈' : '=';
  }

  let mainViewZoomExp = 0;
  const getMainViewSize = () =>
      mainViewSize * Math.pow(mainViewZoomRate, mainViewZoomExp);

  const getViewSize = () =>
      flagUnitCellMode.value ? cellViewSize : getMainViewSize();

  let mouseClicked = false;
  const onMouse = (e, click) => {
    e.preventDefault();
    const viewSize = getViewSize();
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.x;
    const my = e.clientY - rect.y;
    let x = viewSize * mx / canvas.width;
    let y = viewSize * (1 - my / canvas.height);
    if (!click) {
      const px = Math.floor(x + 0.5);
      const py = Math.floor(y + 0.5);
      if (px >= 0 && py >= 0 && px <= viewSize && py <= viewSize) {
        const dx = x - px;
        const dy = y - py;
        if ((dx * dx + dy * dy) < 0.05) {
          x = px;
          y = py;
        }
      }
    }
    y += off.value;
    if (x <= 0) {
      grad.value = 1e3;
    } else if (y <= 0) {
      grad.value = 0;
    } else {
      grad.value = y / x;
    }
    targX = x;
    targY = y;
    targKeep = true;
  };
  canvas.addEventListener('mousedown', e => {
    onMouse(e, mouseClicked = true);
  });
  document.addEventListener('mousemove', e => {
    if (mouseClicked) onMouse(e, mouseClicked);
  });
  document.addEventListener('mouseup', e => {
    if (mouseClicked) onMouse(e, mouseClicked = false);
  });
  const onZoom = delta => {
    forceRedraw = true;
    mainViewZoomExp = clamp(mainViewZoomExp + delta, -20, 10);
  };
  canvas.addEventListener('wheel', e => {
    onZoom(0.01 * e.deltaY);
  });

  const circle = (cc, px, py, r, clr) => {
    cc.fillStyle = clr;
    cc.beginPath();
    cc.ellipse(px, py, r, r, 0, 0, tau);
    cc.fill();
  };

  const line = (cc, px, py, qx, qy, clr) => {
    cc.strokeStyle = clr;
    cc.beginPath();
    cc.moveTo(px, py);
    cc.lineTo(qx, qy);
    cc.stroke();
  };

  const ray = (cc, px, py, dx, dy, clr) => {
    const len = 2 * getMainViewSize();
    line(cc, px, py, px + len * dx, py + len * dy, clr);
  };

  const update = () => {
    for (const fn of onFrameCallbacks) fn();

    if (alwaysRedraw || forceRedraw) {
      forceRedraw = false;
      const viewSize = getViewSize();
      const mainDotSize = mainDotInitSize * Math.sqrt(viewSize / mainViewSize);
      const dotSize = flagUnitCellMode.value ? cellDotSize : mainDotSize;
      const lineSize = flagUnitCellMode.value ? cellLineSize : mainLineSize;
      const ctx = setupCanvas(canvas, viewSize, lineSize);
      const g = grad.value;
      const o = off.value;
      const gx = 1 / Math.sqrt(1 + g * g);
      const gy = gx * g;
      const hitRad = (1 + g) / Math.sqrt(1 + g * g);
      const hitGx = gy;
      const hitGy = -gx;
      const hitSx = hitGx * hitRad;
      const hitSy = hitGy * hitRad;
      const hitOx = 0;
      const hitOy = -o;
      const [zn, zd] = getZ();

      const terms = getContFracTerms(g, contFracTerms);
      const sequence = sequenceFromGrad(g, o, genSeqLength);

      // Clear to black.
      ctx.fillStyle = 'rgba(0, 0, 0, 1)';
      ctx.fillRect(-2 * viewSize, -2 * viewSize, 4 * viewSize, 4 * viewSize);

      // Draw kernel lines.
      const kernDraw = viewSize + 1;
      for (let i = -1; i <= kernDraw; ++i) {
        for (let j = -1; j <= kernDraw; ++j) {
          line(ctx, i, j, i + hitSx, j + hitSy, 'rgba(68, 68, 68, 1)');
        }
      }

      // Draw dots.
      for (let i = 0; i <= viewSize; ++i) {
        for (let j = 0; j <= viewSize; ++j) {
          circle(ctx, i, j, dotSize, 'rgba(68, 68, 68, 1)');
        }
      }

      // Calculate ray hits.
      let px = 0;
      let py = 0;
      const hits = [];
      for (const goUp of sequence) {
        const x = px + (goUp ? 0 : 1);
        const y = py + (goUp ? 1 : 0);
        const k = gx * (x - hitOx) + gy * (y - hitOy);
        const ux = hitOx + k * gx;
        const uy = hitOy + k * gy;
        hits.push([px, py, x, y, ux, uy, k]);
        px = x;
        py = y;
      }

      if (!flagUnitCellMode.value) {  // Normal mode.
        // Draw ray.
        ray(ctx, hitOx, hitOy, gx, gy, 'rgba(255, 255, 255, 1)');

        // Draw z, z=0, and z=inf lines, if in z mode.
        if (isInZMode()) {
          const zvec = (n, d) => {
            const [y, x] = getApproxFrac(terms, approxContFracTerms, n, d);
            const [gy, gx] = unit(y, x);
            ray(ctx, hitOx, hitOy, gx, gy, 'rgba(255, 255, 255, 0.5)');
          };
          zvec(zn, zd);
          zvec(0, 1);
          zvec(1, 0);
        }

        // Draw hit kernel lines.
        for (const [px, py, x, y, ux, uy, k] of hits) {
          line(ctx, x, y, ux, uy, 'rgba(0, 136, 255, 1)');
          circle(ctx, x, y, dotSize, 'rgba(0, 136, 255, 1)');
        }

        // Draw hit dots.
        for (const [px, py, x, y, ux, uy, k] of hits) {
          circle(ctx, ux, uy, 2 * dotSize, 'rgba(255, 34, 0, 1)');
        }

        // Draw steps.
        if (flagShowSteps.value) {
          for (const [px, py, x, y, ux, uy, k] of hits) {
            line(ctx, px, py, x, y, 'rgba(0, 255, 0, 0.8)');
          }
        }

        // Draw convergents, if enabled.
        if (flagShowConvergents.value) {
          for (let i = 1; i <= terms.length; ++i) {
            const [y, x] = getApproxFrac(terms, i);
            circle(ctx, x, y, 2 * dotSize, 'rgba(255, 255, 0, 1)');
          }
        }
      } else {  // Unit cell mode.
        // Draw ray.
        const rcc = getRayCellCrossings(gx, gy, hitOx, hitOy, cellRayLength);
        for (const [ax, ay, ak, bx, by, bk] of rcc) {
          const grd = ctx.createLinearGradient(ax, ay, bx, by);
          grd.addColorStop(0, `rgba(255, 255, 0, ${1 - ak})`);
          grd.addColorStop(1, `rgba(255, 255, 0, ${1 - bk})`);
          line(ctx, ax, ay, bx, by, grd);
        }

        // Modulo all the ray hits into the unit cell.
        const modhits = [];
        for (const [px, py, x, y, ux, uy, k] of hits) {
          if (k > cellRayLength) break;
          const mux = fmod(ux);
          const muy = fmod(uy);
          const gux = x + mux - ux;
          const guy = y + muy - uy;
          const alpha = 1 - k / cellRayLength;
          modhits.push([mux, muy, gux, guy, alpha])
        }

        // Draw hit kernel lines.
        for (const [mux, muy, gux, guy, alpha] of modhits) {
          line(ctx, gux, guy, mux, muy, `rgba(0, 136, 255, ${alpha})`);
          circle(ctx, gux, guy, dotSize, `rgba(0, 136, 255, ${alpha})`);
        }

        // Draw hit dots.
        for (const [mux, muy, gux, guy, alpha] of modhits) {
          circle(ctx, mux, muy, dotSize, `rgba(255, 34, 0, 1)`);
        }
      }

      // Draw target point, if it exists.
      if (targX != null && targY != null) {
        circle(ctx, targX, targY, 2 * dotSize, 'rgba(255, 255, 255, 1)');
      }

      // Fill continued fraction and approx fraction.
      fillContFracDom(terms, zn, zd);
      fillApproxFracDom(terms, zn, zd);

      // Fill word.
      const word = sequence.map(x => x ? 'S' : 'L').join('');
      domWord.innerText = word;

      // Draw the crystal, if enabled.
      if (flagShowCrystal.value) {
        const viewSize = getMainViewSize();
        const crystalCtx = setupCanvas(crystalCanvas, viewSize);
        crystalCanvas.classList.remove('hidden');
        crystalCtx.fillStyle = 'rgba(0, 0, 0, 1)';
        crystalCtx.fillRect(
          -2 * viewSize, -2 * viewSize, 4 * viewSize, 4 * viewSize);
        const midy = 0.025 * viewSize;
        line(crystalCtx, 0, midy, viewSize, midy, 'rgba(255, 255, 255, 1)');
        for (const [px, py, x, y, ux, uy, k] of hits) {
          circle(crystalCtx, k, midy, 2 * mainDotSize, 'rgba(255, 34, 0, 1)');
        }
      } else {
        crystalCanvas.classList.add('hidden');
      }
    }

    window.requestAnimationFrame(update);
  };
  update();
}
window.addEventListener('load', onLoad);
</script>
<style>
html {
  min-height: 100%;
}
body {
  background-color: #212121;
  margin: 0;
}
#head {
  background-color: #424242;
  width: 100%;
  display: flex;
  justify-content: space-around;
  margin-bottom: 16px;
}
h1, #index {
  color: #ffc107;
  text-align: center;
  font-family: monospace;
  font-size: 42px;
  flex-grow: 1;
  padding: 16px;
  margin: 0;
}
#index {
  color: #ff5722;
  text-decoration: none;
  flex-grow: 0;
}
h2 {
  color: #ff5722;
  font-family: monospace;
}
a {
  color: #ffc107;
  font-family: monospace;
  font-size: 16px;
  cursor: pointer;
  text-decoration: underline;
}
#wrap {
  padding: 0 16px;
  color: #f5f5f5;
  font-family: monospace;
  font-size: 16px;
}
#layout {
  display: flex;
  flex-direction: row;
  width: 100%;
  gap: 16px;
}
#left {
  flex-grow: 1;
}
#middle {
  display: flex;
  flex-direction: column;
}
#right {
  display: flex;
  flex-direction: column;
  width: 400px;
}
#word {
  overflow: hidden;
  text-overflow: ellipsis;
  width: 350px;
}
.cont-frac-term {
  margin-top: 0.6em;
}
.cont-frac-term-end {
  margin-top: 0;
}
.cont-frac-frac {
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.cont-frac-num, .approx-frac-num {
  text-align: center;
}
#cont_frac, .cont-frac-den {
  display: flex;
  flex-direction: row;
  justify-content: center;
  gap: 4px;
}
.cont-frac-den, .approx-frac-den {
  border-top: 2px solid #f5f5f5;
  text-align: center;
}
.cont-frac-term-wrap {
  display: flex;
  flex-direction: column;
  justify-content: top;
  align-items: center;
  min-height: 30px;
}
.cont-frac-term-clickable {
  cursor: pointer;
}
.cont-frac-term-clickable:hover {
  background-color: rgba(0, 128, 255, 0.5);
}
.selected .cont-frac-term-clickable {
  background-color: rgba(0, 128, 255, 1);
}
.cont-frac-term-line {
  display: none;
  background-color: rgba(0, 128, 255, 1);
  flex-grow: 1;
  width: 1px;
}
.selected .cont-frac-term-line {
  display: block;
}
.frac-row {
  display: flex;
  flex-direction: row;
  width: 100%;
  gap: 8px;
  justify-content: center;
  align-items: center;
  min-height: 140px;
}
#approx_equal {
  font-size: 32px;
}
#approx_frac {
  display: flex;
  flex-direction: column;
  justify-content: center;
}
#z_slider_wrap, #coeff_slider_wrap {
  display: flex;
  flex-direction: row;
  justify-content: center;
  gap: 4px;
}
#z_slider, #coeff_slider {
  flex-grow: 1;
}
.hidden {
  display: none !important;
}
#advanced_options {
  background-color: #FFF1;
}
.flag {
  display: flex;
  flex-direction: row;
  width: 100%;
  gap: 8px;
  justify-content: flex-start;
}
slide-show {
  display: none;
}
slide-show.loaded {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}
.slide-show-slide-row {
  width: 100%;
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  gap: 8px;
}
.slide-show-dot-row {
  width: 100%;
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
  gap: 8px;
}
.slide-show-dot {
  cursor: pointer;
  width: 8px;
  height: 8px;
  border-radius: 4px;
  background-color: #FFF2;
}
.slide-show-dot.active {
  background-color: #FFF;
}
.slide-show-button {
  cursor: pointer;
  user-select: none;
}
</style>
</head>
<body>
<div id="head">
  <a id="index" href="index.html">&lt;</a>
  <h1>Quasi Crystals (Prototype)</h1>
</div>
<div id="wrap">
  <div id="layout">
    <div id="left">
      <slide-show button-layout="low">
        <span>Blog stuff goes here.</span>
        <span>More text.</span>
        <div>
          YouTube embed:<br/>
          <iframe width="560" height="315" src="https://www.youtube.com/embed/AaQD-cyXH2A" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
        </div>
      </slide-show>
    </div>
    <div id="middle">
      <canvas id="view" width="800" height="800"></canvas>
      <canvas id="crystal_view" width="800" height="40" class="hidden"></canvas>
    </div>
    <div id="right">
      Gradient: <input type="text" id="in_grad"/>
      <input type="range" id="ins_grad" min="0" max="1" step="0.001"/><br/>
      Offset: <input type="text" id="in_off"/>
      <input type="range" id="ins_off" min="0" max="0.999" step="0.001"/><br/>
      <br/>
      Sequence:<br/>
      <div id="word"></div>
      <br/>
      Continued Fraction:<br/>
      <div class="frac-row">
        <div id="cont_frac"></div>
        <div id="approx_equal"></div>
        <div id="approx_frac"></div>
      </div>
      <div id="coeff_slider_wrap" class="hidden">
        <input type="range" id="coeff_slider" min="1" max="30" step="1"/><br/>
      </div>
      <div id="z_slider_wrap" class="hidden">
        Z:
        <input type="range" id="z_slider" min="0" max="1" step="0.01"
            value="0"/><br/>
      </div>
      <br/>
      <div class="flag">
        <input type="checkbox" id="flag_advanced"/>
        <span>Advanced options</span>
      </div>
      <div id="advanced_options" class="hidden">
      </div>
    </div>
  </div>
</div>
</body>
</html>
