<!DOCTYPE html>
<html>
<head>
<title>Quasi Crystals</title>
<link rel="icon" href="res/favicon.ico">
<script src="slide_show.js"></script>
<script type="text/javascript">

// Config
const viewSize = 10;
const contFracTerms = 10;  // Max is around 30 before float errors.
const visibleContFracTerms = 6;
const approxContFracTerms = 7;
const epsilon = 1e-6;
const alwaysRedraw = false;
const maxSeqLength = 1000;  // Way more than what we display.
const genSeqLength = 100;

const tau = 2 * Math.PI;

function fmod(x, y = 1) {
  const z = x / y;
  return (z - Math.floor(z)) * y;
}

function newElement(type, parent, classes = [], text = null) {
  const n = document.createElement(type);
  if (text != null) n.innerText = text;
  for (const cls of classes) n.classList.add(cls);
  if (parent != null) parent.appendChild(n);
  return n;
}

function newDiv(parent, classes = [], text = null) {
  return newElement('div', parent, classes, text);
}

function getContFracTerms(x, maxTerms) {
  const terms = [];
  for (let i = 0; i < maxTerms; ++i) {
    const c = Math.floor(x);
    terms.push(c);
    const r = x - c;
    if (r < epsilon) break;
    x = 1 / r;
  }
  return terms;
}

function getApproxFrac(terms, maxTerms) {
  const first = Math.min(terms.length, maxTerms) - 1;
  const frac = [1, 0];
  for (let i = first; i >= 0; --i) {
    const y = frac[0];
    frac[0] = terms[i] * y + frac[1];
    frac[1] = y;
  }
  return frac;
}

function repeatStr(s, n, max) {
  let t = '';
  while (n > 0) {
    if (n & 1) t += s;
    s += s;
    n >>>= 1;
    if (t.length >= max) break;
  }
  return t;
}

function wordFromContFracTerms(terms) {
  let w = '';
  let w1 = 'S';
  let w2 = 'L';
  for (let i = 0; i < terms.length; ++i) {
    const wr = repeatStr(w1, terms[i], maxSeqLength);
    w = (i % 2 == 0) ? wr + w2 : w2 + wr;
    if (w.length >= maxSeqLength) return w.substr(0, maxSeqLength);
    w2 = w1;
    w1 = w;
  }
  return w;
}

function sequenceFromGrad(x, o, len) {
  let m = o;
  let n = 1;
  const a = [];
  for (let i = 0; i < len; ++i) {
    if (n * x > m) {
      ++m;
      a.push(true);
    } else {
      ++n;
      a.push(false);
    }
  }
  return a;
}

function safeGet(node, defaultValue, isValid = (x => true)) {
  const value = parseFloat(node.value);
  if (isNaN(value) || !isValid(value)) return defaultValue;
  return value;
}

function newElement(type, parent, classes = [], text = null) {
  const n = document.createElement(type);
  if (text != null) n.innerText = text;
  for (const cls of classes) n.classList.add(cls);
  if (parent != null) parent.appendChild(n);
  return n;
}

function newDiv(parent, classes = [], text = null) {
  return newElement('div', parent, classes, text);
}

function emptyDiv(n) {
  while (n.hasChildNodes()) n.removeChild(n.lastChild);
}

function fillContFracDom(node, terms) {
  emptyDiv(node);
  let n = terms.length;
  const trunc = n > visibleContFracTerms;
  if (trunc) n = visibleContFracTerms;
  --n;
  for (let i = 0; i < n; ++i) {
    if (!(i == 0 && terms[i] == 0)) {
      newDiv(node, ['cont-frac-term-inner'], `${terms[i]} + `);
    }
    const frac = newDiv(node, ['cont-frac-frac']);
    newDiv(frac, ['cont-frac-num'], '1');
    node = newDiv(frac, ['cont-frac-den']);
  }
  newDiv(node, ['cont-frac-term'], `${terms[n]}${trunc ? ' ...' : ''}`);
}

function fillApproxFracDom(node, terms) {
  emptyDiv(node);
  newDiv(node, ['approx-frac-num'], terms[0]);
  newDiv(node, ['approx-frac-den'], terms[1]);
}

function runUnitTests() {
  let anyFails = false;
  const testWord = (terms, expectedWord) => {
    const word = wordFromContFracTerms(terms);
    if (word != expectedWord) {
      console.error(`wordFromContFracTerms([${terms}]) produced ${word} instead of ${expectedWord}`);
      anyFails = true;
    }
  };

  testWord([], '');
  testWord([1], 'SL');
  testWord([1, 1], 'SSL');
  testWord([1, 1, 1], 'SSLSL');
  testWord([1, 1, 1, 1], 'SSLSSLSL');
  testWord([1, 1, 1, 1, 1], 'SSLSSLSLSSLSL');
  testWord([1, 1, 1, 1, 1, 1], 'SSLSSLSLSSLSSLSLSSLSL');
  testWord([1, 6, 2, 3, 1, 2], 'SSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSL');
  testWord([0, 2, 2], 'SLLSLLL');

  if (!anyFails) {
    console.log('All tests passed :)');
  }
}

function setupCanvas(canvas, viewWidth) {
  const ctx = canvas.getContext('2d');
  ctx.setTransform(
      canvas.width / viewWidth, 0,
      0, -canvas.width / viewWidth,
      0, canvas.height);
  ctx.lineWidth = viewWidth / canvas.width;
  return ctx;
}

function onLoad() {
  runUnitTests();

  let forceRedraw = true;
  const onFrameCallbacks = [];

  const liveValue = (ids, init = 0, validate = x => x, onchange = () => {}) => {
    // Does a few things:
    // - Maintains the invariant that each dom element has the same value.
    // - Whenever the value changes, sets forceRedraw to true.
    // - Uses validate to sanitize, a function from float to nullable float.
    // - Returns an object with a value field that is kept up to date.
    // - Changes to that field are also reflected on the elements.
    const elements = ids.map(id => document.getElementById(id));
    const oldValues = [];  // One for each element, and one for obj.value.
    for (const e of elements) {
      e.value = init;
      oldValues.push(e.value);
    }
    const obj = { value: init };
    oldValues.push(obj.value);
    onFrameCallbacks.push(() => {
      let anyChange = obj.value != oldValues[elements.length];
      let cause = null;
      if (!anyChange) {
        for (let i = 0; i < elements.length; ++i) {
          const e = elements[i];
          if (e.value != oldValues[i]) {
            const px = parseFloat(e.value);
            const x = isNaN(px) ? null : validate(px);
            if (x != null) {
              anyChange = true;
              obj.value = x;
              cause = i;
              break;
            }
          }
        }
      }
      if (anyChange) {
        forceRedraw = true;
        oldValues[elements.length] = obj.value;
        for (let i = 0; i < elements.length; ++i) {
          const e = elements[i];
          if (i != cause) {
            e.value = obj.value;
          }
          oldValues[i] = e.value;
        }
        onchange();
      }
    });
    return obj;
  };

  let targKeep = false;
  let targX = null;
  let targY = null;
  const grad = liveValue(
      ['in_grad', 'ins_grad'], 0.618033988749894, x => x >= 0 ? x : 0, () => {
    if (targKeep) {
      targKeep = false;
    } else {
      targX = null;
      targY = null;
    }
  });
  const off = liveValue(['in_off', 'ins_off'], 0, x => fmod(x));

  const canvas = document.getElementById('view');
  const crystalCanvas = document.getElementById('crystal_view');
  const domContFrac = document.getElementById('cont_frac');
  const domApproxFrac = document.getElementById('approx_frac');
  const domWord = document.getElementById('word');

  const domAdvancedOptions = document.getElementById('advanced_options');
  const domFlagAdvanced = document.getElementById('flag_advanced');
  domFlagAdvanced.addEventListener('change', () => {
    if (domFlagAdvanced.checked) {
      domAdvancedOptions.classList.remove('hidden');
    } else {
      domAdvancedOptions.classList.add('hidden');
    }
  });

  const makeFlag = (name, initValue = false) => {
    const flag = { value: initValue };
    const div = newDiv(domAdvancedOptions, ['flag']);
    const check = newElement('input', div);
    check.setAttribute('type', 'checkbox');
    if (initValue) check.setAttribute('checked', true);
    check.addEventListener('change', () => {
      forceRedraw = true;
      flag.value = check.checked;
    });
    const label = newElement('span', div, [], name);
    return flag;
  };

  const flagShowConvergents = makeFlag('Show convergents');
  const flagShowSteps = makeFlag('Show steps');
  const flagShowCrystal = makeFlag('Show crystal');

  const ctx = setupCanvas(canvas, viewSize);
  const crystalCtx = setupCanvas(crystalCanvas, viewSize);

  const dotSize = 0.003 * viewSize;

  let mouseClicked = false;
  const onMouse = (e, click) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    console.log(e.clientY, rect.y);
    const mx = e.clientX - rect.x;
    const my = e.clientY - rect.y;
    let x = viewSize * mx / canvas.width;
    let y = viewSize * (1 - my / canvas.height);
    if (!click) {
      const px = Math.floor(x + 0.5);
      const py = Math.floor(y + 0.5);
      if (px >= 0 && py >= 0 && px <= viewSize && py <= viewSize) {
        const dx = x - px;
        const dy = y - py;
        if ((dx * dx + dy * dy) < 0.05) {
          x = px;
          y = py;
        }
      }
    }
    y += off.value;
    if (x <= 0) {
      grad.value = 1e3;
    } else if (y <= 0) {
      grad.value = 0;
    } else {
      grad.value = y / x;
    }
    targX = x;
    targY = y;
    targKeep = true;
  };
  canvas.addEventListener('mousedown', e => {
    onMouse(e, mouseClicked = true);
  });
  document.addEventListener('mousemove', e => {
    if (mouseClicked) onMouse(e, mouseClicked);
  });
  document.addEventListener('mouseup', e => {
    if (mouseClicked) onMouse(e, mouseClicked = false);
  });

  const circle = (cc, px, py, r, clr) => {
    cc.fillStyle = clr;
    cc.beginPath();
    cc.ellipse(px, py, r, r, 0, 0, tau);
    cc.fill();
  };

  const line = (cc, px, py, qx, qy, clr) => {
    cc.strokeStyle = clr;
    cc.beginPath();
    cc.moveTo(px, py);
    cc.lineTo(qx, qy);
    cc.stroke();
  };

  const ray = (cc, px, py, dx, dy, clr) => {
    line(cc, px, py, px + 2 * viewSize * dx, py + 2 * viewSize * dy, clr);
  };

  const update = () => {
    for (const fn of onFrameCallbacks) fn();

    if (alwaysRedraw || forceRedraw) {
      forceRedraw = false;
      const g = grad.value;
      const o = off.value;
      const gx = 1 / Math.sqrt(1 + g * g);
      const gy = gx * g;
      const hitRad = (1 + g) / Math.sqrt(1 + g * g);
      const hitGx = gy;
      const hitGy = -gx;
      const hitSx = hitGx * hitRad;
      const hitSy = hitGy * hitRad;
      const hitOx = 0;
      const hitOy = -o;

      const terms = getContFracTerms(g, contFracTerms);
      const sequence = sequenceFromGrad(g, o, genSeqLength);

      // Clear to black.
      ctx.fillStyle = '#000';
      ctx.fillRect(-2 * viewSize, -2 * viewSize, 4 * viewSize, 4 * viewSize);

      // Draw kernel lines.
      for (let i = 0; i <= viewSize; ++i) {
        for (let j = 0; j <= viewSize; ++j) {
          line(ctx, i, j, i + hitSx, j + hitSy, '#222');
        }
      }

      // Draw dots.
      for (let i = 0; i <= viewSize; ++i) {
        for (let j = 0; j <= viewSize; ++j) {
          circle(ctx, i, j, dotSize, '#444');
        }
      }

      // Draw ray.
      ray(ctx, hitOx, hitOy, gx, gy, '#FFF');

      // Iterate through the sequence.
      let px = 0;
      let py = 0;
      const hits = [];
      for (const goUp of sequence) {
        const x = px + (goUp ? 0 : 1);
        const y = py + (goUp ? 1 : 0);
        const k = gx * (x - hitOx) + gy * (y - hitOy);
        const ux = hitOx + k * gx;
        const uy = hitOy + k * gy;

        // Draw hit dots.
        line(ctx, x, y, ux, uy, '#08F');
        circle(ctx, x, y, dotSize, '#08F');
        circle(ctx, ux, uy, 2 * dotSize, '#F20');

        // Draw steps.
        if (flagShowSteps.value) line(ctx, px, py, x, y, '#0F0C');

        px = x;
        py = y;
        hits.push(k);
      }

      // Draw convergents, if enabled.
      if (flagShowConvergents.value) {
        for (let i = 1; i <= terms.length; ++i) {
          const [y, x] = getApproxFrac(terms, i);
          circle(ctx, x, y, 2 * dotSize, '#FF0');
        }
      }

      // Draw target point, if it exists.
      if (targX != null && targY != null) {
        circle(ctx, targX, targY, 2 * dotSize, '#FFF');
      }

      // Fill continued fraction and approx fraction.
      fillContFracDom(domContFrac, terms);
      fillApproxFracDom(
          domApproxFrac, getApproxFrac(terms, approxContFracTerms));

      // Fill word.
      const word = sequence.map(x => x ? 'S' : 'L').join('');
      domWord.innerText = word;

      // Draw the crystal, if enabled.
      if (flagShowCrystal.value) {
        crystalCanvas.classList.remove('hidden');
        crystalCtx.fillStyle = '#000';
        crystalCtx.fillRect(
          -2 * viewSize, -2 * viewSize, 4 * viewSize, 4 * viewSize);
        const midy = 0.25;
        line(crystalCtx, 0, midy, viewSize, midy, '#FFF');
        for (const x of hits) {
          circle(crystalCtx, x, midy, 2 * dotSize, '#F20');
        }
      } else {
        crystalCanvas.classList.add('hidden');
      }
    }

    window.requestAnimationFrame(update);
  };
  update();
}
window.addEventListener('load', onLoad);
</script>
<style>
html {
  min-height: 100%;
}
body {
  background-color: #212121;
  margin: 0;
}
#head {
  background-color: #424242;
  width: 100%;
  display: flex;
  justify-content: space-around;
  margin-bottom: 16px;
}
h1, #index {
  color: #ffc107;
  text-align: center;
  font-family: monospace;
  font-size: 42px;
  flex-grow: 1;
  padding: 16px;
  margin: 0;
}
#index {
  color: #ff5722;
  text-decoration: none;
  flex-grow: 0;
}
h2 {
  color: #ff5722;
  font-family: monospace;
}
a {
  color: #ffc107;
  font-family: monospace;
  font-size: 16px;
  cursor: pointer;
  text-decoration: underline;
}
#wrap {
  padding: 0 16px;
  color: #f5f5f5;
  font-family: monospace;
  font-size: 16px;
}
#layout {
  display: flex;
  flex-direction: row;
  width: 100%;
  gap: 16px;
}
#left {
  flex-grow: 1;
}
#middle {
  display: flex;
  flex-direction: column;
}
#right {
  display: flex;
  flex-direction: column;
  width: 400px;
}
#word {
  overflow: hidden;
  text-overflow: ellipsis;
  width: 350px;
}
.cont-frac-term-inner {
  padding-top: 0.5em;
  padding-right: 0.7em;
}
.cont-frac-frac {
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.cont-frac-num, .approx-frac-num {
  text-align: center;
}
#cont_frac, .cont-frac-den {
  display: flex;
  flex-direction: row;
  justify-content: center;
}
.cont-frac-den, .approx-frac-den {
  border-top: 2px solid #f5f5f5;
  text-align: center;
}
.frac-row {
  display: flex;
  flex-direction: row;
  width: 100%;
  gap: 8px;
  justify-content: center;
  align-items: center;
  min-height: 130px;
}
#approx_equal {
  font-size: 32px;
}
#approx_frac {
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.hidden {
  display: none;
}
#advanced_options {
  background-color: #FFF1;
}
.flag {
  display: flex;
  flex-direction: row;
  width: 100%;
  gap: 8px;
  justify-content: flex-start;
}
slide-show {
  display: none;
}
slide-show.loaded {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}
.slide-show-slide-row {
  width: 100%;
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  gap: 8px;
}
.slide-show-dot-row {
  width: 100%;
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
  gap: 8px;
}
.slide-show-dot {
  cursor: pointer;
  width: 8px;
  height: 8px;
  border-radius: 4px;
  background-color: #FFF2;
}
.slide-show-dot.active {
  background-color: #FFF;
}
.slide-show-button {
  cursor: pointer;
  user-select: none;
}
</style>
</head>
<body>
<div id="head">
  <a id="index" href="index.html">&lt;</a>
  <h1>Quasi Crystals (Prototype)</h1>
</div>
<div id="wrap">
  <div id="layout">
    <div id="left">
      <slide-show button-layout="low">
        <span>Blog stuff goes here.</span>
        <span>More text.</span>
        <div>
          YouTube embed:<br/>
          <iframe width="560" height="315" src="https://www.youtube.com/embed/AaQD-cyXH2A" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
        </div>
      </slide-show>
    </div>
    <div id="middle">
      <canvas id="view" width="800" height="800"></canvas>
      <canvas id="crystal_view" width="800" height="40" class="hidden"></canvas>
    </div>
    <div id="right">
      Gradient: <input type="text" id="in_grad"/>
      <input type="range" id="ins_grad" min="0" max="1" step="0.001"/><br/>
      Offset: <input type="text" id="in_off"/>
      <input type="range" id="ins_off" min="0" max="0.999" step="0.001"/><br/>
      <br/>
      Sequence:<br/>
      <div id="word"></div>
      <br/>
      Continued Fraction:<br/>
      <div class="frac-row">
        <div id="cont_frac"></div>
        <div id="approx_equal">≈</div>
        <div id="approx_frac"></div>
      </div>
      <br/>
      <div class="flag">
        <input type="checkbox" id="flag_advanced"/>
        <span>Advanced options</span>
      </div>
      <div id="advanced_options" class="hidden">
      </div>
    </div>
  </div>
</div>
</body>
</html>
