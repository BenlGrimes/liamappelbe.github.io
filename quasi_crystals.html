<!DOCTYPE html>
<html>
<head>
<title>Quasi Crystals</title>
<link rel="icon" href="res/favicon.ico">
<script type="text/javascript">

// Config
const viewSize = 10;
const contFracTerms = 10;  // Max is around 30 before float errors.
const visibleContFracTerms = 6;
const approxContFracTerms = 7;
const epsilon = 1e-6;
const alwaysRedraw = false;
const maxSeqLength = 1000;  // Way more than what we display.
const genSeqLength = 30;

function fmod(x, y = 1) {
  const z = x / y;
  return (z - Math.floor(z)) * y;
}

function newElement(type, parent, classes = [], text = null) {
  const n = document.createElement(type);
  if (text != null) n.innerText = text;
  for (const cls of classes) n.classList.add(cls);
  if (parent != null) parent.appendChild(n);
  return n;
}

function newDiv(parent, classes = [], text = null) {
  return newElement('div', parent, classes, text);
}

function getContFracTerms(x, maxTerms) {
  const terms = [];
  for (let i = 0; i < maxTerms; ++i) {
    const c = Math.floor(x);
    terms.push(c);
    const r = x - c;
    if (r < epsilon) break;
    x = 1 / r;
  }
  return terms;
}

function getApproxFrac(terms, maxTerms) {
  const first = Math.min(terms.length, maxTerms) - 1;
  const frac = [1, 0];
  for (let i = first; i >= 0; --i) {
    const x = frac[0];
    frac[0] = terms[i] * x + frac[1];
    frac[1] = x;
  }
  return frac;
}

function repeatStr(s, n, max) {
  let t = '';
  while (n > 0) {
    if (n & 1) t += s;
    s += s;
    n >>>= 1;
    if (t.length >= max) break;
  }
  return t;
}

function wordFromContFracTerms(terms) {
  let w = '';
  let w1 = 'S';
  let w2 = 'L';
  for (let i = 0; i < terms.length; ++i) {
    const wr = repeatStr(w1, terms[i], maxSeqLength);
    w = (i % 2 == 0) ? wr + w2 : w2 + wr;
    if (w.length >= maxSeqLength) return w.substr(0, maxSeqLength);
    w2 = w1;
    w1 = w;
  }
  return w;
}

function sequenceFromGrad(x, o, len) {
  let m = o;
  let n = 1;
  const a = [];
  for (let i = 0; i < len; ++i) {
    if (n * x >= m) {
      ++m;
      a.push(true);
    } else {
      ++n;
      a.push(false);
    }
  }
  return a;
}

function safeGet(node, defaultValue, isValid = (x => true)) {
  const value = parseFloat(node.value);
  if (isNaN(value) || !isValid(value)) return defaultValue;
  return value;
}

function newElement(type, parent, classes = [], text = null) {
  const n = document.createElement(type);
  if (text != null) n.innerText = text;
  for (const cls of classes) n.classList.add(cls);
  if (parent != null) parent.appendChild(n);
  return n;
}

function newDiv(parent, classes = [], text = null) {
  return newElement('div', parent, classes, text);
}

function emptyDiv(n) {
  while (n.hasChildNodes()) n.removeChild(n.lastChild);
}

function fillContFracDom(node, terms) {
  emptyDiv(node);
  let n = terms.length;
  const trunc = n > visibleContFracTerms;
  if (trunc) n = visibleContFracTerms;
  --n;
  for (let i = 0; i < n; ++i) {
    if (!(i == 0 && terms[i] == 0)) {
      newDiv(node, ['cont-frac-term-inner'], `${terms[i]} + `);
    }
    const frac = newDiv(node, ['cont-frac-frac']);
    newDiv(frac, ['cont-frac-num'], '1');
    node = newDiv(frac, ['cont-frac-den']);
  }
  newDiv(node, ['cont-frac-term'], `${terms[n]}${trunc ? ' ...' : ''}`);
}

function fillApproxFracDom(node, terms) {
  emptyDiv(node);
  newDiv(node, ['approx-frac-num'], terms[0]);
  newDiv(node, ['approx-frac-den'], terms[1]);
}

function runUnitTests() {
  let anyFails = false;
  const testWord = (terms, expectedWord) => {
    const word = wordFromContFracTerms(terms);
    if (word != expectedWord) {
      console.error(`wordFromContFracTerms([${terms}]) produced ${word} instead of ${expectedWord}`);
      anyFails = true;
    }
  };

  testWord([], '');
  testWord([1], 'SL');
  testWord([1, 1], 'SSL');
  testWord([1, 1, 1], 'SSLSL');
  testWord([1, 1, 1, 1], 'SSLSSLSL');
  testWord([1, 1, 1, 1, 1], 'SSLSSLSLSSLSL');
  testWord([1, 1, 1, 1, 1, 1], 'SSLSSLSLSSLSSLSLSSLSL');
  testWord([1, 6, 2, 3, 1, 2], 'SSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSL');
  testWord([0, 2, 2], 'SLLSLLL');

  if (!anyFails) {
    console.log('All tests passed :)');
  }
}

function onLoad() {
  runUnitTests();

  let forceRedraw = true;

  const inGrad = document.getElementById('in_grad');
  const inOff = document.getElementById('in_off');
  const canvas = document.getElementById('view');
  const domContFrac = document.getElementById('cont_frac');
  const domApproxFrac = document.getElementById('approx_frac');
  const domWord = document.getElementById('word');

  const domAdvancedOptions = document.getElementById('advanced_options');
  const domFlagAdvanced = document.getElementById('flag_advanced');
  domFlagAdvanced.addEventListener('change', () => {
    if (domFlagAdvanced.checked) {
      domAdvancedOptions.classList.remove('hidden');
    } else {
      domAdvancedOptions.classList.add('hidden');
    }
  });

  const makeFlag = (name, initValue = false) => {
    const flag = { value: initValue };
    const div = newDiv(domAdvancedOptions, ['flag']);
    const check = newElement('input', div);
    check.setAttribute('type', 'checkbox');
    if (initValue) check.setAttribute('checked', true);
    check.addEventListener('change', () => {
      forceRedraw = true;
      flag.value = check.checked;
    });
    const label = newElement('span', div, [], name);
    return flag;
  };

  const flagShowSteps = makeFlag('Show steps');

  const ctx = canvas.getContext('2d');
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  const tau = 2 * Math.PI;
  const halfWidth = canvas.width / 2;
  const halfHeight = canvas.height / 2;
  const dotSize = 0.003 * viewSize;
  const posX = 0.5 * viewSize;
  const posY = 0.5 * viewSize;
  ctx.setTransform(
      2 * halfWidth / viewSize, 0, 0, -2 * halfHeight / viewSize,
      0, halfHeight * (1 + 2 * posY / viewSize));
  ctx.lineWidth = viewSize / (halfWidth + halfHeight);

  const circle = (px, py, r, clr) => {
    ctx.fillStyle = clr;
    ctx.beginPath();
    ctx.ellipse(px, py, r, r, 0, 0, tau);
    ctx.fill();
  };

  const line = (px, py, qx, qy, clr) => {
    ctx.strokeStyle = clr;
    ctx.beginPath();
    ctx.moveTo(px, py);
    ctx.lineTo(qx, qy);
    ctx.stroke();
  };

  const ray = (px, py, dx, dy, clr) => {
    line(px, py, px + 2 * viewSize * dx, py + 2 * viewSize * dy, clr);
  };

  let grad = 0;
  let off = 0;
  const update = () => {
    const oldGrad = grad;
    const oldOff = off;
    grad = safeGet(inGrad, grad, x => x >= 0);
    off = fmod(safeGet(inOff, off));
    const needsRedraw =
        alwaysRedraw || forceRedraw || oldGrad != grad || oldOff != off;

    if (needsRedraw) {
      forceRedraw = false;
      gx = 1 / Math.sqrt(1 + grad * grad);
      gy = gx * grad;
      hitRad = (1 + grad) / Math.sqrt(1 + grad * grad);
      hitGx = gy;
      hitGy = -gx;
      hitSx = hitGx * hitRad;
      hitSy = hitGy * hitRad;
      hitOx = 0;
      hitOy = -off;

      // Clear to black.
      ctx.fillStyle = '#000';
      ctx.fillRect(-2 * viewSize, -2 * viewSize, 4 * viewSize, 4 * viewSize);

      // Draw dots.
      for (let i = 0; i <= viewSize; ++i) {
        for (let j = 0; j <= viewSize; ++j) {
          circle(i, j, dotSize, '#FFF2');
        }
      }

      // Draw kernel lines.
      for (let i = 0; i <= viewSize; ++i) {
        for (let j = 0; j <= viewSize; ++j) {
          line(i, j, i + hitSx, j + hitSy, '#FFF1');
        }
      }

      // Draw ray.
      ray(hitOx, hitOy, gx, gy, '#FFF');

      // Draw hit dots. TODO: Maybe make this more efficient?
      for (let i = 0; i <= viewSize; ++i) {
        for (let j = 0; j <= viewSize; ++j) {
          const k = gx * (i - hitOx) + gy * (j - hitOy);
          const ux = hitOx + k * gx;
          const uy = hitOy + k * gy;
          const dx = i - ux;
          const dy = j - uy;
          if (((dy - dx) >= 0) && ((dx * dx + dy * dy) < hitRad * hitRad)) {
            line(i, j, ux, uy, '#08F');
            circle(i, j, dotSize, '#08F');
            circle(ux, uy, 2 * dotSize, '#F20');
          }
        }
      }

      // Fill continued fraction and approx fraction.
      const terms = getContFracTerms(grad, contFracTerms);
      const sequence = sequenceFromGrad(grad, off, genSeqLength);
      fillContFracDom(domContFrac, terms);
      fillApproxFracDom(
          domApproxFrac, getApproxFrac(terms, approxContFracTerms));

      // Draw steps.
      if (flagShowSteps.value) {
        let px = 0;
        let py = 0;
        for (const goUp of sequence) {
          const nx = px + (goUp ? 0 : 1);
          const ny = py + (goUp ? 1 : 0);
          line(px, py, nx, ny, '#0F0C');
          px = nx;
          py = ny;
        }
      }

      // Fill word.
      // const word = wordFromContFracTerms(terms);
      const word = sequence.map(x => x ? 'S' : 'L').join('');
      domWord.innerText = word;
    }

    window.requestAnimationFrame(update);
  };
  update();
}
window.addEventListener('load', onLoad);
</script>
<style>
body {
  background-color: #212121;
  margin: 0;
}
#head {
  background-color: #424242;
  width: 100%;
  display: flex;
  justify-content: space-around;
  margin-bottom: 16px;
}
h1, #index {
  color: #ffc107;
  text-align: center;
  font-family: monospace;
  font-size: 42px;
  flex-grow: 1;
  padding: 16px;
  margin: 0;
}
#index {
  color: #ff5722;
  text-decoration: none;
  flex-grow: 0;
}
h2 {
  color: #ff5722;
  font-family: monospace;
}
a {
  color: #ffc107;
  font-family: monospace;
  font-size: 16px;
  cursor: pointer;
  text-decoration: underline;
}
#wrap {
  padding: 0 16px;
  color: #f5f5f5;
  font-family: monospace;
  font-size: 16px;
}
#layout {
  display: flex;
  flex-direction: row;
  width: 100%;
  gap: 16px;
}
#left {
  flex-grow: 1;
}
#middle {
}
#right {
  display: flex;
  flex-direction: column;
  width: 400px;
}
#word {
  overflow: hidden;
  text-overflow: ellipsis;
  width: 250px;
}
.cont-frac-term-inner {
  padding-top: 0.5em;
  padding-right: 0.7em;
}
.cont-frac-frac {
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.cont-frac-num, .approx-frac-num {
  text-align: center;
}
#cont_frac, .cont-frac-den {
  display: flex;
  flex-direction: row;
  justify-content: center;
}
.cont-frac-den, .approx-frac-den {
  border-top: 2px solid #f5f5f5;
  text-align: center;
}
.frac-row {
  display: flex;
  flex-direction: row;
  width: 100%;
  gap: 8px;
  justify-content: center;
  align-items: center;
}
#approx_equal {
  font-size: 32px;
}
#approx_frac {
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.hidden {
  display: none;
}
#advanced_options {
  background-color: #FFF1;
}
.flag {
  display: flex;
  flex-direction: row;
  width: 100%;
  gap: 8px;
  justify-content: flex-start;
}
</style>
</head>
<body>
<div id="head">
  <a id="index" href="index.html">&lt;</a>
  <h1>Quasi Crystals (Prototype)</h1>
</div>
<div id="wrap">
  <div id="layout">
    <div id="left">
      Blog stuff goes here.
    </div>
    <div id="middle">
      <canvas id="view" width="800" height="800"></canvas>
    </div>
    <div id="right">
      Gradient: <input type="text" id="in_grad" value="0.618033988749894"/><br/>
      Offset: <input type="text" id="in_off" value="0"/><br/>
      <br/>
      Sequence:<br/>
      <div id="word"></div>
      <br/>
      Continued Fraction:<br/>
      <div class="frac-row">
        <div id="cont_frac"></div>
        <div id="approx_equal">≈</div>
        <div id="approx_frac"></div>
      </div>
      <br/>
      <div class="flag">
        <input type="checkbox" id="flag_advanced"/>
        <span>Advanced options</span>
      </div>
      <div id="advanced_options" class="hidden">
      </div>
    </div>
  </div>
</div>
</body>
</html>
