<!DOCTYPE html>
<html>
<head>
<title>Quasicrystals</title>
<link rel="icon" href="res/favicon.ico">
<script src="slide_show.js"></script>
<script type="text/javascript">

// Config
const mainViewSize = 10;
const mainViewZoomRate = 1.1;
const mainDotInitSize = 0.03;
const mainLineSize = 1;
const cellViewSize = 1;
const cellDotSize = 0.01;
const cellLineSize = 2;
const cellRayLength = 4;
const contFracTerms = 10;  // Max is around 30 before float errors.
const visibleContFracTerms = 6;
const zModeContFracTerms = 4;
const epsilon = 1e-6;
const alwaysRedraw = false;
const maxSeqLength = 1000;  // Way more than what we display.
const genSeqLength = 100;
const timeBetweenDomUpdatesMs = 100;

const tau = 2 * Math.PI;

function randInt(n) {
  return Math.floor(n * Math.random());
}

function fmod(x, y = 1) {
  const z = x / y;
  return (z - Math.floor(z)) * y;
}

function clamp(x, lo = 0, hi = 1) {
  return Math.max(Math.min(x, hi), lo);
}

function squish(x) {
  return (1 - Math.cos(x * Math.PI)) / 4 + x / 2;
}

function squishy(x, n) {
  for (let i = 0; i < n; ++i) x = squish(x);
  return x;
}

function isInt(x) {
  return Math.floor(x) == x;
}

function validate(x, condition) {
  if (condition(x)) return x;
  return null;
}

function unit(x, y) {
  const d = Math.sqrt(x * x + y * y);
  if (d == 0) return [0, 0];
  return [x / d, y / d];
}

function popSwap(a, i) {
  const x = a[i];
  const y = a.pop();
  if (i < a.length) a[i] = y;
  return x;
}

function getContFracTerms(x, maxTerms) {
  const terms = [];
  for (let i = 0; i < maxTerms; ++i) {
    const c = Math.floor(x);
    terms.push(c);
    const r = x - c;
    if (r < epsilon) {
      if (c == 1 && terms.length > 1) {
        terms.pop();
        terms[terms.length - 1] += 1;
      }
      break;
    }
    x = 1 / r;
  }
  return terms;
}

function getContFracTermsWithTargCoeff(x, maxTerms, targCoeff) {
  const terms = getContFracTerms(x, maxTerms);
  // targCoeff is not allowed to target a term that doesn't exist, unless it's
  // the very next term after the end of the terms array and the last element is
  // greater than 1. In that case we steal a 1/1 from that last term. Otherwise
  // we cap the targetCoeff.
  if (targCoeff > terms.length) {
    targCoeff = terms.length;
  }
  if (targCoeff == terms.length) {
    if (terms[terms.length - 1] > 1) {
      terms[terms.length - 1] -= 1;
      terms.push(1);
    } else {
      targCoeff = terms.length - 1;
    }
  }
  return [terms, targCoeff];
}

function getApproxFrac(terms, maxTerms, zn = 0, zd = 1) {
  const first = Math.min(terms.length, maxTerms) - 1;
  const frac = [zd, zn];
  for (let i = first; i >= 0; --i) {
    const y = frac[0];
    frac[0] = terms[i] * y + frac[1];
    frac[1] = y;
  }
  return frac;
}

function getContFracValue(terms) {
  let x = Infinity;
  for (let i = terms.length - 1; i >= 0; --i) {
    x = terms[i] + 1 / x;
  }
  return x;
}

function repeatStr(s, n, max) {
  let t = '';
  while (n > 0) {
    if (n & 1) t += s;
    s += s;
    n >>>= 1;
    if (t.length >= max) break;
  }
  return t;
}

function wordFromContFracTerms(terms) {
  let w = '';
  let w1 = 'S';
  let w2 = 'L';
  for (let i = 0; i < terms.length; ++i) {
    const wr = repeatStr(w1, terms[i], maxSeqLength);
    w = (i % 2 == 0) ? wr + w2 : w2 + wr;
    if (w.length >= maxSeqLength) return w.substr(0, maxSeqLength);
    w2 = w1;
    w1 = w;
  }
  return w;
}

function sequenceFromGrad(x, o, len) {
  let m = o;
  let n = 1;
  const a = [];
  for (let i = 0; i < len; ++i) {
    if (n * x > m) {
      ++m;
      a.push(true);
    } else {
      ++n;
      a.push(false);
    }
  }
  return a;
}

class RateLimiter {
  constructor() {
    this.lastRun = null;
    this.timeout = null;
  }

  run(delayMs, task) {
    const t = performance.now();

    // If it's been more than delayMs since our last task, run immediately.
    if (this.lastRun == null || (this.lastRun + delayMs) < t) {
      this.lastRun = t;
      task();
      return;
    }

    // We're about to set a new timeout, so cancel any existing timeouts.
    if (this.timeout != null) {
      window.clearTimeout(this.timeout);
    }

    // Set a timeout that delays the task by the extra wait time.
    const dt = this.lastRun + delayMs - t;
    this.timeout = window.setTimeout(() => {
      this.lastRun = performance.now();
      task();
    }, dt);
  }
}

function safeGet(node, defaultValue, isValid = (x => true)) {
  const value = parseFloat(node.value);
  if (isNaN(value) || !isValid(value)) return defaultValue;
  return value;
}

function newElement(type, parent, classes = [], text = null) {
  const n = document.createElement(type);
  if (text != null) n.innerText = text;
  for (const cls of classes) n.classList.add(cls);
  if (parent != null) parent.appendChild(n);
  return n;
}

function newDiv(parent, classes = [], text = null) {
  return newElement('div', parent, classes, text);
}

function emptyDiv(n) {
  while (n.hasChildNodes()) n.removeChild(n.lastChild);
}

function findCousinDivWithClass(n, className) {
  while (n != null) {
    for (const c of n.childNodes) {
      if (c.classList != null && c.classList.contains(className)) {
        return c;
      }
    }
    n = n.parentElement;
  }
  return null;
}

function runUnitTests() {
  let anyFails = false;
  const testWord = (terms, expectedWord) => {
    const word = wordFromContFracTerms(terms);
    if (word != expectedWord) {
      console.error(`wordFromContFracTerms([${terms}]) produced ${word} instead of ${expectedWord}`);
      anyFails = true;
    }
  };

  testWord([], '');
  testWord([1], 'SL');
  testWord([1, 1], 'SSL');
  testWord([1, 1, 1], 'SSLSL');
  testWord([1, 1, 1, 1], 'SSLSSLSL');
  testWord([1, 1, 1, 1, 1], 'SSLSSLSLSSLSL');
  testWord([1, 1, 1, 1, 1, 1], 'SSLSSLSLSSLSSLSLSSLSL');
  testWord([1, 6, 2, 3, 1, 2], 'SSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSL');
  testWord([0, 2, 2], 'SLLSLLL');

  const testContFrac = (x) => {
    const y = getContFracValue(getContFracTerms(x, 100));
    if (Math.abs(x - y) > 1e-12) {
      console.error(`getContFracValue(getContFracTerms(${x}, 100)) produced ${y} instead of ${x}`);
      anyFails = true;
    }
  };

  for (let i = 0; i < 1000; ++i) {
    testContFrac(10 * Math.random());
    testContFrac(randInt(10000) / (randInt(10000) + 1));
  }

  if (!anyFails) {
    console.log('All tests passed :)');
  }
}

function getRayCellCrossingsDist(gx, ox, len) {
  if (gx == 0) return null;
  const k = (1 - ox) / gx;
  if (k >= len) return null
  return k;
}

function getRayCellCrossings(gx, gy, ox, oy, len) {
  let d = 0;
  let x = ox;
  let y = oy;
  const a = [];
  for (let i = 0; i < 100; ++i) {
    const l = len - d;
    const kx = getRayCellCrossingsDist(gx, x, l);
    const ky = getRayCellCrossingsDist(gy, y, l);
    const stop = kx == null && ky == null;

    let k = 0;
    let px = null;
    let py = null;
    let nx = null;
    let ny = null;
    if (stop) {
      k = l;
    } else if (ky == null || (kx != null && kx < ky)) {
      k = kx;
      px = 1;
      nx = 0;
    } else {
      k = ky;
      py = 1;
      ny = 0;
    }
    if (ny == null) ny = py = y + k * gy;
    if (nx == null) nx = px = x + k * gx;

    const nd = d + k;
    a.push([x, y, d / len, px, py, nd / len]);
    x = nx;
    y = ny;
    d = nd;

    if (stop) break;
  }
  return a;
}

function setupCanvas(canvas, viewWidth, lineWidthMul = 1) {
  const ctx = canvas.getContext('2d');
  ctx.setTransform(
      canvas.width / viewWidth, 0,
      0, -canvas.width / viewWidth,
      0, canvas.height);
  ctx.lineWidth = lineWidthMul * viewWidth / canvas.width;
  return ctx;
}

function onLoad() {
  runUnitTests();

  let forceRedraw = true;
  const onFrameCallbacks = [];
  const domUpdateLimiter = new RateLimiter();

  const allLiveValues = new Map();
  const liveValue = (id, nodeIds, init = 0, validate = x => x, onchange = () => {}) => {
    // Does a few things:
    // - Maintains the invariant that each dom element has the same value.
    // - Whenever the value changes, sets forceRedraw to true.
    // - Uses validate to sanitize, a function from float to nullable float.
    // - Returns an object with a value field that is kept up to date.
    // - Changes to that field are also reflected on the elements.
    const elements = nodeIds.map(id => document.getElementById(id));
    const oldValues = [];  // One for each element, and one for obj.value.
    for (const e of elements) {
      e.value = init;
      oldValues.push(e.value);
    }
    const obj = { value: init, reset: null };
    obj.reset = () => obj.value = init;
    oldValues.push(obj.value);
    onFrameCallbacks.push(() => {
      let anyChange = obj.value != oldValues[elements.length];
      let cause = null;
      if (!anyChange) {
        for (let i = 0; i < elements.length; ++i) {
          const e = elements[i];
          if (e.value != oldValues[i]) {
            const px = parseFloat(e.value);
            const x = isNaN(px) ? null : validate(px);
            if (x != null) {
              anyChange = true;
              obj.value = x;
              cause = i;
              break;
            }
          }
        }
      }
      if (anyChange) {
        forceRedraw = true;
        oldValues[elements.length] = obj.value;
        for (let i = 0; i < elements.length; ++i) {
          const e = elements[i];
          if (i != cause) {
            e.value = obj.value;
          }
          oldValues[i] = e.value;
        }
        onchange();
      }
    });
    allLiveValues.set(id, obj);
    return obj;
  };

  const domAdvancedOptions = document.getElementById('advanced_options');
  const domFlagAdvanced = document.getElementById('flag_advanced');
  domFlagAdvanced.addEventListener('change', () => {
    if (domFlagAdvanced.checked) {
      domAdvancedOptions.classList.remove('hidden');
    } else {
      domAdvancedOptions.classList.add('hidden');
    }
  });

  const allFlags = new Map();
  const makeFlag = (id, name, initValue = false, onChange = () => {}) => {
    const flag = { value: initValue, setValue: null };
    const div = newDiv(domAdvancedOptions, ['flag']);
    const check = newElement('input', div);
    check.setAttribute('type', 'checkbox');
    if (initValue) check.setAttribute('checked', true);
    flag.setValue = value => {
      if (value) {
        check.setAttribute('checked', true);
      } else {
        check.removeAttribute('checked');
      }
      forceRedraw = true;
      flag.value = value;
      onChange();
    };
    check.addEventListener('change', () => flag.setValue(check.checked));
    const label = newElement('span', div, [], name);
    allFlags.set(id, flag);
    return flag;
  };

  let targKeep = false;
  let targX = null;
  let targY = null;
  const grad = liveValue('grad', ['in_grad', 'ins_grad'], 0.618033988749894,
      x => x >= 0 ? x : 0, () => {
    if (targKeep) {
      targKeep = false;
    } else {
      targX = null;
      targY = null;
    }
  });
  const off = liveValue('off', ['in_off', 'ins_off'], 0, x => fmod(x), () => {
    targX = null;
    targY = null;
  });
  let targCoeff = 0;
  const coeffterm = liveValue('coeff', ['coeff_slider'], 1, x => Math.floor(x),
      () => {
    const [terms, targCoeff_] = getContFracTermsWithTargCoeff(
        grad.value, contFracTerms, targCoeff);
    targCoeff = targCoeff_;
    const x = coeffterm.value;
    if (x == terms[targCoeff]) return;
    const terms_ = terms.slice(0);
    terms_[targCoeff] = x;
    grad.value = getContFracValue(terms_);
  });
  const rawzterm = liveValue('rawz', ['z_slider'], 0, x => clamp(x, 0, 1));

  const flagShowConvergents = makeFlag('conv', 'Show convergents');
  const flagShowSteps = makeFlag('step', 'Show steps');
  const flagShowCrystal = makeFlag('crys', 'Show crystal');
  const flagUnitCellMode = makeFlag('unit', 'Unit cell mode');
  const flagShowZ = makeFlag('rem', 'Editable remainder');
  const flagContFracEdit = makeFlag('cont', 'Editable continued fraction');
  const flagSimpleFracEdit = makeFlag('simp', 'Editable simple fraction');

  const isInZMode = () => (
      flagShowZ.value && !flagContFracEdit.value && !flagSimpleFracEdit.value &&
      !flagUnitCellMode.value);
  const isInSimpleFracEditMode = () =>
      flagSimpleFracEdit.value && !flagContFracEdit.value;
  const getVisibleContFracTerms = () =>
      isInZMode() ? zModeContFracTerms : visibleContFracTerms;
  const getApproxContFracTerms = () =>
      isInZMode() ? zModeContFracTerms : visibleContFracTerms + 1;

  const canvas = document.getElementById('view');
  const crystalCanvas = document.getElementById('crystal_view');
  const domContFrac = document.getElementById('cont_frac');
  const domApproxEqual = document.getElementById('approx_equal');
  const domApproxFrac = document.getElementById('approx_frac');
  const domWord = document.getElementById('word');
  const domZSliderWrap = document.getElementById('z_slider_wrap');
  const domCoeffSliderWrap = document.getElementById('coeff_slider_wrap');

  const blogPageUpdater = [];
  const addBlogPage = (flags, liveValues) => {
    const flg = new Set(flags);
    const lvs = new Map(liveValues);
    blogPageUpdater.push(() => {
      for (const [id, flag] of allFlags.entries()) {
        flag.setValue(flg.has(id));
      }
      for (const [id, lv] of allLiveValues.entries()) {
        if (lvs.has(id)) {
          lv.value = lvs.get(id);
        } else {
          lv.reset();
        }
      }
    });
  };

  addBlogPage(['crys', 'step']);
  addBlogPage(['crys', 'step']);

  const showBlog = index => blogPageUpdater[index]();
  document.getElementById('blog').addEventListener(
      'change', e => showBlog(e.detail));
  showBlog(0);

  const getZ = () => {
    const x = isInZMode() ? rawzterm.value : 0;
    if (x == 0) return [0, 1];
    if (x == 1) return [1, 0];
    if (x == 0.5) return [1, 1];
    const y = squishy(x, 4);
    const z = (1 / (1 - y)) - 1;
    return x < 0.5 ? [1, Math.floor(1 / z)] : [Math.floor(z), 1];
  };

  const fillContFracDom = (terms, zn, zd) => {
    const visibleTerms = getVisibleContFracTerms();
    emptyDiv(domContFrac);
    let n = terms.length;
    const trunc = n > visibleTerms;
    if (trunc) n = visibleTerms;
    --n;
    let node = domContFrac;
    const termDivs = [];

    const addTerm = (i, suffix, cls) => {
      const termWrap = newDiv(node, [cls]);
      const term = newDiv(termWrap, [], terms[i]);
      if (flagContFracEdit.value) {
        termWrap.classList.add('cont-frac-term-wrap');
        term.classList.add('cont-frac-term-clickable');
        if (targCoeff == i) {
          termWrap.classList.add('selected');
        }
        term.addEventListener('click', () => {
          for (const t of termDivs) {
            t.classList.remove('selected');
          }
          termWrap.classList.add('selected');
          targCoeff = i;
          coeffterm.value = terms[i];
        });
        newDiv(termWrap, ['cont-frac-term-line']);
      }
      termDivs.push(termWrap);
      if (suffix != '') newDiv(node, [cls], suffix);
    };

    for (let i = 0; i < n; ++i) {
      if (flagContFracEdit.value || !(i == 0 && terms[i] == 0)) {
        addTerm(i, ' + ', 'cont-frac-term');
      }
      const frac = newDiv(node, ['cont-frac-frac']);
      newDiv(frac, ['cont-frac-num'], '1');
      node = newDiv(frac, ['cont-frac-den']);
    }

    if (flagContFracEdit.value) {
      domCoeffSliderWrap.classList.remove('hidden');
    } else {
      domCoeffSliderWrap.classList.add('hidden');
    }

    if (isInZMode()) {
      domZSliderWrap.classList.remove('hidden');
      const haszd = zd > 1;
      addTerm(n, ' + ', haszd ? 'cont-frac-term' : 'cont-frac-term-end');
      const frac = newDiv(node, ['cont-frac-frac']);
      newDiv(frac, ['cont-frac-num'], zd == 0 ? '∞' : zn);
      if (haszd) newDiv(frac, ['cont-frac-den'], zd);
    } else {
      addTerm(n, trunc ? ' + ...' : '', 'cont-frac-term-end');
      domZSliderWrap.classList.add('hidden');
    }
  }

  const fillApproxFracDom = (terms, zn, zd) => {
    const [n, d] = getApproxFrac(terms, getApproxContFracTerms(), zn, zd);
    emptyDiv(domApproxFrac);
    if (isInSimpleFracEditMode()) {
      const makeText = (cls, val, minVal, onChange) => {
        const inp = newElement('input', domApproxFrac, ['approx-frac-edit']);
        inp.value = val;
        inp.addEventListener('change', () => {
          const val = validate(parseFloat(inp.value),
            x => isFinite(x) && isInt(x) && (x >= minVal));
          if (val != null) onChange(val);
        });
      };
      makeText(n, 0, x => grad.value = x / d);
      newDiv(domApproxFrac, ['approx-frac-edit-line']);
      makeText(d, 1, x => grad.value = n / x);
      domApproxEqual.innerText = '=';
    } else {
      newDiv(domApproxFrac, ['approx-frac-num'], n);
      if (d != 1) newDiv(domApproxFrac, ['approx-frac-den'], d);
      domApproxEqual.innerText =
          getApproxContFracTerms() < terms.length ? '≈' : '=';
    }
  }

  let mainViewZoomExp = 0;
  const getMainViewSize = () =>
      mainViewSize * Math.pow(mainViewZoomRate, mainViewZoomExp);

  const getViewSize = () =>
      flagUnitCellMode.value ? cellViewSize : getMainViewSize();

  const getClickPos = e => {
    const viewSize = getViewSize();
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.x;
    const my = e.clientY - rect.y;
    const x = viewSize * mx / canvas.width;
    const y = viewSize * (1 - my / canvas.height);
    return [x, y];
  };

  let mouseClicked = false;
  const anchors = [];
  const snapToAnchor = (x, y) => {
    const viewSize = getViewSize();
    let mx = null;
    let my = null;
    let mi = null;
    let md = Infinity;
    const maybeSnap = (px, py, pi) => {
      if (px >= 0 && py >= 0 && px <= viewSize && py <= viewSize) {
        const dx = x - px;
        const dy = y - py;
        const dd = dx * dx + dy * dy;
        if (dd < md) {
          mx = px;
          my = py;
          mi = pi;
          md = dd;
        }
      }
    };
    for (let i = 0; i < anchors.length; ++i) {
      const [px, py] = anchors[i];
      maybeSnap(px, py, i);
    }
    maybeSnap(Math.floor(x + 0.5), Math.floor(y + 0.5), null);
    if (md > 0.05) return null;
    return [mx, my, mi];
  };
  const onMouse = (e, click) => {
    e.preventDefault();
    let [x, y] = getClickPos(e);
    if (!click) {
      const snap = snapToAnchor(x, y);
      if (snap != null) {
        x = snap[0];
        y = snap[1];
      }
    }
    const y_ = y + off.value;
    if (x <= 0) {
      grad.value = 1e3;
    } else if (y_ <= 0) {
      grad.value = 0;
    } else {
      grad.value = y_ / x;
    }
    targX = x;
    targY = y;
    targKeep = true;
  };
  const onRightClick = e => {
    forceRedraw = true;
    let [x, y] = getClickPos(e);
    const snap = snapToAnchor(x, y);
    if (snap == null) {
      anchors.push([x, y]);
    } else if (snap[2] == null) {
      anchors.push([snap[0], snap[1]]);
    } else {
      popSwap(anchors, snap[2]);
    }
  };
  canvas.addEventListener('mousedown', e => {
    if (e.which == 1) {
      onMouse(e, mouseClicked = true);
    } else if (e.which == 3) {
      onRightClick(e);
    }
  });
  document.addEventListener('mousemove', e => {
    if (mouseClicked) onMouse(e, mouseClicked);
  });
  document.addEventListener('mouseup', e => {
    if (e.which == 1 && mouseClicked) onMouse(e, mouseClicked = false);
  });

  canvas.addEventListener('contextmenu', e => e.preventDefault());
  canvas.addEventListener('wheel', e => {
    e.preventDefault();
    forceRedraw = true;
    mainViewZoomExp = clamp(mainViewZoomExp + (0.01 * e.deltaY), -20, 10);
  });

  const circle = (cc, px, py, r, clr) => {
    cc.fillStyle = clr;
    cc.beginPath();
    cc.ellipse(px, py, r, r, 0, 0, tau);
    cc.fill();
  };

  const line = (cc, px, py, qx, qy, clr) => {
    cc.strokeStyle = clr;
    cc.beginPath();
    cc.moveTo(px, py);
    cc.lineTo(qx, qy);
    cc.stroke();
  };

  const ray = (cc, px, py, dx, dy, clr) => {
    const len = 2 * getMainViewSize();
    line(cc, px, py, px + len * dx, py + len * dy, clr);
  };

  const update = () => {
    for (const fn of onFrameCallbacks) fn();

    if (alwaysRedraw || forceRedraw) {
      forceRedraw = false;
      const viewSize = getViewSize();
      const mainDotSize =
          mainDotInitSize * Math.sqrt(getMainViewSize() / mainViewSize);
      const dotSize = flagUnitCellMode.value ? cellDotSize : mainDotSize;
      const lineSize = flagUnitCellMode.value ? cellLineSize : mainLineSize;
      const ctx = setupCanvas(canvas, viewSize, lineSize);

      const [zn, zd] = getZ();
      const zmode = isInZMode();
      const g = grad.value;
      const o = off.value;
      const gx = 1 / Math.sqrt(1 + g * g);
      const gy = gx * g;

      if (!flagContFracEdit.value) {
        targCoeff = 0;
      }

      const [terms, targCoeff_] = getContFracTermsWithTargCoeff(
          grad.value, contFracTerms, targCoeff);
      targCoeff = targCoeff_;
      const zray = (n, d) => {
        if (!zmode) return [[gy, gx], g];
        const [y, x] = getApproxFrac(terms, getApproxContFracTerms(), n, d);
        return [unit(y, x), y / x];
      };

      const [[ugy, ugx], zg] = zray(zn, zd);
      const [[ugy0, ugx0], zg0] = zray(0, 1);
      const [[ugy1, ugx1], zg1] = zray(1, 0);

      const hitRad = isFinite(zg) ? (1 + zg) / Math.sqrt(1 + zg * zg) : 1;
      const hitGx = ugy;
      const hitGy = -ugx;
      const hitSx = hitGx * hitRad;
      const hitSy = hitGy * hitRad;
      const hitOx = 0;
      const hitOy = -o;
      const sequence = sequenceFromGrad(zg, o, genSeqLength);

      // Clear to black.
      ctx.fillStyle = 'rgba(0, 0, 0, 1)';
      ctx.fillRect(-2 * viewSize, -2 * viewSize, 4 * viewSize, 4 * viewSize);

      // Draw dots.
      const dotClr = zmode ? 'rgba(34, 34, 34, 1)' : 'rgba(68, 68, 68, 1)';
      for (let i = 0; i <= viewSize; ++i) {
        for (let j = 0; j <= viewSize; ++j) {
          circle(ctx, i, j, dotSize, dotClr);
        }
      }

      // Draw kernel lines.
      const kernDraw = viewSize + 1;
      for (let i = -1; i <= kernDraw; ++i) {
        for (let j = -1; j <= kernDraw; ++j) {
          line(ctx, i, j, i + hitSx, j + hitSy, dotClr);
        }
      }

      // Draw anchors.
      for (const [x, y] of anchors) {
        circle(ctx, x, y, 2 * dotSize, 'rgba(156, 39, 176, 1)');
      }

      // Calculate ray hits.
      let px = 0;
      let py = 0;
      const hits = [];
      for (const goUp of sequence) {
        const x = px + (goUp ? 0 : 1);
        const y = py + (goUp ? 1 : 0);
        const k = ugx * (x - hitOx) + ugy * (y - hitOy);
        const ux = hitOx + k * ugx;
        const uy = hitOy + k * ugy;
        hits.push([px, py, x, y, ux, uy, k]);
        px = x;
        py = y;
      }

      if (!flagUnitCellMode.value) {  // Normal mode.
        // Draw rays.
        if (zmode) {
          ray(ctx, hitOx, hitOy, gx, gy, 'rgba(255, 255, 255, 0.5)');

          // Draw z, z=0, and z=inf lines, if in z mode.
          ray(ctx, hitOx, hitOy, ugx, ugy, `rgba(255, 255, 255, 1)`);
          ray(ctx, hitOx, hitOy, ugx0, ugy0, `rgba(255, 255, 255, 0.5)`);
          ray(ctx, hitOx, hitOy, ugx1, ugy1, `rgba(255, 255, 255, 0.5)`);
        } else {
          ray(ctx, hitOx, hitOy, gx, gy, 'rgba(255, 255, 255, 1)');
        }

        // Draw hit kernel lines.
        for (const [px, py, x, y, ux, uy, k] of hits) {
          line(ctx, x, y, ux, uy, 'rgba(0, 136, 255, 1)');
          circle(ctx, x, y, dotSize, 'rgba(0, 136, 255, 1)');
        }

        // Hilite the dots between the z rays, if in z mode.
        if (zmode) {
          for (let i = 0; i <= viewSize; ++i) {
            for (let j = 0; j <= viewSize; ++j) {
              const k = (j - hitOy) / (i - hitOx);
              if (k >= zg1 && k <= zg0) {
                circle(ctx, i, j, dotSize, 'rgba(170, 170, 170, 1)');
              }
            }
          }
        }

        // Draw hit dots.
        for (const [px, py, x, y, ux, uy, k] of hits) {
          circle(ctx, ux, uy, 2 * dotSize, 'rgba(255, 34, 0, 1)');
        }

        // Draw steps.
        if (flagShowSteps.value) {
          for (const [px, py, x, y, ux, uy, k] of hits) {
            line(ctx, px, py, x, y, 'rgba(0, 255, 0, 0.8)');
          }
        }

        // Draw convergents, if enabled.
        if (flagShowConvergents.value) {
          for (let i = 1; i <= terms.length; ++i) {
            const [y, x] = getApproxFrac(terms, i);
            circle(ctx, x, y, 2 * dotSize, 'rgba(255, 255, 0, 1)');
          }
        }
      } else {  // Unit cell mode.
        // Draw ray.
        const rcc = getRayCellCrossings(ugx, ugy, hitOx, hitOy, cellRayLength);
        for (const [ax, ay, ak, bx, by, bk] of rcc) {
          const grd = ctx.createLinearGradient(ax, ay, bx, by);
          grd.addColorStop(0, `rgba(255, 255, 0, ${1 - ak})`);
          grd.addColorStop(1, `rgba(255, 255, 0, ${1 - bk})`);
          line(ctx, ax, ay, bx, by, grd);
        }

        // Modulo all the ray hits into the unit cell.
        const modhits = [];
        for (const [px, py, x, y, ux, uy, k] of hits) {
          if (k > cellRayLength) break;
          const mux = fmod(ux);
          const muy = fmod(uy);
          const gux = x + mux - ux;
          const guy = y + muy - uy;
          const alpha = 1 - k / cellRayLength;
          modhits.push([mux, muy, gux, guy, alpha])
        }

        // Draw hit dots.
        for (const [mux, muy, gux, guy, alpha] of modhits) {
          circle(ctx, mux, muy, dotSize, `rgba(255, 34, 0, 1)`);
        }
      }

      // Draw target point, if it exists.
      if (targX != null && targY != null) {
        circle(ctx, targX, targY, 2 * dotSize, 'rgba(255, 255, 255, 1)');
      }

      domUpdateLimiter.run(timeBetweenDomUpdatesMs, () => {
        // Fill continued fraction and approx fraction.
        fillContFracDom(terms, zn, zd);
        fillApproxFracDom(terms, zn, zd);

        // Fill word.
        const word = sequence.map(x => x ? 'S' : 'L').join('');
        domWord.innerText = word;
      });

      // Draw the crystal, if enabled.
      if (flagShowCrystal.value) {
        const viewSize = getMainViewSize();
        const crystalCtx = setupCanvas(crystalCanvas, viewSize);
        crystalCanvas.classList.remove('hidden');
        crystalCtx.fillStyle = 'rgba(0, 0, 0, 1)';
        crystalCtx.fillRect(
          -2 * viewSize, -2 * viewSize, 4 * viewSize, 4 * viewSize);
        const midy = 0.025 * viewSize;
        line(crystalCtx, 0, midy, viewSize, midy, 'rgba(255, 255, 255, 1)');
        for (const [px, py, x, y, ux, uy, k] of hits) {
          circle(crystalCtx, k, midy, 2 * mainDotSize, 'rgba(255, 34, 0, 1)');
        }
      } else {
        crystalCanvas.classList.add('hidden');
      }
    }

    window.requestAnimationFrame(update);
  };
  update();
}
window.addEventListener('load', onLoad);

class YouTubeEmbed extends HTMLElement {
  constructor() {
    super();
    const iframe = newElement('iframe', this);
    iframe.setAttribute('width', 560);
    iframe.setAttribute('height', 315);
    iframe.setAttribute(
        'src', 'https://www.youtube.com/embed/' + this.getAttribute('src'));
    iframe.setAttribute('title', 'YouTube video player');
    iframe.setAttribute('frameborder', 0);
    iframe.setAttribute(
        'allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; ' +
            'gyroscope; picture-in-picture');
    iframe.setAttribute('allowfullscreen', '');
  }
}
window.addEventListener(
    'load', () => customElements.define('youtube-embed', YouTubeEmbed));

let shownQuizAnswer = null;
class QuizAnswer extends HTMLElement {
  constructor() {
    super();
    this.answerHTML = this.innerHTML;
    this.innerText = '[Answer]';
    this.answerDiv = findCousinDivWithClass(this, 'quiz-answer');
    this.addEventListener('click', () => {
      if (shownQuizAnswer != this) {
        shownQuizAnswer = this;
        this.answerDiv.innerHTML = this.answerHTML;
      } else {
        shownQuizAnswer = null;
        this.answerDiv.innerHTML = '';
      }
    });
  }
}
window.addEventListener(
    'load', () => customElements.define('quiz-answer', QuizAnswer));
</script>
<style>
html {
  min-height: 100%;
}
body {
  background-color: #212121;
  margin: 0;
}
#head {
  background-color: #424242;
  width: 100%;
  display: flex;
  justify-content: space-around;
  margin-bottom: 4px;
}
h1, #index {
  color: #ffc107;
  text-align: center;
  font-family: monospace;
  font-size: 42px;
  flex-grow: 1;
  padding: 16px;
  margin: 0;
}
#index {
  color: #ff5722;
  text-decoration: none;
  flex-grow: 0;
}
h2 {
  color: #ff5722;
  font-family: monospace;
}
a {
  color: #ffc107;
  font-family: monospace;
  font-size: 16px;
  cursor: pointer;
  text-decoration: underline;
}
#wrap {
  padding: 0 16px;
  color: #f5f5f5;
  font-family: monospace;
  font-size: 16px;
}
#layout {
  display: flex;
  flex-direction: row;
  width: 100%;
  gap: 16px;
}
#left {
  flex-grow: 1;
}
#middle {
  display: flex;
  flex-direction: column;
}
#right {
  display: flex;
  flex-direction: column;
  flex-shrink: 0;
  width: 350px;
}
#word {
  overflow: hidden;
  text-overflow: ellipsis;
  width: 330px;
}
.cont-frac-term {
  margin-top: 0.6em;
}
.cont-frac-term-end {
  margin-top: 0;
}
.cont-frac-frac {
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.cont-frac-num, .approx-frac-num {
  text-align: center;
}
#cont_frac, .cont-frac-den {
  display: flex;
  flex-direction: row;
  justify-content: center;
  gap: 4px;
}
.cont-frac-den, .approx-frac-den, .approx-frac-edit-line {
  border-top: 2px solid #f5f5f5;
  text-align: center;
}
.approx-frac-edit-line {
  margin: 4px;
}
.approx-frac-edit {
  max-width: 50px;
}
.cont-frac-term-wrap {
  display: flex;
  flex-direction: column;
  justify-content: top;
  align-items: center;
  min-height: 30px;
}
.cont-frac-term-clickable {
  cursor: pointer;
}
.cont-frac-term-clickable:hover {
  background-color: rgba(0, 128, 255, 0.5);
}
.selected .cont-frac-term-clickable {
  background-color: rgba(0, 128, 255, 1);
}
.cont-frac-term-line {
  display: none;
  background-color: rgba(0, 128, 255, 1);
  flex-grow: 1;
  width: 1px;
}
.selected .cont-frac-term-line {
  display: block;
}
.frac-row {
  display: flex;
  flex-direction: row;
  width: 100%;
  gap: 8px;
  justify-content: center;
  align-items: center;
  min-height: 140px;
}
#approx_equal {
  font-size: 32px;
}
#approx_frac {
  display: flex;
  flex-direction: column;
  justify-content: center;
}
#z_slider_wrap, #coeff_slider_wrap {
  display: flex;
  flex-direction: row;
  justify-content: center;
  gap: 4px;
}
#z_slider, #coeff_slider {
  flex-grow: 1;
}
.hidden {
  display: none !important;
}
#advanced_options {
  background-color: #FFF1;
}
.flag {
  display: flex;
  flex-direction: row;
  width: 100%;
  gap: 8px;
  justify-content: flex-start;
}
slide-show {
  display: none;
}
slide-show.loaded {
  display: flex;
  flex-direction: column-reverse;
  align-items: center;
  gap: 8px;
}
.slide-show-slide-row {
  width: 100%;
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  gap: 8px;
}
.slide-show-dot-row {
  width: 100%;
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
  gap: 8px;
}
.slide-show-dot {
  cursor: pointer;
  width: 8px;
  height: 8px;
  border-radius: 4px;
  background-color: #FFF2;
}
.slide-show-dot.active {
  background-color: #FFF;
}
.slide-show-button {
  cursor: pointer;
  user-select: none;
}
quiz-answer {
  cursor: pointer;
  color: #ff5722;
}
quiz-answer:hover {
  color: #ffc107;
}
</style>
</head>
<body>
<div id="head">
  <a id="index" href="index.html">&lt;</a>
  <h1>Quasicrystals (Prototype)</h1>
</div>
<div id="wrap">
  <div id="layout">
    <div id="left">
      <slide-show id="blog" button-layout="low">
        <span>
          <h2>Rational Numbers and Periodic Crystals</h2>

          You can click and drag the slope of the line and watch the crystal
          structures (bottom) and sequences (right) which form based on this.
          Use the mouse wheel to zoom.
          <br/>

          <h3>Questions</h3>

          1) Can you make a periodic structure?
          <quiz-answer>Try clicking on any of the grid points.</quiz-answer>
          <br/><br/>

          2) What sort of gradients give you periodic structures?
          <quiz-answer>
            Since the lattice is periodic, the view from any point on the
            lattice is the same as from any other. Hence, if a line leaves a
            point (i.e., the origin), and hits another point, then the view
            from the next point must be the same as that from the first point,
            meaning the structure repeats itself until we hit the next point,
            after which it repeats again, continuing indefinitely. Any line
            that hits a lattice point must move an integer number of steps up,
            and an integer number of steps along, meaning its gradient is of the
            form p/q, where (q,p) are the coordinates of the point we hit.
          </quiz-answer>
          <br/><br/>

          3) What determines how many atoms appear in your crystal before it
          begins to repeat.
          <quiz-answer>
            As for the number of atoms in between – if we look at the staircase
            representation, we can see the total number of atoms is given by the
            number of steps up, plus the number along, meaning there will always
            be p+q atoms per repetition (or ‘in the unit cell’).
          </quiz-answer>
          <br/><br/>

          <br/><br/>
          <div class="quiz-answer"></div>
        </span>
        <span>
          <h2>Rational Numbers and Periodic Crystals</h2>

          If a line directly hits a lattice point, that fixes its gradient, so
          at least some gradients can be represented by just a point.
          <br/>

          <h3>Questions</h3>

          1) Is this representation unique?
          <quiz-answer>
            The fraction p/q, corresponding to hitting the point (q,p), isn’t
            unique – we could multiply top and bottom by an integer, and find
            another point the line hits (np/nq and (nq,np)). This is another
            way of showing the periodicity of this structure.
          </quiz-answer>
          <br/><br/>

          2) What additional requirement could you add to <i>make</i> it unique?
          <quiz-answer>
            If we want to find a <i>unique</i> point corresponding to any
            gradient, we can always simplify this fraction by cancelling all
            common factors between p and q, corresponding to finding the first
            point we hit as we move out from the origin.
          </quiz-answer>
          <br/><br/>

          3) Do all possible gradients correspond to a point on the lattice?
          <quiz-answer>
            All this work <i>assumes</i> that we hit an atom in the first
            place. But what if we pick a gradient which <i>isn’t</i>
            rational (meaning it’s not a number which can be written p/q,
            where p and q are integers – say like π, ϕ, or √2)?
            Well, if the line ever <i>did</i> touch a point, that would
            mean it had a rational gradient – but we know it’s an
            irrational number, so it never does. Hence, it only
            ever hits one atom (the one at the origin), and
            it never repeats. Hence, we’ve found a deterministic
            <i>non</i>-periodic structure. We haven’t shown yet that it
            is aperiodic (i.e., that it doesn’t ever have large runs
            of repeating words), which will be one of our major
            goals in investigating these.
          </quiz-answer>
          <br/><br/>

          <br/><br/>
          <div class="quiz-answer"></div>
        </span>
        <!-- <div>
          YouTube embed:<br/>
          <youtube-embed src="AaQD-cyXH2A"></youtube-embed>
        </div> -->
      </slide-show>
    </div>
    <div id="middle">
      <canvas id="view" width="800" height="800"></canvas>
      <canvas id="crystal_view" width="800" height="40" class="hidden"></canvas>
    </div>
    <div id="right">
      Gradient: <input type="text" id="in_grad"/>
      <input type="range" id="ins_grad" min="0" max="1" step="0.001"/><br/>
      Offset: <input type="text" id="in_off"/>
      <input type="range" id="ins_off" min="0" max="0.999" step="0.001"/><br/>
      <br/>
      Sequence:<br/>
      <div id="word"></div>
      <br/>
      Continued Fraction:<br/>
      <div class="frac-row">
        <div id="cont_frac"></div>
        <div id="approx_equal"></div>
        <div id="approx_frac"></div>
      </div>
      <div id="coeff_slider_wrap" class="hidden">
        <input type="range" id="coeff_slider" min="1" max="30" step="1"/><br/>
      </div>
      <div id="z_slider_wrap" class="hidden">
        r:
        <input type="range" id="z_slider" min="0" max="1" step="0.01"
            value="0"/><br/>
      </div>
      <br/>
      <div class="flag">
        <input type="checkbox" id="flag_advanced"/>
        <span>Advanced options</span>
      </div>
      <div id="advanced_options" class="hidden">
      </div>
    </div>
  </div>
</div>
</body>
</html>
