<!DOCTYPE html>
<html>
<head>
<title>Quasi Crystals</title>
<link rel="icon" href="res/favicon.ico">
<script type="text/javascript">

// Config
const viewSize = 10;
const contFracTerms = 10;  // Max is around 30 before float errors.
const visibleContFracTerms = 6;
const epsilon = 1e-6;
const alwaysRedraw = false;
const maxSeqLength = 1000;  // Way more than what we display.

function getContFracTerms(x, maxTerms) {
  const terms = [];
  for (let i = 0; i < maxTerms; ++i) {
    const c = Math.floor(x);
    terms.push(c);
    const r = x - c;
    if (r < epsilon) break;
    x = 1 / r;
  }
  return terms;
}

function repeatStr(s, n, max) {
  let t = '';
  while (n > 0) {
    if (n & 1) t += s;
    s += s;
    n >>>= 1;
    if (t.length >= max) break;
  }
  return t;
}

function wordFromContFracTerms(terms) {
  let w = '';
  let w1 = 'S';
  let w2 = 'L';
  for (let i = 0; i < terms.length; ++i) {
    const wr = repeatStr(w1, terms[i], maxSeqLength);
    w = (i % 2 == 0) ? wr + w2 : w2 + wr;
    if (w.length >= maxSeqLength) return w.substr(0, maxSeqLength);
    w2 = w1;
    w1 = w;
  }
  return w;
}

function safeGet(node, defaultValue, isValid = (x => true)) {
  const value = parseFloat(node.value);
  if (isNaN(value) || !isValid(value)) return defaultValue;
  return value;
}

function newElement(type, parent, classes = [], text = null) {
  const n = document.createElement(type);
  if (text != null) n.innerText = text;
  for (const cls of classes) n.classList.add(cls);
  if (parent != null) parent.appendChild(n);
  return n;
}

function newDiv(parent, classes = [], text = null) {
  return newElement('div', parent, classes, text);
}

function emptyDiv(n) {
  while (n.hasChildNodes()) n.removeChild(n.lastChild);
}

function fillContFracDom(node, terms) {
  emptyDiv(node);
  let n = terms.length;
  const trunc = n > visibleContFracTerms;
  if (trunc) n = visibleContFracTerms;
  --n;
  for (let i = 0; i < n; ++i) {
    if (!(i == 0 && terms[i] == 0)) {
      newDiv(node, ['cont-frac-term-inner'], `${terms[i]} + `);
    }
    const frac = newDiv(node, ['cont-frac-frac']);
    newDiv(frac, ['cont-frac-num'], '1');
    node = newDiv(frac, ['cont-frac-den']);
  }
  newDiv(node, ['cont-frac-term'], `${terms[n]}${trunc ? ' ...' : ''}`);
}

function runUnitTests() {
  let anyFails = false;
  const testWord = (terms, expectedWord) => {
    const word = wordFromContFracTerms(terms);
    if (word != expectedWord) {
      console.error(`wordFromContFracTerms([${terms}]) produced ${word} instead of ${expectedWord}`);
      anyFails = true;
    }
  };

  testWord([], '');
  testWord([1], 'SL');
  testWord([1, 1], 'SSL');
  testWord([1, 1, 1], 'SSLSL');
  testWord([1, 1, 1, 1], 'SSLSSLSL');
  testWord([1, 1, 1, 1, 1], 'SSLSSLSLSSLSL');
  testWord([1, 1, 1, 1, 1, 1], 'SSLSSLSLSSLSSLSLSSLSL');
  testWord([1, 6, 2, 3, 1, 2], 'SSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSL');
  testWord([0, 2, 2], 'SLLSLLL');

  if (!anyFails) {
    console.log('All tests passed :)');
  }
}

function onLoad() {
  runUnitTests();

  const inGrad = document.getElementById('in_grad');
  const inOff = document.getElementById('in_off');
  const canvas = document.getElementById('view');
  const domFraction = document.getElementById('fraction');
  const domWord = document.getElementById('word');

  const ctx = canvas.getContext('2d');
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  const tau = 2 * Math.PI;
  const halfWidth = canvas.width / 2;
  const halfHeight = canvas.height / 2;
  const dotSize = 0.003 * viewSize;
  const posX = 0.5 * viewSize;
  const posY = 0.5 * viewSize;
  ctx.setTransform(
      0, -2 * halfWidth / viewSize, 2 * halfHeight / viewSize, 0,
      halfWidth * (1 - 2 * posX / viewSize), halfHeight * (1 + 2 * posY / viewSize));
  ctx.lineWidth = viewSize / (halfWidth + halfHeight);

  const circle = (px, py, r, clr) => {
    ctx.fillStyle = clr;
    ctx.beginPath();
    ctx.ellipse(px, py, r, r, 0, 0, tau);
    ctx.fill();
  };

  const line = (px, py, qx, qy, clr) => {
    ctx.strokeStyle = clr;
    ctx.beginPath();
    ctx.moveTo(px, py);
    ctx.lineTo(qx, qy);
    ctx.stroke();
  };

  let grad = 0;
  let off = 0;
  const update = () => {
    const oldGrad = grad;
    const oldOff = off;
    grad = safeGet(inGrad, grad, x => x >= 0);
    off = safeGet(inOff, off);
    const needsRedraw = alwaysRedraw || oldGrad != grad || oldOff != off;

    if (needsRedraw) {
      gy = 1 / Math.sqrt(1 + grad * grad);
      gx = gy * grad;
      hitRad = (1 + grad) / Math.sqrt(1 + grad * grad);
      hitGx = gy;
      hitGy = -gx;
      hitSx = hitGx * hitRad;
      hitSy = hitGy * hitRad;
      hitOx = hitGx * off;
      hitOy = hitGy * off;

      // Clear to black.
      ctx.fillStyle = '#000';
      ctx.fillRect(-2 * viewSize, -2 * viewSize, 4 * viewSize, 4 * viewSize);

      // Draw dots.
      for (let i = 0; i <= viewSize; ++i) {
        for (let j = 0; j <= viewSize; ++j) {
          circle(i, j, dotSize, '#FFFFFF22');
        }
      }

      // Draw hit lines.
      for (let i = 0; i <= viewSize; ++i) {
        for (let j = 0; j <= viewSize; ++j) {
          line(i, j, i + hitSx, j + hitSy, '#0088FF22');
        }
      }

      // Draw ray.
      line(hitOx, hitOy, 2 * viewSize * gx, 2 * viewSize * gy, '#FFF');

      // Draw hit dots. TODO: Maybe make this more efficient?
      for (let i = 0; i <= viewSize; ++i) {
        for (let j = 0; j <= viewSize; ++j) {
          const k = gx * (i - hitOx) + gy * (j - hitOy);
          const ux = hitOx + k * gx;
          const uy = hitOy + k * gy;
          const dx = i - ux;
          const dy = j - uy;
          if (((dx - dy) >= 0) && ((dx * dx + dy * dy) < hitRad * hitRad)) {
            line(i, j, ux, uy, '#08F');
            circle(ux, uy, 2 * dotSize, '#F00');
            circle(i, j, dotSize, '#08F');
          }
        }
      }

      // Fill continued fraction.
      const terms = getContFracTerms(grad, contFracTerms);
      fillContFracDom(domFraction, terms);

      // Fill word.
      const word = wordFromContFracTerms(terms);
      domWord.innerText = word;
    }

    window.requestAnimationFrame(update);
  };
  update();
}
window.addEventListener('load', onLoad);
</script>
<style>
body {
  background-color: #212121;
  margin: 0;
}
#head {
  background-color: #424242;
  width: 100%;
  display: flex;
  justify-content: space-around;
  margin-bottom: 16px;
}
h1, #index {
  color: #ffc107;
  text-align: center;
  font-family: monospace;
  font-size: 42px;
  flex-grow: 1;
  padding: 16px;
  margin: 0;
}
#index {
  color: #ff5722;
  text-decoration: none;
  flex-grow: 0;
}
h2 {
  color: #ff5722;
  font-family: monospace;
}
a {
  color: #ffc107;
  font-family: monospace;
  font-size: 16px;
  cursor: pointer;
  text-decoration: underline;
}
#wrap {
  padding: 0 16px;
  color: #f5f5f5;
  font-family: monospace;
  font-size: 16px;
}
#layout {
  display: flex;
  flex-direction: row;
  width: 100%;
}
#left {
}
#right {
  margin-left: 16px;
  flex-grow: 1;
  flex-shrink: 1;
  display: flex;
  flex-direction: column;
}
#word {
  overflow: hidden;
  text-overflow: ellipsis;
  width: 250px;
}
.cont-frac-term-inner {
  padding-top: 0.5em;
  padding-right: 0.7em;
}
.cont-frac-frac {
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.cont-frac-num {
  text-align: center;
}
#fraction, .cont-frac-den {
  display: flex;
  flex-direction: row;
  justify-content: center;
}
.cont-frac-den {
  border-top: 2px solid #f5f5f5;
}
</style>
</head>
<body>
<div id="head">
  <a id="index" href="index.html">&lt;</a>
  <h1>Quasi Crystals (Prototype)</h1>
</div>
<div id="wrap">
  <div id="layout">
    <div id="left">
      <canvas id="view" width="800" height="800"></canvas>
    </div>
    <div id="right">
      Gradient: <input type="text" id="in_grad" value="0.618033988749894"/><br/>
      Offset: <input type="text" id="in_off" value="0"/><br/>
      <br/>
      Sequence:<br/>
      <div id="word"></div>
      <br/>
      Continued Fraction:<br/>
      <div id="fraction"></div>
    </div>
  </div>
</div>
</body>
</html>
