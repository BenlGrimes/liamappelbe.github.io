<!DOCTYPE html>
<html>
<head>
<title>Quasicrystals</title>
<link rel="icon" href="res/favicon.ico">
<script src="slide_show.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script>
MathJax = {
  tex: {inlineMath: [['$', '$']]}
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>
<script type="text/javascript">

// Config
const mainViewSize = 10;
const mainViewZoomRate = 1.1;
const mainDotInitSize = 0.03;
const mainLineSize = 1;
const cellViewSize = 1;
const cellDotSize = 0.01;
const cellLineSize = 2;
const cellRayLength = 4;
const contFracTerms = 10;  // Max is around 30 before float errors.
const visibleContFracTerms = 6;
const zModeContFracTerms = 4;
const epsilon = 1e-6;
const alwaysRedraw = false;
const maxSeqLength = 1000;  // Way more than what we display.
const genSeqLength = 100;
const timeBetweenDomUpdatesMs = 100;

const tau = 2 * Math.PI;

function randInt(n) {
  return Math.floor(n * Math.random());
}

function fmod(x, y = 1) {
  const z = x / y;
  return (z - Math.floor(z)) * y;
}

function clamp(x, lo = 0, hi = 1) {
  return Math.max(Math.min(x, hi), lo);
}

function squish(x) {
  return (1 - Math.cos(x * Math.PI)) / 4 + x / 2;
}

function squishy(x, n) {
  for (let i = 0; i < n; ++i) x = squish(x);
  return x;
}

function isInt(x) {
  return Math.floor(x) == x;
}

function validate(x, condition) {
  if (condition(x)) return x;
  return null;
}

function unit(x, y) {
  const d = Math.sqrt(x * x + y * y);
  if (d == 0) return [0, 0];
  return [x / d, y / d];
}

function popSwap(a, i) {
  const x = a[i];
  const y = a.pop();
  if (i < a.length) a[i] = y;
  return x;
}

function getContFracTerms(x, maxTerms) {
  const terms = [];
  for (let i = 0; i < maxTerms; ++i) {
    const c = Math.floor(x);
    terms.push(c);
    const r = x - c;
    if (r < epsilon) {
      if (c == 1 && terms.length > 1) {
        terms.pop();
        terms[terms.length - 1] += 1;
      }
      break;
    }
    x = 1 / r;
  }
  return terms;
}

function getContFracTermsWithTargCoeff(x, maxTerms, targCoeff) {
  const terms = getContFracTerms(x, maxTerms);
  // targCoeff is not allowed to target a term that doesn't exist, unless it's
  // the very next term after the end of the terms array and the last element is
  // greater than 1. In that case we steal a 1/1 from that last term. Otherwise
  // we cap the targetCoeff.
  if (targCoeff > terms.length) {
    targCoeff = terms.length;
  }
  if (targCoeff == terms.length) {
    if (terms[terms.length - 1] > 1) {
      terms[terms.length - 1] -= 1;
      terms.push(1);
    } else {
      targCoeff = terms.length - 1;
    }
  }
  return [terms, targCoeff];
}

function getApproxFrac(terms, maxTerms, zn = 0, zd = 1) {
  const first = Math.min(terms.length, maxTerms) - 1;
  const frac = [zd, zn];
  for (let i = first; i >= 0; --i) {
    const y = frac[0];
    frac[0] = terms[i] * y + frac[1];
    frac[1] = y;
  }
  return frac;
}

function getContFracValue(terms) {
  let x = Infinity;
  for (let i = terms.length - 1; i >= 0; --i) {
    x = terms[i] + 1 / x;
  }
  return x;
}

function repeatStr(s, n, max) {
  let t = '';
  while (n > 0) {
    if (n & 1) t += s;
    s += s;
    n >>>= 1;
    if (t.length >= max) break;
  }
  return t;
}

function wordFromContFracTerms(terms) {
  let w = '';
  let w1 = 'S';
  let w2 = 'L';
  for (let i = 0; i < terms.length; ++i) {
    const wr = repeatStr(w1, terms[i], maxSeqLength);
    w = (i % 2 == 0) ? wr + w2 : w2 + wr;
    if (w.length >= maxSeqLength) return w.substr(0, maxSeqLength);
    w2 = w1;
    w1 = w;
  }
  return w;
}

function sequenceFromGrad(x, o, len) {
  let m = o;
  let n = 1;
  const a = [];
  for (let i = 0; i < len; ++i) {
    if (n * x > m) {
      ++m;
      a.push(true);
    } else {
      ++n;
      a.push(false);
    }
  }
  return a;
}

class RateLimiter {
  constructor() {
    this.lastRun = null;
    this.timeout = null;
  }

  run(delayMs, task) {
    const t = performance.now();

    // If it's been more than delayMs since our last task, run immediately.
    if (this.lastRun == null || (this.lastRun + delayMs) < t) {
      this.lastRun = t;
      task();
      return;
    }

    // We're about to set a new timeout, so cancel any existing timeouts.
    if (this.timeout != null) {
      window.clearTimeout(this.timeout);
    }

    // Set a timeout that delays the task by the extra wait time.
    const dt = this.lastRun + delayMs - t;
    this.timeout = window.setTimeout(() => {
      this.lastRun = performance.now();
      task();
    }, dt);
  }
}

function safeGet(node, defaultValue, isValid = (x => true)) {
  const value = parseFloat(node.value);
  if (isNaN(value) || !isValid(value)) return defaultValue;
  return value;
}

function newElement(type, parent, classes = [], text = null) {
  const n = document.createElement(type);
  if (text != null) n.innerText = text;
  for (const cls of classes) n.classList.add(cls);
  if (parent != null) parent.appendChild(n);
  return n;
}

function newDiv(parent, classes = [], text = null) {
  return newElement('div', parent, classes, text);
}

function emptyDiv(n) {
  while (n.hasChildNodes()) n.removeChild(n.lastChild);
}

function findCousinDivWithClass(n, className) {
  while (n != null) {
    for (const c of n.childNodes) {
      if (c.classList != null && c.classList.contains(className)) {
        return c;
      }
    }
    n = n.parentElement;
  }
  return null;
}

function runUnitTests() {
  let anyFails = false;
  const testWord = (terms, expectedWord) => {
    const word = wordFromContFracTerms(terms);
    if (word != expectedWord) {
      console.error(`wordFromContFracTerms([${terms}]) produced ${word} instead of ${expectedWord}`);
      anyFails = true;
    }
  };

  testWord([], '');
  testWord([1], 'SL');
  testWord([1, 1], 'SSL');
  testWord([1, 1, 1], 'SSLSL');
  testWord([1, 1, 1, 1], 'SSLSSLSL');
  testWord([1, 1, 1, 1, 1], 'SSLSSLSLSSLSL');
  testWord([1, 1, 1, 1, 1, 1], 'SSLSSLSLSSLSSLSLSSLSL');
  testWord([1, 6, 2, 3, 1, 2], 'SSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSL');
  testWord([0, 2, 2], 'SLLSLLL');

  const testContFrac = (x) => {
    const y = getContFracValue(getContFracTerms(x, 100));
    if (Math.abs(x - y) > 1e-12) {
      console.error(`getContFracValue(getContFracTerms(${x}, 100)) produced ${y} instead of ${x}`);
      anyFails = true;
    }
  };

  for (let i = 0; i < 1000; ++i) {
    testContFrac(10 * Math.random());
    testContFrac(randInt(10000) / (randInt(10000) + 1));
  }

  if (!anyFails) {
    console.log('All tests passed :)');
  }
}

function getRayCellCrossingsDist(gx, ox, len) {
  if (gx == 0) return null;
  const k = (1 - ox) / gx;
  if (k >= len) return null
  return k;
}

function getRayCellCrossings(gx, gy, ox, oy, len) {
  let d = 0;
  let x = ox;
  let y = oy;
  const a = [];
  for (let i = 0; i < 100; ++i) {
    const l = len - d;
    const kx = getRayCellCrossingsDist(gx, x, l);
    const ky = getRayCellCrossingsDist(gy, y, l);
    const stop = kx == null && ky == null;

    let k = 0;
    let px = null;
    let py = null;
    let nx = null;
    let ny = null;
    if (stop) {
      k = l;
    } else if (ky == null || (kx != null && kx < ky)) {
      k = kx;
      px = 1;
      nx = 0;
    } else {
      k = ky;
      py = 1;
      ny = 0;
    }
    if (ny == null) ny = py = y + k * gy;
    if (nx == null) nx = px = x + k * gx;

    const nd = d + k;
    a.push([x, y, d / len, px, py, nd / len]);
    x = nx;
    y = ny;
    d = nd;

    if (stop) break;
  }
  return a;
}

function closestPointToLine(px, py, ox, oy, dx, dy) {
  // q = o + kd
  // (q - o) . (p - q) = 0
  // kd . (p - o - kd) = 0
  // d . (p - o - kd) = 0
  // d . (p - o) - k(d . d) = 0
  // d . (p - o) = k(d . d)
  // d . (p - o) = k  // d is a unit vector
  const k = dx * (px - ox) + dy * (py - oy);
  return [ox + k * dx, oy + k * dy];
}

function setupCanvas(canvas, viewWidth, lineWidthMul = 1) {
  const ctx = canvas.getContext('2d');
  ctx.setTransform(
      canvas.width / viewWidth, 0,
      0, -canvas.width / viewWidth,
      0, canvas.height);
  ctx.lineWidth = lineWidthMul * viewWidth / canvas.width;
  return ctx;
}

function onLoad() {
  runUnitTests();

  let forceRedraw = true;
  const onFrameCallbacks = [];
  const domUpdateLimiter = new RateLimiter();

  const allLiveValues = new Map();
  const liveValue = (id, nodeIds, init = 0, validate = x => x, onchange = () => {}) => {
    // Does a few things:
    // - Maintains the invariant that each dom element has the same value.
    // - Whenever the value changes, sets forceRedraw to true.
    // - Uses validate to sanitize, a function from float to nullable float.
    // - Returns an object with a value field that is kept up to date.
    // - Changes to that field are also reflected on the elements.
    const elements = nodeIds.map(id => document.getElementById(id));
    const oldValues = [];  // One for each element, and one for obj.value.
    for (const e of elements) {
      e.value = init;
      oldValues.push(e.value);
    }
    const obj = { value: init, reset: null };
    obj.reset = () => obj.value = init;
    oldValues.push(obj.value);
    onFrameCallbacks.push(() => {
      let anyChange = obj.value != oldValues[elements.length];
      let cause = null;
      if (!anyChange) {
        for (let i = 0; i < elements.length; ++i) {
          const e = elements[i];
          if (e.value != oldValues[i]) {
            const px = parseFloat(e.value);
            const x = isNaN(px) ? null : validate(px);
            if (x != null) {
              anyChange = true;
              obj.value = x;
              cause = i;
              break;
            }
          }
        }
      }
      if (anyChange) {
        forceRedraw = true;
        oldValues[elements.length] = obj.value;
        for (let i = 0; i < elements.length; ++i) {
          const e = elements[i];
          if (i != cause) {
            e.value = obj.value;
          }
          oldValues[i] = e.value;
        }
        onchange();
      }
    });
    allLiveValues.set(id, obj);
    return obj;
  };

  const domAdvancedOptions = document.getElementById('advanced_options');
  const domFlagAdvanced = document.getElementById('flag_advanced');
  domFlagAdvanced.addEventListener('change', () => {
    if (domFlagAdvanced.checked) {
      domAdvancedOptions.classList.remove('hidden');
    } else {
      domAdvancedOptions.classList.add('hidden');
    }
  });

  const allFlags = new Map();
  const makeFlag = (id, name, initValue = false, onChange = () => {}) => {
    const flag = { value: initValue, setValue: null };
    const div = newDiv(domAdvancedOptions, ['flag']);
    const check = newElement('input', div);
    check.setAttribute('type', 'checkbox');
    check.checked = initValue;
    flag.setValue = value => {
      if (value) {
        check.checked = true;
      } else {
        check.checked = false;
      }
      forceRedraw = true;
      flag.value = value;
      onChange();
    };
    check.addEventListener('change', () => flag.setValue(check.checked));
    const label = newElement('span', div, [], name);
    allFlags.set(id, flag);
    return flag;
  };

  let targKeep = false;
  let targX = null;
  let targY = null;
  const grad = liveValue('grad', ['in_grad', 'ins_grad'], 0.618033988749894,
      x => x >= 0 ? x : 0, () => {
    if (targKeep) {
      targKeep = false;
    } else {
      targX = null;
      targY = null;
    }
  });
  const off = liveValue('off', ['in_off', 'ins_off'], 0, x => fmod(x), () => {
    targX = null;
    targY = null;
  });
  let targCoeff = 0;
  const coeffterm = liveValue('coeff', ['coeff_slider'], 1, x => Math.floor(x),
      () => {
    const [terms, targCoeff_] = getContFracTermsWithTargCoeff(
        grad.value, contFracTerms, targCoeff);
    targCoeff = targCoeff_;
    const x = coeffterm.value;
    if (x == terms[targCoeff]) return;
    const terms_ = terms.slice(0);
    terms_[targCoeff] = x;
    grad.value = getContFracValue(terms_);
  });
  const rawzterm = liveValue('rawz', ['z_slider'], 0, x => clamp(x, 0, 1));

  const flagShowConvergents = makeFlag('aprx', 'Show approximants');
  const flagShowSteps = makeFlag('step', 'Show steps');
  const flagShowCrystal = makeFlag('crys', 'Show crystal');
  const flagUnitCellMode = makeFlag('unit', 'Unit cell mode');
  const flagShowZ = makeFlag('rem', 'Editable remainder');
  const flagContFracEdit = makeFlag('cont', 'Editable continued fraction');
  const flagSimpleFracEdit = makeFlag('simp', 'Editable simple fraction');

  const isInZMode = () => (
      flagShowZ.value && !flagContFracEdit.value && !flagSimpleFracEdit.value &&
      !flagUnitCellMode.value);
  const isInSimpleFracEditMode = () =>
      flagSimpleFracEdit.value && !flagContFracEdit.value;
  const getVisibleContFracTerms = () =>
      isInZMode() ? zModeContFracTerms : visibleContFracTerms;
  const getApproxContFracTerms = () =>
      isInZMode() ? zModeContFracTerms : visibleContFracTerms + 1;

  const canvas = document.getElementById('view');
  const crystalCanvas = document.getElementById('crystal_view');
  const domContFrac = document.getElementById('cont_frac');
  const domApproxEqual = document.getElementById('approx_equal');
  const domApproxFrac = document.getElementById('approx_frac');
  const domWord = document.getElementById('word');
  const domZSliderWrap = document.getElementById('z_slider_wrap');
  const domCoeffSliderWrap = document.getElementById('coeff_slider_wrap');
  const domAppMiddle = document.getElementById('middle');
  const domAppRight = document.getElementById('right');

  class SetGradient extends HTMLElement {
    constructor() {
      super();
      const y = (x => {
        if (x == 'p') return 0.618033988749894;
        if (x == 'phi') return 1.618033988749894;
        if (x == 'pi') return 3.141592653589793;
        if (x == 'e2') return 2.549646778303845;
        return parseFloat(x);
      })(this.getAttribute('x'));
      this.addEventListener('click', () => {
        grad.value = y;
      });
    }
  }
  customElements.define('s-g', SetGradient);

  const blogPageUpdater = [];
  const addBlogPage = (showApp, flags, liveValues) => {
      const flg = new Set(flags);
      const lvs = new Map(liveValues);
      blogPageUpdater.push(() => {
        if (showApp) {
          for (const [id, flag] of allFlags.entries()) {
            flag.setValue(flg.has(id));
          }
          for (const [id, lv] of allLiveValues.entries()) {
            if (lvs.has(id)) {
              lv.value = lvs.get(id);
            } else {
              lv.reset();
            }
          }
          domAppMiddle.classList.remove('hidden');
          domAppRight.classList.remove('hidden');
        } else {
          domAppMiddle.classList.add('hidden');
          domAppRight.classList.add('hidden');
        }
      });
  };

  addBlogPage(false);
  addBlogPage(false);
  addBlogPage(true, ['crys', 'step', 'simp']);
  addBlogPage(true, ['crys', 'step', 'simp']);
  addBlogPage(true, ['crys', 'step', 'simp']);
  addBlogPage(true, ['crys', 'step', 'simp']);
  addBlogPage(true, ['crys', 'step', 'cont']);
  addBlogPage(true, ['crys', 'step', 'cont']);
  addBlogPage(true, ['crys', 'step', 'aprx', 'cont']);
  addBlogPage(true, ['crys', 'step', 'aprx', 'rem']);
  addBlogPage(true, ['crys', 'step', 'aprx', 'cont']);
  addBlogPage(true, ['crys', 'step', 'aprx', 'cont']);
  addBlogPage(false);
  addBlogPage(false);

  const showBlog = index => blogPageUpdater[index]();
  document.getElementById('blog').addEventListener(
      'change', e => showBlog(e.detail));
  showBlog(0);

  const getZ = () => {
    const x = isInZMode() ? rawzterm.value : 0;
    if (x == 0) return [0, 1];
    if (x == 1) return [1, 0];
    if (x == 0.5) return [1, 1];
    const y = squishy(x, 4);
    const z = (1 / (1 - y)) - 1;
    return x < 0.5 ? [1, Math.floor(1 / z)] : [Math.floor(z), 1];
  };

  const fillContFracDom = (terms, zn, zd) => {
    const visibleTerms = getVisibleContFracTerms();
    emptyDiv(domContFrac);
    let n = terms.length;
    const trunc = n > visibleTerms;
    if (trunc) n = visibleTerms;
    --n;
    let node = domContFrac;
    const termDivs = [];

    const addTerm = (i, suffix, cls) => {
      const termWrap = newDiv(node, [cls]);
      const term = newDiv(termWrap, [], terms[i]);
      if (flagContFracEdit.value) {
        termWrap.classList.add('cont-frac-term-wrap');
        term.classList.add('cont-frac-term-clickable');
        if (targCoeff == i) {
          termWrap.classList.add('selected');
        }
        term.addEventListener('click', () => {
          for (const t of termDivs) {
            t.classList.remove('selected');
          }
          termWrap.classList.add('selected');
          targCoeff = i;
          coeffterm.value = terms[i];
        });
        newDiv(termWrap, ['cont-frac-term-line']);
      }
      termDivs.push(termWrap);
      if (suffix != '') newDiv(node, [cls], suffix);
    };

    for (let i = 0; i < n; ++i) {
      if (flagContFracEdit.value || !(i == 0 && terms[i] == 0)) {
        addTerm(i, ' + ', 'cont-frac-term');
      }
      const frac = newDiv(node, ['cont-frac-frac']);
      newDiv(frac, ['cont-frac-num'], '1');
      node = newDiv(frac, ['cont-frac-den']);
    }

    if (flagContFracEdit.value) {
      domCoeffSliderWrap.classList.remove('hidden');
    } else {
      domCoeffSliderWrap.classList.add('hidden');
    }

    if (isInZMode()) {
      domZSliderWrap.classList.remove('hidden');
      const haszd = zd > 1;
      addTerm(n, ' + ', haszd ? 'cont-frac-term' : 'cont-frac-term-end');
      const frac = newDiv(node, ['cont-frac-frac']);
      newDiv(frac, ['cont-frac-num'], zd == 0 ? '∞' : zn);
      if (haszd) newDiv(frac, ['cont-frac-den'], zd);
    } else {
      addTerm(n, trunc ? ' + ...' : '', 'cont-frac-term-end');
      domZSliderWrap.classList.add('hidden');
    }
  }

  const fillApproxFracDom = (terms, zn, zd) => {
    const [n, d] = getApproxFrac(terms, getApproxContFracTerms(), zn, zd);
    emptyDiv(domApproxFrac);
    if (isInSimpleFracEditMode()) {
      const makeText = (val, minVal, onChange) => {
        const inp = newElement('input', domApproxFrac, ['approx-frac-edit']);
        inp.value = val;
        inp.addEventListener('change', () => {
          const val = validate(parseFloat(inp.value),
            x => isFinite(x) && isInt(x) && (x >= minVal));
          if (val != null) onChange(val);
        });
      };
      makeText(n, 0, x => grad.value = x / d);
      newDiv(domApproxFrac, ['approx-frac-edit-line']);
      makeText(d, 1, x => grad.value = n / x);
      domApproxEqual.innerText = '=';
    } else {
      newDiv(domApproxFrac, ['approx-frac-num'], n);
      if (d != 1) newDiv(domApproxFrac, ['approx-frac-den'], d);
      domApproxEqual.innerText =
          getApproxContFracTerms() < terms.length ? '≈' : '=';
    }
  }

  let mainViewZoomExp = 0;
  const getMainViewSize = () =>
      mainViewSize * Math.pow(mainViewZoomRate, mainViewZoomExp);

  const getViewSize = () =>
      flagUnitCellMode.value ? cellViewSize : getMainViewSize();

  const getClickPos = e => {
    const viewSize = getViewSize();
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.x;
    const my = e.clientY - rect.y;
    const x = viewSize * mx / canvas.width;
    const y = viewSize * (1 - my / canvas.height);
    return [x, y];
  };

  let mouseClicked = false;
  let currentGx = 1;
  let currentGy = 0;
  let currentOx = 0;
  let currentOy = 0;
  const anchors = [];
  const snapToAnchor = (x, y, alsoSnapToLine) => {
    const viewSize = getViewSize();
    let mx = null;
    let my = null;
    let mi = null;
    let md = Infinity;
    const maybeSnap = (px, py, pi, distmul = 1) => {
      if (px >= 0 && py >= 0 && px <= viewSize && py <= viewSize) {
        const dx = x - px;
        const dy = y - py;
        const dd = distmul * (dx * dx + dy * dy);
        if (dd < md) {
          mx = px;
          my = py;
          mi = pi;
          md = dd;
        }
      }
    };
    for (let i = 0; i < anchors.length; ++i) {
      const [px, py] = anchors[i];
      maybeSnap(px, py, i);
    }
    maybeSnap(Math.floor(x + 0.5), Math.floor(y + 0.5), null, 1.1);
    if (alsoSnapToLine) {
      const [lx, ly] = closestPointToLine(
          x, y, currentOx, currentOy, currentGx, currentGy);
      maybeSnap(lx, ly, null, 2);
    }
    if (md > 0.05) return null;
    return [mx, my, mi];
  };
  const onMouse = (e, click) => {
    e.preventDefault();
    let [x, y] = getClickPos(e);
    if (!click) {
      const snap = snapToAnchor(x, y, false);
      if (snap != null) {
        x = snap[0];
        y = snap[1];
      }
    }
    const y_ = y + off.value;
    if (x <= 0) {
      grad.value = 1e3;
    } else if (y_ <= 0) {
      grad.value = 0;
    } else {
      grad.value = y_ / x;
    }
    targX = x;
    targY = y;
    targKeep = true;
  };
  const onRightClick = e => {
    forceRedraw = true;
    let [x, y] = getClickPos(e);
    const snap = snapToAnchor(x, y, true);
    if (snap == null) {
      anchors.push([x, y]);
    } else if (snap[2] == null) {
      anchors.push([snap[0], snap[1]]);
    } else {
      popSwap(anchors, snap[2]);
    }
  };
  canvas.addEventListener('mousedown', e => {
    if (e.which == 1) {
      onMouse(e, mouseClicked = true);
    } else if (e.which == 3) {
      onRightClick(e);
    }
  });
  document.addEventListener('mousemove', e => {
    if (mouseClicked) onMouse(e, mouseClicked);
  });
  document.addEventListener('mouseup', e => {
    if (e.which == 1 && mouseClicked) onMouse(e, mouseClicked = false);
  });

  canvas.addEventListener('contextmenu', e => e.preventDefault());
  canvas.addEventListener('wheel', e => {
    e.preventDefault();
    forceRedraw = true;
    mainViewZoomExp = clamp(mainViewZoomExp + (0.01 * e.deltaY), -20, 10);
  });

  const circle = (cc, px, py, r, clr) => {
    cc.fillStyle = clr;
    cc.beginPath();
    cc.ellipse(px, py, r, r, 0, 0, tau);
    cc.fill();
  };

  const line = (cc, px, py, qx, qy, clr) => {
    cc.strokeStyle = clr;
    cc.beginPath();
    cc.moveTo(px, py);
    cc.lineTo(qx, qy);
    cc.stroke();
  };

  const ray = (cc, px, py, dx, dy, clr) => {
    const len = 2 * getMainViewSize();
    line(cc, px, py, px + len * dx, py + len * dy, clr);
  };

  const update = () => {
    for (const fn of onFrameCallbacks) fn();

    if (alwaysRedraw || forceRedraw) {
      forceRedraw = false;
      const viewSize = getViewSize();
      const mainDotSize =
          mainDotInitSize * Math.sqrt(getMainViewSize() / mainViewSize);
      const dotSize = flagUnitCellMode.value ? cellDotSize : mainDotSize;
      const lineSize = flagUnitCellMode.value ? cellLineSize : mainLineSize;
      const ctx = setupCanvas(canvas, viewSize, lineSize);

      const [zn, zd] = getZ();
      const zmode = isInZMode();
      const g = grad.value;
      const o = off.value;
      const gx = 1 / Math.sqrt(1 + g * g);
      const gy = gx * g;

      if (!flagContFracEdit.value) {
        targCoeff = 0;
      }

      const [terms, targCoeff_] = getContFracTermsWithTargCoeff(
          grad.value, contFracTerms, targCoeff);
      targCoeff = targCoeff_;
      const zray = (n, d) => {
        if (!zmode) return [[gy, gx], g];
        const [y, x] = getApproxFrac(terms, getApproxContFracTerms(), n, d);
        return [unit(y, x), y / x];
      };

      const [[ugy, ugx], zg] = zray(zn, zd);
      const [[ugy0, ugx0], zg0] = zray(0, 1);
      const [[ugy1, ugx1], zg1] = zray(1, 0);

      const hitRad = isFinite(zg) ? (1 + zg) / Math.sqrt(1 + zg * zg) : 1;
      const hitGx = ugy;
      const hitGy = -ugx;
      const hitSx = hitGx * hitRad;
      const hitSy = hitGy * hitRad;
      const hitOx = 0;
      const hitOy = -o;
      const sequence = sequenceFromGrad(zg, o, genSeqLength);

      currentGx = ugx;
      currentGy = ugy;
      currentOx = hitOx;
      currentOy = hitOy;

      // Clear to black.
      ctx.fillStyle = 'rgba(0, 0, 0, 1)';
      ctx.fillRect(-2 * viewSize, -2 * viewSize, 4 * viewSize, 4 * viewSize);

      // Draw dots.
      const dotClr = zmode ? 'rgba(34, 34, 34, 1)' : 'rgba(68, 68, 68, 1)';
      for (let i = 0; i <= viewSize; ++i) {
        for (let j = 0; j <= viewSize; ++j) {
          circle(ctx, i, j, dotSize, dotClr);
        }
      }

      // Draw kernel lines.
      const kernDraw = viewSize + 1;
      for (let i = -1; i <= kernDraw; ++i) {
        for (let j = -1; j <= kernDraw; ++j) {
          line(ctx, i, j, i + hitSx, j + hitSy, dotClr);
        }
      }

      // Draw anchors.
      for (const [x, y] of anchors) {
        circle(ctx, x, y, 2 * dotSize, 'rgba(156, 39, 176, 1)');
      }

      // Calculate ray hits.
      let px = 0;
      let py = 0;
      const hits = [];
      for (const goUp of sequence) {
        const x = px + (goUp ? 0 : 1);
        const y = py + (goUp ? 1 : 0);
        const k = ugx * (x - hitOx) + ugy * (y - hitOy);
        const ux = hitOx + k * ugx;
        const uy = hitOy + k * ugy;
        hits.push([px, py, x, y, ux, uy, k]);
        px = x;
        py = y;
      }

      if (!flagUnitCellMode.value) {  // Normal mode.
        // Draw rays.
        if (zmode) {
          ray(ctx, hitOx, hitOy, gx, gy, 'rgba(255, 255, 255, 0.5)');

          // Draw z, z=0, and z=inf lines, if in z mode.
          ray(ctx, hitOx, hitOy, ugx, ugy, `rgba(255, 255, 255, 1)`);
          ray(ctx, hitOx, hitOy, ugx0, ugy0, `rgba(255, 255, 255, 0.5)`);
          ray(ctx, hitOx, hitOy, ugx1, ugy1, `rgba(255, 255, 255, 0.5)`);
        } else {
          ray(ctx, hitOx, hitOy, gx, gy, 'rgba(255, 255, 255, 1)');
        }

        // Draw hit kernel lines.
        for (const [px, py, x, y, ux, uy, k] of hits) {
          line(ctx, x, y, ux, uy, 'rgba(0, 136, 255, 1)');
          circle(ctx, x, y, dotSize, 'rgba(0, 136, 255, 1)');
        }

        // Hilite the dots between the z rays, if in z mode.
        if (zmode) {
          for (let i = 0; i <= viewSize; ++i) {
            for (let j = 0; j <= viewSize; ++j) {
              const k = (j - hitOy) / (i - hitOx);
              if (k >= zg1 && k <= zg0) {
                circle(ctx, i, j, dotSize, 'rgba(170, 170, 170, 1)');
              }
            }
          }
        }

        // Draw hit dots.
        for (const [px, py, x, y, ux, uy, k] of hits) {
          circle(ctx, ux, uy, 2 * dotSize, 'rgba(255, 34, 0, 1)');
        }

        // Draw steps.
        if (flagShowSteps.value) {
          for (const [px, py, x, y, ux, uy, k] of hits) {
            line(ctx, px, py, x, y, 'rgba(0, 255, 0, 0.8)');
          }
        }

        // Draw approximants, if enabled.
        if (flagShowConvergents.value) {
          for (let i = 1; i <= terms.length; ++i) {
            const [y, x] = getApproxFrac(terms, i);
            circle(ctx, x, y, 2 * dotSize, 'rgba(255, 255, 0, 1)');
          }
        }
      } else {  // Unit cell mode.
        // Draw ray.
        const rcc = getRayCellCrossings(ugx, ugy, hitOx, hitOy, cellRayLength);
        for (const [ax, ay, ak, bx, by, bk] of rcc) {
          const grd = ctx.createLinearGradient(ax, ay, bx, by);
          grd.addColorStop(0, `rgba(255, 255, 0, ${1 - ak})`);
          grd.addColorStop(1, `rgba(255, 255, 0, ${1 - bk})`);
          line(ctx, ax, ay, bx, by, grd);
        }

        // Modulo all the ray hits into the unit cell.
        const modhits = [];
        for (const [px, py, x, y, ux, uy, k] of hits) {
          if (k > cellRayLength) break;
          const mux = fmod(ux);
          const muy = fmod(uy);
          const gux = x + mux - ux;
          const guy = y + muy - uy;
          const alpha = 1 - k / cellRayLength;
          modhits.push([mux, muy, gux, guy, alpha])
        }

        // Draw hit dots.
        for (const [mux, muy, gux, guy, alpha] of modhits) {
          circle(ctx, mux, muy, dotSize, `rgba(255, 34, 0, 1)`);
        }
      }

      // Draw target point, if it exists.
      if (targX != null && targY != null) {
        circle(ctx, targX, targY, 2 * dotSize, 'rgba(255, 255, 255, 1)');
      }

      domUpdateLimiter.run(timeBetweenDomUpdatesMs, () => {
        // Fill continued fraction and approx fraction.
        fillContFracDom(terms, zn, zd);
        fillApproxFracDom(terms, zn, zd);

        // Fill word.
        const word = sequence.map(x => x ? 'S' : 'L').join('');
        domWord.innerText = word;
      });

      // Draw the crystal, if enabled.
      if (flagShowCrystal.value) {
        const viewSize = getMainViewSize();
        const crystalCtx = setupCanvas(crystalCanvas, viewSize);
        crystalCanvas.classList.remove('hidden');
        crystalCtx.fillStyle = 'rgba(0, 0, 0, 1)';
        crystalCtx.fillRect(
          -2 * viewSize, -2 * viewSize, 4 * viewSize, 4 * viewSize);
        const midy = 0.025 * viewSize;
        line(crystalCtx, 0, midy, viewSize, midy, 'rgba(255, 255, 255, 1)');
        for (const [px, py, x, y, ux, uy, k] of hits) {
          circle(crystalCtx, k, midy, 2 * mainDotSize, 'rgba(255, 34, 0, 1)');
        }
      } else {
        crystalCanvas.classList.add('hidden');
      }
    }

    window.requestAnimationFrame(update);
  };
  update();
}
window.addEventListener('load', onLoad);

class YouTubeEmbed extends HTMLElement {
  constructor() {
    super();
    const isBig = this.getAttribute('size') == 'big';
    const iframe = newElement('iframe', this);
    iframe.setAttribute('width', isBig ? 1000 : 560);
    iframe.setAttribute('height', isBig ? 563 : 315);
    iframe.setAttribute('title', 'YouTube video player');
    iframe.setAttribute('frameborder', 0);
    iframe.setAttribute(
        'allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; ' +
            'gyroscope; picture-in-picture; fullscreen');
    iframe.setAttribute(
        'src', 'https://www.youtube.com/embed/' + this.getAttribute('src'));
  }
}
window.addEventListener(
    'load', () => customElements.define('youtube-embed', YouTubeEmbed));

let shownQuizAnswer = null;
class QuizAnswer extends HTMLElement {
  constructor() {
    super();
    this.answerHTML = this.innerHTML;
    this.innerText = '[Discussion]';
    this.answerDiv = findCousinDivWithClass(this, 'quiz-answer');
    this.addEventListener('click', () => {
      if (shownQuizAnswer != this) {
        shownQuizAnswer = this;
        this.answerDiv.innerHTML = this.answerHTML;
        this.answerDiv.classList.add('shown');
      } else {
        shownQuizAnswer = null;
        this.answerDiv.innerHTML = '';
        this.answerDiv.classList.remove('shown');
      }
    });
  }
}
window.addEventListener(
    'load', () => customElements.define('quiz-answer', QuizAnswer));
</script>
<style>
html {
  min-height: 100%;
}
body {
  background-color: #212121;
  margin: 0;
  overflow-y: scroll;
}
#head {
  background-color: #424242;
  width: 100%;
  display: flex;
  justify-content: space-around;
  margin-bottom: 4px;
}
h1, #index {
  color: #ffc107;
  text-align: center;
  font-family: monospace;
  font-size: 42px;
  flex-grow: 1;
  padding: 16px;
  margin: 0;
}
#index {
  color: #ff5722;
  text-decoration: none;
  flex-grow: 0;
}
h2 {
  color: #ff5722;
  font-family: monospace;
}
a {
  color: #ffc107;
  font-family: monospace;
  font-size: 16px;
  cursor: pointer;
  text-decoration: underline;
}
#wrap {
  padding: 0 16px;
  color: #f5f5f5;
  font-family: monospace;
  font-size: 16px;
}
#layout {
  display: flex;
  flex-direction: row;
  width: 100%;
  gap: 16px;
}
#left {
  flex-grow: 1;
}
#middle {
  display: flex;
  flex-direction: column;
}
#right {
  display: flex;
  flex-direction: column;
  flex-shrink: 0;
  width: 350px;
}
#word {
  overflow: hidden;
  text-overflow: ellipsis;
  width: 330px;
}
.cont-frac-term {
  margin-top: 0.6em;
}
.cont-frac-term-end {
  margin-top: 0;
}
.cont-frac-frac {
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.cont-frac-num, .approx-frac-num {
  text-align: center;
}
#cont_frac, .cont-frac-den {
  display: flex;
  flex-direction: row;
  justify-content: center;
  gap: 4px;
}
.cont-frac-den, .approx-frac-den, .approx-frac-edit-line {
  border-top: 2px solid #f5f5f5;
  text-align: center;
}
.approx-frac-edit-line {
  margin: 4px;
}
.approx-frac-edit {
  max-width: 50px;
}
.cont-frac-term-wrap {
  display: flex;
  flex-direction: column;
  justify-content: top;
  align-items: center;
  min-height: 30px;
}
.cont-frac-term-clickable {
  cursor: pointer;
}
.cont-frac-term-clickable:hover {
  background-color: rgba(0, 128, 255, 0.5);
}
.selected .cont-frac-term-clickable {
  background-color: rgba(0, 128, 255, 1);
}
.cont-frac-term-line {
  display: none;
  background-color: rgba(0, 128, 255, 1);
  flex-grow: 1;
  width: 1px;
}
.selected .cont-frac-term-line {
  display: block;
}
.frac-row {
  display: flex;
  flex-direction: row;
  width: 100%;
  gap: 8px;
  justify-content: center;
  align-items: center;
  min-height: 140px;
}
#approx_equal {
  font-size: 32px;
}
#approx_frac {
  display: flex;
  flex-direction: column;
  justify-content: center;
}
#z_slider_wrap, #coeff_slider_wrap {
  display: flex;
  flex-direction: row;
  justify-content: center;
  gap: 4px;
}
#z_slider, #coeff_slider {
  flex-grow: 1;
}
.hidden {
  display: none !important;
}
#advanced_options {
  background-color: #FFF1;
}
.flag {
  display: flex;
  flex-direction: row;
  width: 100%;
  gap: 8px;
  justify-content: flex-start;
}
slide-show {
  display: none;
}
slide-show.loaded {
  display: flex;
  flex-direction: column-reverse;
  align-items: center;
  gap: 8px;
}
.slide-show-slide-row,
.slide-show-slides,
.slide-show-slide-wrap {
  width: 100%;
}
.slide-show-dot-row {
  width: 100%;
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
  gap: 8px;
}
.slide-show-dot {
  cursor: pointer;
  width: 8px;
  height: 8px;
  border-radius: 4px;
  background-color: #FFF2;
}
.slide-show-dot.active {
  background-color: #FFF;
}
.slide-show-button {
  cursor: pointer;
  user-select: none;
}
.slide-show-button.disabled {
  pointer-events: none;
  opacity: 50%;
}
quiz-answer {
  cursor: pointer;
  color: #ff5722;
}
quiz-answer:hover {
  color: #ffc107;
}
b {
  color: #ffc107;
}
.questions {
  margin-left: 12px;
}
.quiz-answer {
  display: none;
  background-color: #ffffff11;
  padding: 8px;
  margin-bottom: 8px;
}
.quiz-answer.shown {
  display: block;
}
.center {
  width: 100%;
  text-align: center;
  display: inline-block;
}
s-g {
  color: #b39ddb;
  cursor: pointer;
}
s-g:hover {
  color: #d1c4e9;
}
.blog-youtube {
  display: flex;
  justify-content: center;
}
</style>
</head>
<body>
<div id="head">
  <a id="index" href="index.html">&lt;</a>
  <h1>Number Theory and Quasicrystals</h1>
</div>
<div id="wrap">
  <div id="layout">
    <div id="left">
      <slide-show id="blog" button-layout="low" loop="false"
          prev="Prev <" next="> Next">
        <div class="blog-youtube">
          <youtube-embed src="3UErP7P5JHk" size="big"></youtube-embed>
        </div>


        <div class="blog-youtube">
          <youtube-embed src="5A2LUx89d20" size="big"></youtube-embed>
        </div>


        <span>
          <!-- 1 -->
          <h2>Periodic Crystals</h2>

          You can click and drag the slope of the line and watch the crystal
          structures (bottom) and sequences (right) which form based on this.
          Use the mouse wheel to zoom.
          <br/><br/>

          <div class="questions">
            <b>Q1)</b> Can you make a periodic structure?
            <quiz-answer>
              Try clicking on any of the grid points. Periodicity should be
              easiest to see for points near the bottom left (the origin).
            </quiz-answer>
            <br/><br/>

            <b>Q2)</b> What property of a gradient determines whether it forms
            periodic structures?
            <quiz-answer>
              Rationality - i.e. the gradient being written as a fraction of
              finite integers. Since the gradient is the number of steps up
              divided by the number of steps along,
              any line connecting two grid points has a rational gradient.
              If we hit the point $(q,p)$ (starting from $(0,0)$), we get a
              gradient of $\frac{p}{q}$, and the same holds in reverse:
              a gradient of $\frac{p}{q}$ must hit $(q,p)$.
            </quiz-answer>
            <br/><br/>

            <b>Q3)</b> How does the gradient determine how many atoms
            appear in a periodic crystal before it begins to repeat?
            <quiz-answer>
              If we look at the
              staircase representation, we can see the total number of atoms
              is given by the number of steps up, plus the number along,
              meaning there will always be $p+q$ atoms per repetition
              (or 'in the unit cell').
            </quiz-answer>
            <br/><br/>
          </div>

          If a line directly hits a lattice point, that fixes its gradient, so
          at least <i>some</i> gradients can be represented by just a point.
          <br/><br/>

          <div class="questions">
            <b>Q4)</b> Is this representation unique?
            <quiz-answer>
              The fraction $p \over q$, corresponding to hitting the point
              $(q,p)$, isn't unique - we could multiply top and bottom by
              an integer, and find another point the line hits
              ($np \over nq$ and $(nq,np)$).
            </quiz-answer>
            <br/><br/>

            <b>Q5)</b> What additional requirement could you add to <i>make</i>
            it unique?
            <quiz-answer>
              If we want to find a <i>unique</i> point corresponding to any
              gradient, we can always simplify $\frac{p}{q}$ by cancelling all
              common factors between $p$ and $q$, corresponding to finding the
              first point we hit as we move out from the origin.
            </quiz-answer>
            <br/><br/>

            <b>Q6)</b> Do all possible gradients correspond to a point on the
            lattice in this way? What does this mean for forming non-periodic
            crystals?
            <quiz-answer>
              We know all rational gradients correspond to a point,
              so the only remaining gradients to account for are
              irrational ones (meaning they can't be written
              $p \over q$, where $p$ and $q$ are finite integers - say like
              <s-g x="pi">$\pi$</s-g>,
              <s-g x="phi">$\phi$</s-g>,
              <s-g x="1.414213562373095">$\sqrt{2}$</s-g>, or
              <s-g x="1.258498950641826">$\sqrt[7]{5}$</s-g>)?
              <br/>

              Our 'point-based' representation requires that we hit a point
              aside from $(0,0)$. But hitting any other point $(q,p)$ forces
              the gradient to be $\frac{p}{q}$. Since this
              can't be the case for irrational numbers,
              irrational numbers never hit a point, and can't
              be represented in this way.
              <br/>

              Since the graient needs to hit a point other than $(0,0)$
              to be periodic, and these never do, irrational numbers
              form non-periodic structures. This isn't enough to be a
              quasicrystal though, so learning about the number of
              consecutive repetitions of parts of a crystal will
              therefore be a major focus for us.
            </quiz-answer>
            <br/><br/>
          </div>

          We'll spend a lot of time investigating the link between
          structures of different gradients. You can save an
          anchor point by right-clicking, to which you can snap
          the gradient later. Try right-clicking near a lattice
          point, near the gradient, and far away from either. Anchor
          points are also removed by right-clicking on them.
          <br/><br/>

          <div class="quiz-answer"></div>
        </span>


        <span>
          <!-- 2 -->
          <h2>Offsets and Words</h2>

          Let's take a look at how the offset slider
          affects the generated structure, and how structures
          can be understood as a sequence of letters.
          <br/><br/>

          <div class="questions">
            <b>Q1)</b> Can you spot the relationship between the pattern of
            atoms/steps and the sequence of 'S's and 'L's on the right?
            <quiz-answer>
              For gradients less than 1, we tend to label the atoms based
              on whether they correspond to short (S) or long (L) gaps.
              This corresponds to steps <i>up</i> on the staircase corresponding
              to the letter S, and steps <i>along</i> corresponding to the
              letter L.
            </quiz-answer>
            <br/><br/>

            <b>Q2)</b> Does this still hold if we increase the gradient past 1?
            <quiz-answer>
              When the gradient is 1, using 'S' for short segments
              and 'L' for long segments poses a
              problem: steps up and along are both the same length.
              For gradients greater than 1, steps up are now
              the longer ones, and vice versa. In order to maintain
              some sense of continuity, however, we remain labelling
              steps up (such as the first point) with an S, even
              for gradients greater than 1. Practically, the exact
              spacing can be accounted for in other ways, and often
              isn't used, so the letters are mostly arbitrary.
              A more consistent definition is to, think of S as
              steps up, and L as steps along.
            </quiz-answer>
            <br/><br/>

            <b>Q3)</b> Can you spot any rough pattern between the length of
            runs of the same letter (known as that letter's power),
            and the gradient?
            <quiz-answer>
              You might have also seen that the letter S will have
              a power of the gradient rounded either down or up.
              This turns out to generalise to the powers of more
              complicated structures, as we'll see later, and
              is part of how we'll prove aperiodicity.
            </quiz-answer>
            <br/><br/>
          </div>

          Since the structure of atoms is determined by this sequence of
          letters, this sequence is quite important. Sometimes
          referred to as the 'word' for a particular gradient.
          <br/><br/>

          <div class="questions">
            <b>Q4)</b> Pick a simple rational number for the gradient - say
            something like <s-g x="0.333333333333333">$1 \over 3$</s-g>.
            By how much do you have to change
            the offset before atoms begin to jump?
            <quiz-answer>
              For a fraction simplified to $p \over q$, we need to increase
              the offset to at least $1 \over q$ for the first hop to occur.
              The graph of these distances is
              known as
              <a target="_blank" href="https://en.wikipedia.org/wiki/Thomae%27s_function">Thomae's function</a>,
              or the popcorn function. To a physicist's eye, this function
              is truly an abomination, it has the property that,
              despite being continuous almost everywhere, it's
              never continuous over any finite range (it's discontinuous
              at every rational number). It's a great example of
              why calculus and number theory tend to be so disjoint -
              good luck trying to write a differential equation
              which describes <i>this</i>!
            </quiz-answer>
            <br/><br/>

            <b>Q5)</b> Are atoms conserved as we change the offset?
            <quiz-answer>
              Atoms are, in fact, conserved (meaning this
              can happen in real quasicrystals - it's called a 'phason').
              From the perspective of the staircase, moving past a
              point corresponds from changing an along-then-up (i.e. LS)
              to an up-then-along (SL).
            </quiz-answer>
            <br/><br/>
          </div>

          Now, try an irrational number - say something like
          <s-g x="p">$\phi^{-1}$</s-g>.
          <br/><br/>

          <div class="questions">
            <b>Q6)</b> How far do you have to move the offset now, before atoms
            begin to jump (and how do you think this would change if we
            could zoom as far out as we liked)?
            <quiz-answer>
              For irrational numbers, any finite movement,
              however small, will correspond to a jump - it might just
              be really far away! Compared to
              rational numbers, where numbers of the form $p \over q$ change
              after a shift by $1 \over q$, irrational numbers can
              <i>roughly</i> be thought of as having infinite
              $p$ and $q$, so ${1 \over q} = 0$.
            </quiz-answer>
            <br/><br/>

            <b>Q7)</b> Are the first atoms to move near to the origin,
            or far away? Why?
            <quiz-answer>
              Aside from the hop precisely at the origin,
              for irrational numbers, the first hops are always
              a long way away. A rough argument for this
              is that a change in structure near the origin would
              require, as we lift up our line, that it crosses
              a point near the origin before any
              further away, implying that the best approximation
              to the gradient
              is near the origin. However, this implies that
              there even <i>exists</i> a best rational approximation to a
              particular irrational number, and it should be fairly
              easy to convince yourself that given any rational
              approximation, we can always build another, better one.
            </quiz-answer>
            <br/><br/>

            <b>Q8)</b> If I suggest that you can view a change in offset
            as moving our origin to a new latice point,
            am I right or wrong? Does your answer depend on whether
            or not the crystal is rational?
            <quiz-answer>
              As it turns out, only <i>certain</i> offsets correspond
              directly to a shift in our perspective. Specifically,
              it's those offsets which have <i>just</i> caused an atom to
              jump: our line now crosses through the atom which
              <i>just</i> jumped, and it's therefore equivalent to our
              origin. Hence, in the case of an irrational number,
              where any finite movement produces jumps,
              continuously changing the offset is equivalent to
              pinging us wildly across our infinite,
              non-periodic, crystal.
            </quiz-answer>
            <br/><br/>
          </div>

          <div class="quiz-answer"></div>
        </span>


        <span>
          <!-- 3 -->
          <h2>Approximants</h2>

          Remember that you can mark and un-mark lattice
          points by right-clicking to place an anchor, and
          right-clicking the anchor to remove it.

          <div class="questions">
            <b>Q1)</b> Given the structure of a particular irrational
            number (say <s-g x="p">$\phi^{-1}$</s-g>),
            can you find a series of rational
            gradients (and therefore periodic structures, known
            as approximants) which tend towards
            <s-g x="p">$\phi^{-1}$</s-g> (you can do
            this roughly, visually, or mathematically)?
            <quiz-answer>
              One answer to this is to base this off all the
              truncated decimal expansions of
              <s-g x="p">$\phi^{-1}$</s-g>, so:
              $${0 \over 1},{6 \over 10},{61 \over 100},{618 \over 1000},{61803 \over 100000},...$$
              Which, cancelling common factors, gives:
              $${0 \over 1},{3 \over 5},{61 \over 100},{309 \over 500},{61803 \over 100000},...$$
            </quiz-answer>
            <br/><br/>

            <b>Q2)</b> Is this sequence unique?
            <quiz-answer>
              Series of rational numbers approaching
              <s-g x="p">$\phi^{-1}$</s-g>
              are far from unique: sequences don't even
              need to get closer at every step, so there
              are lots of ways one can safely add or remove
              points from a sequence without damaging
              its convergence.
              (That's not to say the points we could add are
              <i>unconstrained</i> - if you added $\frac{1}{1}$
              after every approximant to
              <s-g x="p">$\phi^{-1}$</s-g>, there
              would still be parts of your sequence which
              <i>wouldn't</i> get closer, breaking convergence.)
            </quiz-answer>
            <br/><br/>

            <b>Q3)</b> If I add the condition that we have to
            get closer with <i>every</i> term added, and that we
            never add a fraction with a higher denominator
            if one with a lower denominator could do a
            better job, how does that narrow down your choices?
            <quiz-answer>
              Two sequences which satisfy this condition for
              <s-g x="p">$\phi^{-1}$</s-g>
              can be expressed particularly nicely in terms of
              the Fibonacci numbers.
              $${1 \over 1},{1 \over 2},{2 \over 3},{3 \over 5},{5 \over 8},{8 \over 13},{13 \over 21},...$$
              $${1 \over 1},{2 \over 3},{5 \over 8},{13 \over 21},...$$
              In general, this condition will narrow down
              your options a lot, but it will be far from
              unique, so these aren't the only options you
              could have picked. If you didn't find any sequences
              like these, I'd suggest checking these out and
              getting a sense of their properties. In particular,
              the first one will be key later on, whilst the second
              may provide an interesting lens with which to contrast
              the decisions we take when introducing continued
              fractions, later.
            </quiz-answer>
            <br/><br/>

            <b>Q4)</b> [Something of an extension, for those interested
            in adding rigor to the idea of strings 'converging']:
            In what sense are these good approximations,
            and why might not all ways to define 'closeness to our
            limit' agree on whether or not we converge?
            <quiz-answer>
              When we say a list of things converges to something,
              we mean that, as we move throughout a list, we can say
              that all future values in the list have a 'distance to
              our limit' less than some number, and that, as we move
              throughout our list, that 'distance' drops to zero.
              Basing approximants around convergent gradients
              essentially asks the question 'Within the first
              period of our approximant, what's the length of the
              longest continuous subsequence which matches the limit?',
              defining 'distance to the limit' as the inverse of this
              answer. For an example, compare the respective limit and
              approximant
              <br/><br/>
              <span class="center"><b>SLSLLSL</b>SLLSLLSLSLLSL...</span>
              <br/><br/>
              <span class="center"><b>SLSLLSL</b>L|SLSLLSLL|...</span>
              <br/><br/>
              The bar denotes the periods of the approximant, and
              the bold section is the longest continuous subsequence.
              It has 7 letters, and hence the 'distance' is $\frac{1}{7}$.
              If, instead, we defined the 'distance' based around asking
              'What proportion of the infinite periodic sequence and
              the limit match?', the question of convergence might be
              far less clear, and certainly would be beyond the scope
              of this introduction.
              It's these sorts of details us physicists like to ignore
              which really wind up the mathematicians, so they're good
              things to look out for.
            </quiz-answer>
            <br/><br/>

            <b>Q5)</b> How does the distribution of approximants
            change for other irrational numbers (say
            <s-g x="1.414213562373095">$\sqrt{2}$</s-g>)?
            <quiz-answer>
              For <s-g x="p">$\phi^{-1}$</s-g>, it seems
              like there's a nice (and maybe
              even complete, in some sense, in the set that a
              large class of other sets can be constructed from
              it) set of approximants meeting the condition that
              each gets progressively closer to
              <s-g x="p">$\phi^{-1}$</s-g>, given
              earlier by:
              $${1 \over 1},{1 \over 2},{2 \over 3},{3 \over 5},{5 \over 8},{8 \over 13},{13 \over 21},...$$
              And, if you try to find these on the graph, you'll
              find they alternate. For
              <s-g x="1.414213562373095">$\sqrt{2}$</s-g>,
              however, if we try to
              find something similar, we might find something like:
              $$\frac{1}{1},\frac{3}{2},\frac{4}{3},\frac{7}{5},...$$
              Which contains, close to the origin,
              a point which breaks the pattern of alternation:
              $(3,4)$, or $4 \over 3$. We'll see later that the sequence for
              <s-g x="p">$\phi^{-1}$</s-g> generalises nicely
              to other irrational numbers,
              but should always remember that, <i>unlike</i> in the
              case of <s-g x="p">$\phi^{-1}$</s-g>, there in
              general may also be other
              numbers which <i>could</i> fit into our
              sequence, with different properties. They won't cause
              us any problems, but their existence is worth remembering.
            </quiz-answer>
            <br/><br/>
          </div>

          <div class="quiz-answer"></div>
        </span>


        <span>
          <!-- 4 -->
          <h2>Moving Between Approximants</h2>

          We can now construct a series of approximants to our
          quasicrystal, but that doesn't leave us better off,
          if the only way of calculating the next approximant
          is by producing the staircase, or intersection construction,
          for the approximant line. If we have to do that,
          we might as well go right back to drawing the line
          for <s-g x="p">$\phi^{-1}$</s-g> and avoid
          calculations with any other
          lines. However, what if we began by calculating an
          incredibly simple approximant (say $\frac{1}{1}$
          for <s-g x="pi">$\pi$</s-g>), and then just work
          out the <i>changes</i>
          as we move between successive approximants?
          <br/>
          Unlike their infinite non-periodic limit, rational approximants
          also have the advantage of periodicity
          - in order to understand an approximant's structure
          <i>everywhere</i>, we only actually need to understand
          a single period, even if it does get very large.
          <br/><br/>

          <div class="questions">
            <b>Q1)</b> Consider slowly moving the graph from a
            rational point near the origin to any other further
            out: When, visually, will a given atom hop?
            (Hint: This is similar to what we found when adjusting
            the offset earlier).
            <quiz-answer>
              The structure changes whenever the gradient line
              crosses a lattice point.
            </quiz-answer>
            <br/><br/>

            <b>Q2)</b> Where does the structure change the least?
            Is it close to the origin, or further away?
            <quiz-answer>
              As we saw earlier when varying the offset, the number of
              lattice points close to the line is the
              lowest near the origin, meaning changes to the gradient
              will cross the
              fewest points, such that changes in the gradient
              are understood most simply, there.
            </quiz-answer>
            <br/><br/>

            <b>Q3)</b> Focusing now on the first period of the
            final structure, what determines how many changes
            occur between the two lines (i.e., how many times
            do atoms jump position as we move?).
            <quiz-answer>
              The number of changes between the two lines
              will depend slightly on if you're moving up
              or down. If you're moving up (i.e. $1 \over 1$ to
              $17 \over 16$, both approximations to
              <s-g x="1.059463094359295">$\sqrt[12]{2}$</s-g>, the
              frequency multiplier for a semitone on a
              typical piano), you will instantly push out
              the staircase at all points corresponding to the
              first approximant, $1 \over 1$
              (i.e. $(n,n)$), whilst moving the gradient
              downwards by a small amount makes no instant
              change at these
              points (this is all simply based on how the
              staircase structure was defined). Otherwise,
              the number of changes from a smaller
              approximant to a larger approximant within
              the first period is simply the number of
              points between those lines, plus those points
              possibly corresponding to the approximants themselves.
            </quiz-answer>
            <br/><br/>

            <b>Q4)</b> Consider our approximants to
            <s-g x="p">$\phi^{-1}$</s-g>, as
            chosen above: how many points in the first
            period (as well as <i>which</i> points) change as we
            move between approximants (particularly
            successive approximants) from the sequence below?
            $${1 \over 1},{1 \over 2},{2 \over 3},{3 \over 5},{5 \over 8},{8 \over 13},{13 \over 21},...$$
            <quiz-answer>
              This sequence has the property (as for <i>why</i>
              this is the case, we'll find this out later) that
              the only changes within the first period of the
              larger approximation are those corresponding to the
              approximants themselves - there are no points between
              the lines until we get to much higher denominators
              (again, we'll prove this later). Therefore, there should
              be one change every time the line is moved, each time
              at the site of one of the approximants.
            </quiz-answer>
            <br/><br/>

            <b>Q5)</b> Can you find another sequence where even
            fewer points change between each step?
            <quiz-answer>
              It turns out, at least one point always has to change
              as we move from rational approximant to rational
              approximant. However, we <i>can</i> find a sequence with
              this minimum number of points changing, but which
              converges faster. As an example, what if we choose
              approximants which converge from above, rather than
              alternating, such
              as the other series we found earlier for
              <s-g x="p">$\phi^{-1}$</s-g>:
              $${1 \over 1},{2 \over 3},{5 \over 8},{13 \over 21},...$$

              It's worth noting the reason we're able to make
              this gain to convergence, which we can see if we
              move from $5 \over 8$ down to $8 \over 13$ and back up
              to $13 \over 21$, whilst
              paying attention to, rather than the first period
              of $8 \over 13$, the first period of $13 \over 21$.
              The act of moving
              down to hit $8 \over 13$ changes one point, but moving back
              up to $13 \over 21$ undoes that change straight after.
            </quiz-answer>
            <br/><br/>

            <b>Q6)</b> Two approximants for
            <s-g x="1.414213562373095">$\sqrt{2}$</s-g>
            are given by $7 \over 5$,
            and $17 \over 12$, do the changes as you move
            between these two fit your intuition from
            <s-g x="p">$\phi^{-1}$</s-g>?
            <quiz-answer>
              For the approximants of
              <s-g x="1.414213562373095">$\sqrt{2}$</s-g>
              given, something
              different does happen, although you may or
              may not have already built this into your
              model. The distance between the two approximants
              is sufficiently large that two points corresponding to
              the $7 \over 5$
              approximant occur before $17 \over 12$ (specifically, the
              points $(5,7)$ and $(10,14)$), meaning that rather than
              one point hopping, as in the case of
              <s-g x="p">$\phi^{-1}$</s-g>, we see
              two points hopping, instead.
            </quiz-answer>
            <br/><br/>
          </div>

          <div class="quiz-answer"></div>
        </span>


        <div class="blog-youtube">
          <youtube-embed src="4ClmhtmQajo"></youtube-embed>
        </div>


        <div class="blog-youtube">
          <youtube-embed src="PE7Qas8Kct4"></youtube-embed>
        </div>


        <span>
          <!-- 6a -->
          <h2>Proving we have Approximants</h2>

          Having introduced continued fractions, and suggested
          that the truncated continued fractions would form a
          useful set of approximants, all that we have left to
          do is to show that, in fact, they do. The property
          we'd like to demonstrate is that gradients between
          two of our approximants always have a more
          complicated fraction.
          <br/><br/>

          <div class="questions">
            <b>Q1)</b> By editing the coefficients of the
            continued fraction, convince yourself that, as you
            move down the fraction, increasing the coefficients
            alternately increases and decreases the value of
            the continued fraction. Can you work out why this is?
            <quiz-answer>
              Increasing the first (or, I guess, zeroth)
              coefficient of the continued fraction has a
              fairly obvious effect - we're just increasing
              a number out the front of the fraction:
              $$a_0+m+\frac{1}{a_1+...}$$
              will always increase as $m$ increases -
              which holds even if $m$ isn't an integer.
              If we add $m$ to $a_1$, which gives us:
              $$a_0+\frac{1}{a_1+m+...}$$
              increasing it increases something we're dividing by,
              and so decreases the result. What if we go deeper?
              Increasing $a_2$ gives:
              $$a_0+\frac{1}{a_1+\frac{1}{a_2+m+...}}$$
              Increasing $m$ increases the amount we're
              dividing by in the fraction $\frac{1}{a_2+m+...}$,
              decreasing it and $a_1+\frac{1}{a_2+m+...}$,
              which in turn increases $\frac{1}{a_1+\frac{1}{a_2+m+...}}$.
              And if we add it deeper, the pattern repeats -
              every layer deeper we move, this same pattern
              happens, and adding something to the coefficient
              has the same alternating effect.
            </quiz-answer>
            <br/><br/>
          </div>

          <div class="quiz-answer"></div>
        </span>


        <span>
          <!-- 6b -->
          <h2>Proving we have Approximants (cont.)</h2>

          Remainder mode replaces a term in the continued
          fraction with a remainder $r$ which you can
          edit to move between $0$ and $\infty$.
          <br/><br/>

          <div class="questions">
            <b>Q2)</b> What's special about the value of the
            continued fraction at $r=0$ and $r=\infty$?
            <quiz-answer>
              Consider:
              $$F_2(r)=a_0+\frac{1}{a_1+\frac{1}{a_2+r}}$$
              When $r=0$, this just gives us
              the second convergent fraction,
              $F_2$. However, when $r \rightarrow \infty$,
              $a_2+r \rightarrow \infty$, meaning that
              $\frac{1}{a_2+r} \rightarrow 0$, leaving us with
              $F_2(\infty) \rightarrow a_0+\frac{1}{a_1+0}=F_1$.
              <br/><br/>
              In other words, increasing $r$ sweeps out all
              gradients between the two approximants.
            </quiz-answer>
            <br/><br/>
          </div>

          When developing this, we had to choose a scaling
          for the slider for $r$, over these next two questions,
          consider why we picked the distribution of points we did.
          <br/><br/>

          <div class="questions">
            <b>Q3)</b> Does the resulting gradient for any other
            $r$ ever have a simpler fractional form (i.e. first
            hitting a point closer to the origin than those
            for $r=0$ and $r=\infty$)?
            <quiz-answer>
              Values of $r$ aside from $0$ and $\infty$ can
              <i>never</i> result in a simpler form.
              If $r$ has a fractional part, it simply adds
              extra depth to the continued fraction,
              forcing us to expand more terms, increasing
              complexity. If $r$ is, instead, a positive
              integer, increasing it increases the very
              first term we multiply up, increasing the first
              denominator and all which follow. No matter
              what we pick, the resulting fraction is
              more complicated.
            </quiz-answer>
            <br/><br/>

            <b>Q4)</b> As we move the remainder between $0$ and $\infty$,
            what changes occur in the structure (as usual,
            deduced from the first period) of the
            approximant we added the remainder to?
            <quiz-answer>
              As the slider is moved from $0$ to $\infty$,
              it never passes through a point between the
              two approximants aside from points corresponding
              to the approximants themselves, meaning the <i>only</i>
              change is the instant we decrease from $\infty$
              (in general, depending on the order of approximant
              at which we dropped in the remainder, we might
              instead get a change when we hit the point $r=0$).
            </quiz-answer>
            <br/><br/>
          </div>

          <div class="quiz-answer"></div>
        </span>


        <span>
          <!-- 7 -->
          <h2>Periodicity and Continued Fraction Coefficients</h2>

          <div class="questions">
            <b>Q1)</b> As we hop from approximant to approximant,
            how can we work out the structure of the next
            approximant from the previous, as well as from
            the continued fraction?
            <quiz-answer>
              We've already discussed this a bit, but now we
              have convergents available on which to base our
              approximants, we can be a little more specific.
              Most points don't shift as we move from approximant
              $(q_1,p_1)$ to approximant $(q_2,p_2)$, aside from points
              corresponding to one or other of the approximants
              (either $(q_2,p_2)$, itself, or $(nq_1,np_1)$, for integer $n$
              such that $nq_1 \lt q_2$, as we found previously). Aside
              from these points (which we'll cover later), the
              structure of the next approximant is given by
              repeating the previous structure a certain number
              of times:
              $$W_{n+1} \approx \textrm{repeat} \; W_n \; \textrm{for} \; L_{n+1} \; \textrm{letters}$$
              These approximant points are very significant
              in the early iterations, if you check this for
              yourself, but once the length of the word starts
              getting larger, they become less and less significant.
              In terms of scale, since the length of $W_n$ only
              ever increases with $n$, which means that deeper
              coefficients control the maximum power (number
              of consecutive repetitions) of subsequences at
              ever larger scales.
            </quiz-answer>
            <br/><br/>

            <b>Q2)</b> Thinking about your answer to the
            previous question, how do the coefficients of a
            continued fraction relate to the number of times
            we find repetitions of different lengths?
            <quiz-answer>
              When we create $W_{n+1}$, the previous word ($W_n$)
              will repeat $a_{n+1}$ times, before being cut-off
              part way through the next repetition, meaning
              that $W_n$ will repeat $a_{n+1}$ times consecutively.
              In fact, it turns out it can actually repeat
              more than this, but only twice more at most,
              corresponding to getting lucky with the
              structures which end up surrounding it on
              both sides, which, although they do break
              off the periodicity, may allow a single
              additional repetition on each side. For
              intuition, I'd suggest messing around with:
              $$W_{n+1}=W_nW_{n-1}$$
              $$W_0=\textrm{LS}$$
              $$W_1=\textrm{LSL}$$
              where you can find that LSL will be repeated at
              most 3 times, for the same reason as above.
              We'll find out later that this particular example
              is actually equivalent to a quasicrystal
              with a gradient of <s-g x="p">$\phi^{-1}$</s-g>.
            </quiz-answer>
            <br/><br/>

            <b>Q3)</b> Aperiodicity requires that no part
            of a structure, on any scale, repeats an arbitrarily
            large number of times. Why does this make the
            structure generated by
            <s-g x="p">$\phi^{-1}$</s-g> aperiodic? The continued
            fraction for <s-g x="e2">$\frac{e-2}{3-e}$</s-g> is given by
            $$\frac{e-2}{3-e}=2+\frac{1}{1+\frac{1}{1+\frac{1}{4+\frac{1}{1+\frac{1}{1+\frac{1}{6+...}}}}}}$$
            Is the structure generated by $e$ aperiodic?
            <quiz-answer>
              <s-g x="p">$\phi^{-1}$</s-g> is nice and aperiodic - its
              continued fraction contains only coefficients
              of 1, meaning that at most we can ever find
              3 consecutive repetitions of any part of it.
              The fact that it has such an upper bound
              means that we've found a quasicrystal (it
              happens to be a hugely relevant quasicrystal,
              too, central to patterns in the Penrose tiling).
              <br/><br/>
              <s-g x="e2">$\frac{e-2}{3-e}$</s-g>
              is not aperiodic, since it
              has arbitrarily large coefficients. Hence,
              whatever upper bound someone proposes for
              consecutive repetitions, by looking down the
              continued fraction, I can find a coefficient
              larger than that, corresponding to more consecutive
              repetitions. As a result, there's no upper bound
              on the number of repetitions in the structure of
              <s-g x="e2">$\frac{e-2}{3-e}$</s-g>,
              meaning its resulting structure
              isn't aperiodic.
            </quiz-answer>
            <br/><br/>

            <b>Q4)</b> Why might it sometimes be useful to view
            rational numbers as having a continued fraction
            truncated by a coefficient of $\infty$ (see below)?
            $$3+\frac{1}{7+\frac{1}{7+\frac{1}{\infty+...}}}=3.14$$
            <quiz-answer>
              It doesn't matter what follows the $\infty$
              (as long as it's positive or finite, anyway,
              which it will be for all continued fractions),
              since $\frac{1}{\infty+x}$ is definitely $0$. The reason this
              might be intuitively <i>useful</i> is that periodicity
              at particular scales is determined by continued
              fraction coefficient. A coefficient of $\infty$ for
              rational numbers makes it clear they repeat an
              infinite number of consecutive times by the same
              rules we use to judge maximum consecutive
              repetitions for irrational gradients.
            </quiz-answer>
            <br/><br/>
          </div>

          <div class="quiz-answer"></div>
        </span>


        <span>
          <!-- 8 -->
          <h2>Point Flipping</h2>

          We've seen a few times now that,
          as we slowly change gradient from one approximant to
          the next, the points
          corresponding to approximants will experience
          a flip (say from up-then-right (SL) to
          right-then-up (LS)).
          <br/><br/>

          <div class="questions">
            <b>Q1)</b> What happens to these points when
            we move along by two approximants? (If you
            have been keeping track of what rounding up,
            rather than down, when generating a continued
            fraction, does, then think how this might
            relate to that).
            <quiz-answer>
              As we move from, say,
              <s-g x="0.666666666666666">$\frac{2}{3}$</s-g> to
              <s-g x="0.6">$\frac{3}{5}$</s-g> in the
              convergents of <s-g x="p">$\phi^{-1}$</s-g>, we notice all the
              structure of <s-g x="0.666666666666666">$\frac{2}{3}$</s-g>
              is retained perfectly,
              aside from a single letter change corresponding
              to us hitting <s-g x="0.6">$\frac{3}{5}$</s-g>.
              However, the second we
              move back up from <s-g x="0.6">$\frac{3}{5}$</s-g>
              to start moving towards
              <s-g x="0.625">$\frac{5}{8}$</s-g>, that point
              gets crossed again, this
              time in the other direction. Intuitively,
              we could imagine that, rather than hitting
              <s-g x="0.6">$\frac{3}{5}$</s-g>, we merely skim
              close to it, before
              returning back, never quite touching it. As
              a result, flipping points corresponding to
              the approximants of <s-g x="0.6">$\frac{3}{5}$</s-g>
              never actually make a
              difference. And the same will be true of
              any point: since we always return closer to
              <s-g x="p">$\phi^{-1}$</s-g> afterwards,
              meaning that the largest
              number of points we could ever be dealing
              with is simply $a_{n+1}$, the number of points
              equivalent to our current convergent before
              the next. As we find larger and larger
              structures, these at most $a_{n+1}$ points
              make up less and less of our overall
              structure, meaning we can, hope to be able
              to ignore it. (To be more precise, the
              first point where occurs tends towards
              being infinitely far away for irrational
              numbers).
            </quiz-answer>
            <br/><br/>

            <b>Q2)</b> Argue why, when we repeat this process
            many times, the number of points remaining affected
            should be bounded for quasicrystals, and that
            thus we should, roughly, find every other
            structure to be <i>increasingly</i> similar to:
            $$W_{n+1} = \textrm{repeat} \; W_n \; \textrm{for} \; L_{n+1} \; \textrm{letters}$$
            <quiz-answer>
              Following on from the previous question, we simply
              repeat the previous structure $W_n$ until we reach
              the end of the first period of the next
              structure, which is at $L_{n+1}$.
              $$W_{n+1} = \textrm{repeat} \; W_n \; \textrm{for} \; L_{n+1} \; \textrm{letters}$$
              The only difficulty arises from, as we've seen a
              few times now, points corresponding to either the
              current or previous convergent. Fortunately, we
              just showed that the problems due to these points
              don't accumulate, and so we only need to worry
              about points corresponding to either this or the
              previous convergent - in quasicrystals, the
              distance between these two (and hence the number
              of points corresponding to the simpler approximant)
              is bounded, and so the proportion of such points
              is $0$ as we tend to $\infty$.
            </quiz-answer>
            <br/><br/>

            <b>Q3)</b> Given $L_{n+1}=a_{n+1}L_n+L_{n-1}$,
            this corresponds to:
            $$W_{n+1} = W_n^{a_{n+1}} \; (\textrm{truncate} \; W_n \; \textrm{after} \; L_{n-1} \; \textrm{letters})$$
            Why does this then give:
            $$W_{n+1} = W_n^{a_{n+1}}W_{n-1}$$
            <quiz-answer>
              For this final step, note that, since:
              $$W_{n+1} = W_n^{a_{n+1}} \; (\textrm{truncate} \; W_n \; \textrm{after} \; L_{n-1} \; \textrm{letters})$$
              then (just using $n-1$):
              $$W_n = W_n^{a_n} \; (\textrm{truncate} \; W_{n-1} \; \textrm{after} \; L_{n-2} \; \textrm{letters})$$
              Substituting one into the other:
              $$W_{n+1} = W_n^{a_{n+1}} \; (\textrm{truncate} \; (W_n^{a_n} \; (\textrm{truncate} \; W_{n-1} \; \textrm{after} \; L_{n-2} \; \textrm{letters})) \; \textrm{after} \; L_{n-1} \; \textrm{letters})$$
              This might not look much better, until we
              note that we're truncating something which
              begins with $W_{n-1}$ after $L_{n-1}$ letters. That's
              exactly the length of $W_{n-1}$, and hence that
              whole truncation just gives $W_{n-1}$:
              $$W_{n+1} = W_n^{a_{n+1}}W_{n-1}$$
            </quiz-answer>
            <br/><br/>

            <b>Q4)</b> In the case of
            <s-g x="p">$\phi^{-1}$</s-g>, why might the
            resulting lattice be called the 'Fibonacci lattice'?
            <quiz-answer>
              For <s-g x="p">$\phi^{-1}$</s-g>,
              after the initial $a_0=0$, all
              $a_n$ are equal to 1, meaning that we have:
              $$W_{n+1} = W_nW_{n-1}$$
              or, in other words, the next word is the
              concatenation of the previous two, just as,
              for the Fibonacci numbers, the next number
              is the <i>sum</i> of the previous two (this also
              means the length is always a Fibonacci number).
            </quiz-answer>
            <br/><br/>
          </div>

          <div class="quiz-answer"></div>
        </span>


        <div class="blog-youtube">
          <youtube-embed src="c0hJkdQ_ilM" size="big"></youtube-embed>
        </div>


        <div class="blog-youtube">
          <youtube-embed src="qjJlJe3Z6EM" size="big"></youtube-embed>
        </div>


      </slide-show>
    </div>
    <div id="middle" class="hidden">
      <canvas id="view" width="800" height="800"></canvas>
      <canvas id="crystal_view" width="800" height="40" class="hidden"></canvas>
    </div>
    <div id="right" class="hidden">
      Gradient: <input type="text" id="in_grad"/>
      <input type="range" id="ins_grad" min="0" max="1" step="0.001"/><br/>
      Offset: <input type="text" id="in_off"/>
      <input type="range" id="ins_off" min="0" max="0.999" step="0.001"/><br/>
      <br/>
      Sequence:<br/>
      <div id="word"></div>
      <br/>
      Continued Fraction:<br/>
      <div class="frac-row">
        <div id="cont_frac"></div>
        <div id="approx_equal"></div>
        <div id="approx_frac"></div>
      </div>
      <div id="coeff_slider_wrap" class="hidden">
        <input type="range" id="coeff_slider" min="1" max="30" step="1"/><br/>
      </div>
      <div id="z_slider_wrap" class="hidden">
        r:
        <input type="range" id="z_slider" min="0" max="1" step="0.01"
            value="0"/><br/>
      </div>
      <br/>
      <div class="flag">
        <input type="checkbox" id="flag_advanced"/>
        <span>Advanced options</span>
      </div>
      <div id="advanced_options" class="hidden">
      </div>
    </div>
  </div>
</div>
</body>
</html>
