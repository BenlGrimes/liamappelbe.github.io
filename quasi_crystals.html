<!DOCTYPE html>
<html>
<head>
<title>Quasicrystals</title>
<link rel="icon" href="res/favicon.ico">
<script src="slide_show.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script>
MathJax = {
  tex: {inlineMath: [['$', '$']]}
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>
<script type="text/javascript">

// Config
const mainViewSize = 10;
const mainViewZoomRate = 1.1;
const mainDotInitSize = 0.03;
const mainLineSize = 1;
const cellViewSize = 1;
const cellDotSize = 0.01;
const cellLineSize = 2;
const cellRayLength = 4;
const contFracTerms = 10;  // Max is around 30 before float errors.
const visibleContFracTerms = 6;
const zModeContFracTerms = 4;
const epsilon = 1e-6;
const alwaysRedraw = false;
const maxSeqLength = 1000;  // Way more than what we display.
const genSeqLength = 100;
const timeBetweenDomUpdatesMs = 100;

const tau = 2 * Math.PI;

function randInt(n) {
  return Math.floor(n * Math.random());
}

function fmod(x, y = 1) {
  const z = x / y;
  return (z - Math.floor(z)) * y;
}

function clamp(x, lo = 0, hi = 1) {
  return Math.max(Math.min(x, hi), lo);
}

function squish(x) {
  return (1 - Math.cos(x * Math.PI)) / 4 + x / 2;
}

function squishy(x, n) {
  for (let i = 0; i < n; ++i) x = squish(x);
  return x;
}

function isInt(x) {
  return Math.floor(x) == x;
}

function validate(x, condition) {
  if (condition(x)) return x;
  return null;
}

function unit(x, y) {
  const d = Math.sqrt(x * x + y * y);
  if (d == 0) return [0, 0];
  return [x / d, y / d];
}

function popSwap(a, i) {
  const x = a[i];
  const y = a.pop();
  if (i < a.length) a[i] = y;
  return x;
}

function getContFracTerms(x, maxTerms) {
  const terms = [];
  for (let i = 0; i < maxTerms; ++i) {
    const c = Math.floor(x);
    terms.push(c);
    const r = x - c;
    if (r < epsilon) {
      if (c == 1 && terms.length > 1) {
        terms.pop();
        terms[terms.length - 1] += 1;
      }
      break;
    }
    x = 1 / r;
  }
  return terms;
}

function getContFracTermsWithTargCoeff(x, maxTerms, targCoeff) {
  const terms = getContFracTerms(x, maxTerms);
  // targCoeff is not allowed to target a term that doesn't exist, unless it's
  // the very next term after the end of the terms array and the last element is
  // greater than 1. In that case we steal a 1/1 from that last term. Otherwise
  // we cap the targetCoeff.
  if (targCoeff > terms.length) {
    targCoeff = terms.length;
  }
  if (targCoeff == terms.length) {
    if (terms[terms.length - 1] > 1) {
      terms[terms.length - 1] -= 1;
      terms.push(1);
    } else {
      targCoeff = terms.length - 1;
    }
  }
  return [terms, targCoeff];
}

function getApproxFrac(terms, maxTerms, zn = 0, zd = 1) {
  const first = Math.min(terms.length, maxTerms) - 1;
  const frac = [zd, zn];
  for (let i = first; i >= 0; --i) {
    const y = frac[0];
    frac[0] = terms[i] * y + frac[1];
    frac[1] = y;
  }
  return frac;
}

function getContFracValue(terms) {
  let x = Infinity;
  for (let i = terms.length - 1; i >= 0; --i) {
    x = terms[i] + 1 / x;
  }
  return x;
}

function repeatStr(s, n, max) {
  let t = '';
  while (n > 0) {
    if (n & 1) t += s;
    s += s;
    n >>>= 1;
    if (t.length >= max) break;
  }
  return t;
}

function wordFromContFracTerms(terms) {
  let w = '';
  let w1 = 'S';
  let w2 = 'L';
  for (let i = 0; i < terms.length; ++i) {
    const wr = repeatStr(w1, terms[i], maxSeqLength);
    w = (i % 2 == 0) ? wr + w2 : w2 + wr;
    if (w.length >= maxSeqLength) return w.substr(0, maxSeqLength);
    w2 = w1;
    w1 = w;
  }
  return w;
}

function sequenceFromGrad(x, o, len) {
  let m = o;
  let n = 1;
  const a = [];
  for (let i = 0; i < len; ++i) {
    if (n * x > m) {
      ++m;
      a.push(true);
    } else {
      ++n;
      a.push(false);
    }
  }
  return a;
}

class RateLimiter {
  constructor() {
    this.lastRun = null;
    this.timeout = null;
  }

  run(delayMs, task) {
    const t = performance.now();

    // If it's been more than delayMs since our last task, run immediately.
    if (this.lastRun == null || (this.lastRun + delayMs) < t) {
      this.lastRun = t;
      task();
      return;
    }

    // We're about to set a new timeout, so cancel any existing timeouts.
    if (this.timeout != null) {
      window.clearTimeout(this.timeout);
    }

    // Set a timeout that delays the task by the extra wait time.
    const dt = this.lastRun + delayMs - t;
    this.timeout = window.setTimeout(() => {
      this.lastRun = performance.now();
      task();
    }, dt);
  }
}

function safeGet(node, defaultValue, isValid = (x => true)) {
  const value = parseFloat(node.value);
  if (isNaN(value) || !isValid(value)) return defaultValue;
  return value;
}

function newElement(type, parent, classes = [], text = null) {
  const n = document.createElement(type);
  if (text != null) n.innerText = text;
  for (const cls of classes) n.classList.add(cls);
  if (parent != null) parent.appendChild(n);
  return n;
}

function newDiv(parent, classes = [], text = null) {
  return newElement('div', parent, classes, text);
}

function emptyDiv(n) {
  while (n.hasChildNodes()) n.removeChild(n.lastChild);
}

function findCousinDivWithClass(n, className) {
  while (n != null) {
    for (const c of n.childNodes) {
      if (c.classList != null && c.classList.contains(className)) {
        return c;
      }
    }
    n = n.parentElement;
  }
  return null;
}

function runUnitTests() {
  let anyFails = false;
  const testWord = (terms, expectedWord) => {
    const word = wordFromContFracTerms(terms);
    if (word != expectedWord) {
      console.error(`wordFromContFracTerms([${terms}]) produced ${word} instead of ${expectedWord}`);
      anyFails = true;
    }
  };

  testWord([], '');
  testWord([1], 'SL');
  testWord([1, 1], 'SSL');
  testWord([1, 1, 1], 'SSLSL');
  testWord([1, 1, 1, 1], 'SSLSSLSL');
  testWord([1, 1, 1, 1, 1], 'SSLSSLSLSSLSL');
  testWord([1, 1, 1, 1, 1, 1], 'SSLSSLSLSSLSSLSLSSLSL');
  testWord([1, 6, 2, 3, 1, 2], 'SSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSLSSLSLSLSLSLSLSSLSLSLSLSLSLSL');
  testWord([0, 2, 2], 'SLLSLLL');

  const testContFrac = (x) => {
    const y = getContFracValue(getContFracTerms(x, 100));
    if (Math.abs(x - y) > 1e-12) {
      console.error(`getContFracValue(getContFracTerms(${x}, 100)) produced ${y} instead of ${x}`);
      anyFails = true;
    }
  };

  for (let i = 0; i < 1000; ++i) {
    testContFrac(10 * Math.random());
    testContFrac(randInt(10000) / (randInt(10000) + 1));
  }

  if (!anyFails) {
    console.log('All tests passed :)');
  }
}

function getRayCellCrossingsDist(gx, ox, len) {
  if (gx == 0) return null;
  const k = (1 - ox) / gx;
  if (k >= len) return null
  return k;
}

function getRayCellCrossings(gx, gy, ox, oy, len) {
  let d = 0;
  let x = ox;
  let y = oy;
  const a = [];
  for (let i = 0; i < 100; ++i) {
    const l = len - d;
    const kx = getRayCellCrossingsDist(gx, x, l);
    const ky = getRayCellCrossingsDist(gy, y, l);
    const stop = kx == null && ky == null;

    let k = 0;
    let px = null;
    let py = null;
    let nx = null;
    let ny = null;
    if (stop) {
      k = l;
    } else if (ky == null || (kx != null && kx < ky)) {
      k = kx;
      px = 1;
      nx = 0;
    } else {
      k = ky;
      py = 1;
      ny = 0;
    }
    if (ny == null) ny = py = y + k * gy;
    if (nx == null) nx = px = x + k * gx;

    const nd = d + k;
    a.push([x, y, d / len, px, py, nd / len]);
    x = nx;
    y = ny;
    d = nd;

    if (stop) break;
  }
  return a;
}

function closestPointToLine(px, py, ox, oy, dx, dy) {
  // q = o + kd
  // (q - o) . (p - q) = 0
  // kd . (p - o - kd) = 0
  // d . (p - o - kd) = 0
  // d . (p - o) - k(d . d) = 0
  // d . (p - o) = k(d . d)
  // d . (p - o) = k  // d is a unit vector
  const k = dx * (px - ox) + dy * (py - oy);
  return [ox + k * dx, oy + k * dy];
}

function setupCanvas(canvas, viewWidth, lineWidthMul = 1) {
  const ctx = canvas.getContext('2d');
  ctx.setTransform(
      canvas.width / viewWidth, 0,
      0, -canvas.width / viewWidth,
      0, canvas.height);
  ctx.lineWidth = lineWidthMul * viewWidth / canvas.width;
  return ctx;
}

function onLoad() {
  runUnitTests();

  let forceRedraw = true;
  const onFrameCallbacks = [];
  const domUpdateLimiter = new RateLimiter();

  const allLiveValues = new Map();
  const liveValue = (id, nodeIds, init = 0, validate = x => x, onchange = () => {}) => {
    // Does a few things:
    // - Maintains the invariant that each dom element has the same value.
    // - Whenever the value changes, sets forceRedraw to true.
    // - Uses validate to sanitize, a function from float to nullable float.
    // - Returns an object with a value field that is kept up to date.
    // - Changes to that field are also reflected on the elements.
    const elements = nodeIds.map(id => document.getElementById(id));
    const oldValues = [];  // One for each element, and one for obj.value.
    for (const e of elements) {
      e.value = init;
      oldValues.push(e.value);
    }
    const obj = { value: init, reset: null };
    obj.reset = () => obj.value = init;
    oldValues.push(obj.value);
    onFrameCallbacks.push(() => {
      let anyChange = obj.value != oldValues[elements.length];
      let cause = null;
      if (!anyChange) {
        for (let i = 0; i < elements.length; ++i) {
          const e = elements[i];
          if (e.value != oldValues[i]) {
            const px = parseFloat(e.value);
            const x = isNaN(px) ? null : validate(px);
            if (x != null) {
              anyChange = true;
              obj.value = x;
              cause = i;
              break;
            }
          }
        }
      }
      if (anyChange) {
        forceRedraw = true;
        oldValues[elements.length] = obj.value;
        for (let i = 0; i < elements.length; ++i) {
          const e = elements[i];
          if (i != cause) {
            e.value = obj.value;
          }
          oldValues[i] = e.value;
        }
        onchange();
      }
    });
    allLiveValues.set(id, obj);
    return obj;
  };

  const domAdvancedOptions = document.getElementById('advanced_options');
  const domFlagAdvanced = document.getElementById('flag_advanced');
  domFlagAdvanced.addEventListener('change', () => {
    if (domFlagAdvanced.checked) {
      domAdvancedOptions.classList.remove('hidden');
    } else {
      domAdvancedOptions.classList.add('hidden');
    }
  });

  const allFlags = new Map();
  const makeFlag = (id, name, initValue = false, onChange = () => {}) => {
    const flag = { value: initValue, setValue: null };
    const div = newDiv(domAdvancedOptions, ['flag']);
    const check = newElement('input', div);
    check.setAttribute('type', 'checkbox');
    if (initValue) check.setAttribute('checked', true);
    flag.setValue = value => {
      if (value) {
        check.setAttribute('checked', true);
      } else {
        check.removeAttribute('checked');
      }
      forceRedraw = true;
      flag.value = value;
      onChange();
    };
    check.addEventListener('change', () => flag.setValue(check.checked));
    const label = newElement('span', div, [], name);
    allFlags.set(id, flag);
    return flag;
  };

  let targKeep = false;
  let targX = null;
  let targY = null;
  const grad = liveValue('grad', ['in_grad', 'ins_grad'], 0.618033988749894,
      x => x >= 0 ? x : 0, () => {
    if (targKeep) {
      targKeep = false;
    } else {
      targX = null;
      targY = null;
    }
  });
  const off = liveValue('off', ['in_off', 'ins_off'], 0, x => fmod(x), () => {
    targX = null;
    targY = null;
  });
  let targCoeff = 0;
  const coeffterm = liveValue('coeff', ['coeff_slider'], 1, x => Math.floor(x),
      () => {
    const [terms, targCoeff_] = getContFracTermsWithTargCoeff(
        grad.value, contFracTerms, targCoeff);
    targCoeff = targCoeff_;
    const x = coeffterm.value;
    if (x == terms[targCoeff]) return;
    const terms_ = terms.slice(0);
    terms_[targCoeff] = x;
    grad.value = getContFracValue(terms_);
  });
  const rawzterm = liveValue('rawz', ['z_slider'], 0, x => clamp(x, 0, 1));

  const flagShowConvergents = makeFlag('aprx', 'Show approximants');
  const flagShowSteps = makeFlag('step', 'Show steps');
  const flagShowCrystal = makeFlag('crys', 'Show crystal');
  const flagUnitCellMode = makeFlag('unit', 'Unit cell mode');
  const flagShowZ = makeFlag('rem', 'Editable remainder');
  const flagContFracEdit = makeFlag('cont', 'Editable continued fraction');
  const flagSimpleFracEdit = makeFlag('simp', 'Editable simple fraction');

  const isInZMode = () => (
      flagShowZ.value && !flagContFracEdit.value && !flagSimpleFracEdit.value &&
      !flagUnitCellMode.value);
  const isInSimpleFracEditMode = () =>
      flagSimpleFracEdit.value && !flagContFracEdit.value;
  const getVisibleContFracTerms = () =>
      isInZMode() ? zModeContFracTerms : visibleContFracTerms;
  const getApproxContFracTerms = () =>
      isInZMode() ? zModeContFracTerms : visibleContFracTerms + 1;

  const canvas = document.getElementById('view');
  const crystalCanvas = document.getElementById('crystal_view');
  const domContFrac = document.getElementById('cont_frac');
  const domApproxEqual = document.getElementById('approx_equal');
  const domApproxFrac = document.getElementById('approx_frac');
  const domWord = document.getElementById('word');
  const domZSliderWrap = document.getElementById('z_slider_wrap');
  const domCoeffSliderWrap = document.getElementById('coeff_slider_wrap');

  const blogPageUpdater = [];
  const addBlogPage = (flags, liveValues) => {
    const flg = new Set(flags);
    const lvs = new Map(liveValues);
    blogPageUpdater.push(() => {
      for (const [id, flag] of allFlags.entries()) {
        flag.setValue(flg.has(id));
      }
      for (const [id, lv] of allLiveValues.entries()) {
        if (lvs.has(id)) {
          lv.value = lvs.get(id);
        } else {
          lv.reset();
        }
      }
    });
  };

  addBlogPage(['crys', 'step']);
  addBlogPage(['crys', 'step']);
  addBlogPage(['crys', 'step', 'aprx']);
  addBlogPage(['crys', 'step', 'aprx']);

  const showBlog = index => blogPageUpdater[index]();
  document.getElementById('blog').addEventListener(
      'change', e => showBlog(e.detail));
  showBlog(0);

  const getZ = () => {
    const x = isInZMode() ? rawzterm.value : 0;
    if (x == 0) return [0, 1];
    if (x == 1) return [1, 0];
    if (x == 0.5) return [1, 1];
    const y = squishy(x, 4);
    const z = (1 / (1 - y)) - 1;
    return x < 0.5 ? [1, Math.floor(1 / z)] : [Math.floor(z), 1];
  };

  const fillContFracDom = (terms, zn, zd) => {
    const visibleTerms = getVisibleContFracTerms();
    emptyDiv(domContFrac);
    let n = terms.length;
    const trunc = n > visibleTerms;
    if (trunc) n = visibleTerms;
    --n;
    let node = domContFrac;
    const termDivs = [];

    const addTerm = (i, suffix, cls) => {
      const termWrap = newDiv(node, [cls]);
      const term = newDiv(termWrap, [], terms[i]);
      if (flagContFracEdit.value) {
        termWrap.classList.add('cont-frac-term-wrap');
        term.classList.add('cont-frac-term-clickable');
        if (targCoeff == i) {
          termWrap.classList.add('selected');
        }
        term.addEventListener('click', () => {
          for (const t of termDivs) {
            t.classList.remove('selected');
          }
          termWrap.classList.add('selected');
          targCoeff = i;
          coeffterm.value = terms[i];
        });
        newDiv(termWrap, ['cont-frac-term-line']);
      }
      termDivs.push(termWrap);
      if (suffix != '') newDiv(node, [cls], suffix);
    };

    for (let i = 0; i < n; ++i) {
      if (flagContFracEdit.value || !(i == 0 && terms[i] == 0)) {
        addTerm(i, ' + ', 'cont-frac-term');
      }
      const frac = newDiv(node, ['cont-frac-frac']);
      newDiv(frac, ['cont-frac-num'], '1');
      node = newDiv(frac, ['cont-frac-den']);
    }

    if (flagContFracEdit.value) {
      domCoeffSliderWrap.classList.remove('hidden');
    } else {
      domCoeffSliderWrap.classList.add('hidden');
    }

    if (isInZMode()) {
      domZSliderWrap.classList.remove('hidden');
      const haszd = zd > 1;
      addTerm(n, ' + ', haszd ? 'cont-frac-term' : 'cont-frac-term-end');
      const frac = newDiv(node, ['cont-frac-frac']);
      newDiv(frac, ['cont-frac-num'], zd == 0 ? '∞' : zn);
      if (haszd) newDiv(frac, ['cont-frac-den'], zd);
    } else {
      addTerm(n, trunc ? ' + ...' : '', 'cont-frac-term-end');
      domZSliderWrap.classList.add('hidden');
    }
  }

  const fillApproxFracDom = (terms, zn, zd) => {
    const [n, d] = getApproxFrac(terms, getApproxContFracTerms(), zn, zd);
    emptyDiv(domApproxFrac);
    if (isInSimpleFracEditMode()) {
      const makeText = (cls, val, minVal, onChange) => {
        const inp = newElement('input', domApproxFrac, ['approx-frac-edit']);
        inp.value = val;
        inp.addEventListener('change', () => {
          const val = validate(parseFloat(inp.value),
            x => isFinite(x) && isInt(x) && (x >= minVal));
          if (val != null) onChange(val);
        });
      };
      makeText(n, 0, x => grad.value = x / d);
      newDiv(domApproxFrac, ['approx-frac-edit-line']);
      makeText(d, 1, x => grad.value = n / x);
      domApproxEqual.innerText = '=';
    } else {
      newDiv(domApproxFrac, ['approx-frac-num'], n);
      if (d != 1) newDiv(domApproxFrac, ['approx-frac-den'], d);
      domApproxEqual.innerText =
          getApproxContFracTerms() < terms.length ? '≈' : '=';
    }
  }

  let mainViewZoomExp = 0;
  const getMainViewSize = () =>
      mainViewSize * Math.pow(mainViewZoomRate, mainViewZoomExp);

  const getViewSize = () =>
      flagUnitCellMode.value ? cellViewSize : getMainViewSize();

  const getClickPos = e => {
    const viewSize = getViewSize();
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.x;
    const my = e.clientY - rect.y;
    const x = viewSize * mx / canvas.width;
    const y = viewSize * (1 - my / canvas.height);
    return [x, y];
  };

  let mouseClicked = false;
  let currentGx = 1;
  let currentGy = 0;
  let currentOx = 0;
  let currentOy = 0;
  const anchors = [];
  const snapToAnchor = (x, y, alsoSnapToLine) => {
    const viewSize = getViewSize();
    let mx = null;
    let my = null;
    let mi = null;
    let md = Infinity;
    const maybeSnap = (px, py, pi, distmul = 1) => {
      if (px >= 0 && py >= 0 && px <= viewSize && py <= viewSize) {
        const dx = x - px;
        const dy = y - py;
        const dd = distmul * (dx * dx + dy * dy);
        if (dd < md) {
          mx = px;
          my = py;
          mi = pi;
          md = dd;
        }
      }
    };
    for (let i = 0; i < anchors.length; ++i) {
      const [px, py] = anchors[i];
      maybeSnap(px, py, i);
    }
    maybeSnap(Math.floor(x + 0.5), Math.floor(y + 0.5), null, 1.1);
    if (alsoSnapToLine) {
      const [lx, ly] = closestPointToLine(
          x, y, currentOx, currentOy, currentGx, currentGy);
      maybeSnap(lx, ly, null, 2);
    }
    if (md > 0.05) return null;
    return [mx, my, mi];
  };
  const onMouse = (e, click) => {
    e.preventDefault();
    let [x, y] = getClickPos(e);
    if (!click) {
      const snap = snapToAnchor(x, y, false);
      if (snap != null) {
        x = snap[0];
        y = snap[1];
      }
    }
    const y_ = y + off.value;
    if (x <= 0) {
      grad.value = 1e3;
    } else if (y_ <= 0) {
      grad.value = 0;
    } else {
      grad.value = y_ / x;
    }
    targX = x;
    targY = y;
    targKeep = true;
  };
  const onRightClick = e => {
    forceRedraw = true;
    let [x, y] = getClickPos(e);
    const snap = snapToAnchor(x, y, true);
    if (snap == null) {
      anchors.push([x, y]);
    } else if (snap[2] == null) {
      anchors.push([snap[0], snap[1]]);
    } else {
      popSwap(anchors, snap[2]);
    }
  };
  canvas.addEventListener('mousedown', e => {
    if (e.which == 1) {
      onMouse(e, mouseClicked = true);
    } else if (e.which == 3) {
      onRightClick(e);
    }
  });
  document.addEventListener('mousemove', e => {
    if (mouseClicked) onMouse(e, mouseClicked);
  });
  document.addEventListener('mouseup', e => {
    if (e.which == 1 && mouseClicked) onMouse(e, mouseClicked = false);
  });

  canvas.addEventListener('contextmenu', e => e.preventDefault());
  canvas.addEventListener('wheel', e => {
    e.preventDefault();
    forceRedraw = true;
    mainViewZoomExp = clamp(mainViewZoomExp + (0.01 * e.deltaY), -20, 10);
  });

  const circle = (cc, px, py, r, clr) => {
    cc.fillStyle = clr;
    cc.beginPath();
    cc.ellipse(px, py, r, r, 0, 0, tau);
    cc.fill();
  };

  const line = (cc, px, py, qx, qy, clr) => {
    cc.strokeStyle = clr;
    cc.beginPath();
    cc.moveTo(px, py);
    cc.lineTo(qx, qy);
    cc.stroke();
  };

  const ray = (cc, px, py, dx, dy, clr) => {
    const len = 2 * getMainViewSize();
    line(cc, px, py, px + len * dx, py + len * dy, clr);
  };

  const update = () => {
    for (const fn of onFrameCallbacks) fn();

    if (alwaysRedraw || forceRedraw) {
      forceRedraw = false;
      const viewSize = getViewSize();
      const mainDotSize =
          mainDotInitSize * Math.sqrt(getMainViewSize() / mainViewSize);
      const dotSize = flagUnitCellMode.value ? cellDotSize : mainDotSize;
      const lineSize = flagUnitCellMode.value ? cellLineSize : mainLineSize;
      const ctx = setupCanvas(canvas, viewSize, lineSize);

      const [zn, zd] = getZ();
      const zmode = isInZMode();
      const g = grad.value;
      const o = off.value;
      const gx = 1 / Math.sqrt(1 + g * g);
      const gy = gx * g;

      if (!flagContFracEdit.value) {
        targCoeff = 0;
      }

      const [terms, targCoeff_] = getContFracTermsWithTargCoeff(
          grad.value, contFracTerms, targCoeff);
      targCoeff = targCoeff_;
      const zray = (n, d) => {
        if (!zmode) return [[gy, gx], g];
        const [y, x] = getApproxFrac(terms, getApproxContFracTerms(), n, d);
        return [unit(y, x), y / x];
      };

      const [[ugy, ugx], zg] = zray(zn, zd);
      const [[ugy0, ugx0], zg0] = zray(0, 1);
      const [[ugy1, ugx1], zg1] = zray(1, 0);

      const hitRad = isFinite(zg) ? (1 + zg) / Math.sqrt(1 + zg * zg) : 1;
      const hitGx = ugy;
      const hitGy = -ugx;
      const hitSx = hitGx * hitRad;
      const hitSy = hitGy * hitRad;
      const hitOx = 0;
      const hitOy = -o;
      const sequence = sequenceFromGrad(zg, o, genSeqLength);

      currentGx = ugx;
      currentGy = ugy;
      currentOx = hitOx;
      currentOy = hitOy;

      // Clear to black.
      ctx.fillStyle = 'rgba(0, 0, 0, 1)';
      ctx.fillRect(-2 * viewSize, -2 * viewSize, 4 * viewSize, 4 * viewSize);

      // Draw dots.
      const dotClr = zmode ? 'rgba(34, 34, 34, 1)' : 'rgba(68, 68, 68, 1)';
      for (let i = 0; i <= viewSize; ++i) {
        for (let j = 0; j <= viewSize; ++j) {
          circle(ctx, i, j, dotSize, dotClr);
        }
      }

      // Draw kernel lines.
      const kernDraw = viewSize + 1;
      for (let i = -1; i <= kernDraw; ++i) {
        for (let j = -1; j <= kernDraw; ++j) {
          line(ctx, i, j, i + hitSx, j + hitSy, dotClr);
        }
      }

      // Draw anchors.
      for (const [x, y] of anchors) {
        circle(ctx, x, y, 2 * dotSize, 'rgba(156, 39, 176, 1)');
      }

      // Calculate ray hits.
      let px = 0;
      let py = 0;
      const hits = [];
      for (const goUp of sequence) {
        const x = px + (goUp ? 0 : 1);
        const y = py + (goUp ? 1 : 0);
        const k = ugx * (x - hitOx) + ugy * (y - hitOy);
        const ux = hitOx + k * ugx;
        const uy = hitOy + k * ugy;
        hits.push([px, py, x, y, ux, uy, k]);
        px = x;
        py = y;
      }

      if (!flagUnitCellMode.value) {  // Normal mode.
        // Draw rays.
        if (zmode) {
          ray(ctx, hitOx, hitOy, gx, gy, 'rgba(255, 255, 255, 0.5)');

          // Draw z, z=0, and z=inf lines, if in z mode.
          ray(ctx, hitOx, hitOy, ugx, ugy, `rgba(255, 255, 255, 1)`);
          ray(ctx, hitOx, hitOy, ugx0, ugy0, `rgba(255, 255, 255, 0.5)`);
          ray(ctx, hitOx, hitOy, ugx1, ugy1, `rgba(255, 255, 255, 0.5)`);
        } else {
          ray(ctx, hitOx, hitOy, gx, gy, 'rgba(255, 255, 255, 1)');
        }

        // Draw hit kernel lines.
        for (const [px, py, x, y, ux, uy, k] of hits) {
          line(ctx, x, y, ux, uy, 'rgba(0, 136, 255, 1)');
          circle(ctx, x, y, dotSize, 'rgba(0, 136, 255, 1)');
        }

        // Hilite the dots between the z rays, if in z mode.
        if (zmode) {
          for (let i = 0; i <= viewSize; ++i) {
            for (let j = 0; j <= viewSize; ++j) {
              const k = (j - hitOy) / (i - hitOx);
              if (k >= zg1 && k <= zg0) {
                circle(ctx, i, j, dotSize, 'rgba(170, 170, 170, 1)');
              }
            }
          }
        }

        // Draw hit dots.
        for (const [px, py, x, y, ux, uy, k] of hits) {
          circle(ctx, ux, uy, 2 * dotSize, 'rgba(255, 34, 0, 1)');
        }

        // Draw steps.
        if (flagShowSteps.value) {
          for (const [px, py, x, y, ux, uy, k] of hits) {
            line(ctx, px, py, x, y, 'rgba(0, 255, 0, 0.8)');
          }
        }

        // Draw approximants, if enabled.
        if (flagShowConvergents.value) {
          for (let i = 1; i <= terms.length; ++i) {
            const [y, x] = getApproxFrac(terms, i);
            circle(ctx, x, y, 2 * dotSize, 'rgba(255, 255, 0, 1)');
          }
        }
      } else {  // Unit cell mode.
        // Draw ray.
        const rcc = getRayCellCrossings(ugx, ugy, hitOx, hitOy, cellRayLength);
        for (const [ax, ay, ak, bx, by, bk] of rcc) {
          const grd = ctx.createLinearGradient(ax, ay, bx, by);
          grd.addColorStop(0, `rgba(255, 255, 0, ${1 - ak})`);
          grd.addColorStop(1, `rgba(255, 255, 0, ${1 - bk})`);
          line(ctx, ax, ay, bx, by, grd);
        }

        // Modulo all the ray hits into the unit cell.
        const modhits = [];
        for (const [px, py, x, y, ux, uy, k] of hits) {
          if (k > cellRayLength) break;
          const mux = fmod(ux);
          const muy = fmod(uy);
          const gux = x + mux - ux;
          const guy = y + muy - uy;
          const alpha = 1 - k / cellRayLength;
          modhits.push([mux, muy, gux, guy, alpha])
        }

        // Draw hit dots.
        for (const [mux, muy, gux, guy, alpha] of modhits) {
          circle(ctx, mux, muy, dotSize, `rgba(255, 34, 0, 1)`);
        }
      }

      // Draw target point, if it exists.
      if (targX != null && targY != null) {
        circle(ctx, targX, targY, 2 * dotSize, 'rgba(255, 255, 255, 1)');
      }

      domUpdateLimiter.run(timeBetweenDomUpdatesMs, () => {
        // Fill continued fraction and approx fraction.
        fillContFracDom(terms, zn, zd);
        fillApproxFracDom(terms, zn, zd);

        // Fill word.
        const word = sequence.map(x => x ? 'S' : 'L').join('');
        domWord.innerText = word;
      });

      // Draw the crystal, if enabled.
      if (flagShowCrystal.value) {
        const viewSize = getMainViewSize();
        const crystalCtx = setupCanvas(crystalCanvas, viewSize);
        crystalCanvas.classList.remove('hidden');
        crystalCtx.fillStyle = 'rgba(0, 0, 0, 1)';
        crystalCtx.fillRect(
          -2 * viewSize, -2 * viewSize, 4 * viewSize, 4 * viewSize);
        const midy = 0.025 * viewSize;
        line(crystalCtx, 0, midy, viewSize, midy, 'rgba(255, 255, 255, 1)');
        for (const [px, py, x, y, ux, uy, k] of hits) {
          circle(crystalCtx, k, midy, 2 * mainDotSize, 'rgba(255, 34, 0, 1)');
        }
      } else {
        crystalCanvas.classList.add('hidden');
      }
    }

    window.requestAnimationFrame(update);
  };
  update();
}
window.addEventListener('load', onLoad);

class YouTubeEmbed extends HTMLElement {
  constructor() {
    super();
    const iframe = newElement('iframe', this);
    iframe.setAttribute('width', 560);
    iframe.setAttribute('height', 315);
    iframe.setAttribute(
        'src', 'https://www.youtube.com/embed/' + this.getAttribute('src'));
    iframe.setAttribute('title', 'YouTube video player');
    iframe.setAttribute('frameborder', 0);
    iframe.setAttribute(
        'allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; ' +
            'gyroscope; picture-in-picture');
    iframe.setAttribute('allowfullscreen', '');
  }
}
window.addEventListener(
    'load', () => customElements.define('youtube-embed', YouTubeEmbed));

let shownQuizAnswer = null;
class QuizAnswer extends HTMLElement {
  constructor() {
    super();
    this.answerHTML = this.innerHTML;
    this.innerText = '[Discussion]';
    this.answerDiv = findCousinDivWithClass(this, 'quiz-answer');
    this.addEventListener('click', () => {
      if (shownQuizAnswer != this) {
        shownQuizAnswer = this;
        this.answerDiv.innerHTML = this.answerHTML;
        this.answerDiv.classList.add('shown');
      } else {
        shownQuizAnswer = null;
        this.answerDiv.innerHTML = '';
        this.answerDiv.classList.remove('shown');
      }
    });
  }
}
window.addEventListener(
    'load', () => customElements.define('quiz-answer', QuizAnswer));
</script>
<style>
html {
  min-height: 100%;
}
body {
  background-color: #212121;
  margin: 0;
  overflow-y: scroll;
}
#head {
  background-color: #424242;
  width: 100%;
  display: flex;
  justify-content: space-around;
  margin-bottom: 4px;
}
h1, #index {
  color: #ffc107;
  text-align: center;
  font-family: monospace;
  font-size: 42px;
  flex-grow: 1;
  padding: 16px;
  margin: 0;
}
#index {
  color: #ff5722;
  text-decoration: none;
  flex-grow: 0;
}
h2 {
  color: #ff5722;
  font-family: monospace;
}
a {
  color: #ffc107;
  font-family: monospace;
  font-size: 16px;
  cursor: pointer;
  text-decoration: underline;
}
#wrap {
  padding: 0 16px;
  color: #f5f5f5;
  font-family: monospace;
  font-size: 16px;
}
#layout {
  display: flex;
  flex-direction: row;
  width: 100%;
  gap: 16px;
}
#left {
  flex-grow: 1;
}
#middle {
  display: flex;
  flex-direction: column;
}
#right {
  display: flex;
  flex-direction: column;
  flex-shrink: 0;
  width: 350px;
}
#word {
  overflow: hidden;
  text-overflow: ellipsis;
  width: 330px;
}
.cont-frac-term {
  margin-top: 0.6em;
}
.cont-frac-term-end {
  margin-top: 0;
}
.cont-frac-frac {
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.cont-frac-num, .approx-frac-num {
  text-align: center;
}
#cont_frac, .cont-frac-den {
  display: flex;
  flex-direction: row;
  justify-content: center;
  gap: 4px;
}
.cont-frac-den, .approx-frac-den, .approx-frac-edit-line {
  border-top: 2px solid #f5f5f5;
  text-align: center;
}
.approx-frac-edit-line {
  margin: 4px;
}
.approx-frac-edit {
  max-width: 50px;
}
.cont-frac-term-wrap {
  display: flex;
  flex-direction: column;
  justify-content: top;
  align-items: center;
  min-height: 30px;
}
.cont-frac-term-clickable {
  cursor: pointer;
}
.cont-frac-term-clickable:hover {
  background-color: rgba(0, 128, 255, 0.5);
}
.selected .cont-frac-term-clickable {
  background-color: rgba(0, 128, 255, 1);
}
.cont-frac-term-line {
  display: none;
  background-color: rgba(0, 128, 255, 1);
  flex-grow: 1;
  width: 1px;
}
.selected .cont-frac-term-line {
  display: block;
}
.frac-row {
  display: flex;
  flex-direction: row;
  width: 100%;
  gap: 8px;
  justify-content: center;
  align-items: center;
  min-height: 140px;
}
#approx_equal {
  font-size: 32px;
}
#approx_frac {
  display: flex;
  flex-direction: column;
  justify-content: center;
}
#z_slider_wrap, #coeff_slider_wrap {
  display: flex;
  flex-direction: row;
  justify-content: center;
  gap: 4px;
}
#z_slider, #coeff_slider {
  flex-grow: 1;
}
.hidden {
  display: none !important;
}
#advanced_options {
  background-color: #FFF1;
}
.flag {
  display: flex;
  flex-direction: row;
  width: 100%;
  gap: 8px;
  justify-content: flex-start;
}
slide-show {
  display: none;
}
slide-show.loaded {
  display: flex;
  flex-direction: column-reverse;
  align-items: center;
  gap: 8px;
}
.slide-show-slide-row {
  width: 100%;
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  gap: 8px;
}
.slide-show-dot-row {
  width: 100%;
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
  gap: 8px;
}
.slide-show-dot {
  cursor: pointer;
  width: 8px;
  height: 8px;
  border-radius: 4px;
  background-color: #FFF2;
}
.slide-show-dot.active {
  background-color: #FFF;
}
.slide-show-button {
  cursor: pointer;
  user-select: none;
}
quiz-answer {
  cursor: pointer;
  color: #ff5722;
}
quiz-answer:hover {
  color: #ffc107;
}
b {
  color: #ffc107;
}
.questions {
  margin-left: 12px;
}
.quiz-answer {
  display: none;
  background-color: #ffffff11;
  padding: 8px;
  margin-bottom: 8px;
}
.quiz-answer.shown {
  display: block;
}
</style>
</head>
<body>
<div id="head">
  <a id="index" href="index.html">&lt;</a>
  <h1>Quasicrystals (Prototype)</h1>
</div>
<div id="wrap">
  <div id="layout">
    <div id="left">
      <slide-show id="blog" button-layout="low">
        <span>
          <h2>Rational Numbers and Periodic Crystals</h2>

          You can click and drag the slope of the line and watch the crystal
          structures (bottom) and sequences (right) which form based on this.
          Use the mouse wheel to zoom.
          <br/><br/>

          <div class="questions">
            <b>Q1)</b> Can you make a periodic structure?
            <quiz-answer>Try clicking on any of the grid points.</quiz-answer>
            <br/><br/>

            <b>Q2)</b> What sort of gradients give you periodic structures?
            <quiz-answer>
              Since the lattice is periodic, the view from any point on the
              lattice is the same as from any other. Hence, if a line leaves a
              point (i.e., the origin), and hits another point, then the view
              from the next point must be the same as that from the first point,
              meaning the structure repeats itself until we hit the next point,
              after which it repeats again, continuing indefinitely. Any line
              that hits a lattice point must move an integer number of steps up,
              and an integer number of steps along, meaning its gradient is of
              the form $p \over q$, where $(q,p)$ are the coordinates of the
              point we hit.
            </quiz-answer>
            <br/><br/>

            <b>Q3)</b> What determines how many atoms appear in your crystal
            before it begins to repeat.
            <quiz-answer>
              As for the number of atoms in between - if we look at the
              staircase representation, we can see the total number of atoms
              is given by the number of steps up, plus the number along,
              meaning there will always be $p+q$ atoms per repetition
              (or 'in the unit cell').
            </quiz-answer>
            <br/><br/>
          </div>

          If a line directly hits a lattice point, that fixes its gradient, so
          at least some gradients can be represented by just a point.
          <br/><br/>

          <div class="questions">
            <b>Q4)</b> Is this representation unique?
            <quiz-answer>
              The fraction $p \over q$, corresponding to hitting the point
              $(q,p)$, isn't unique - we could multiply top and bottom by
              an integer, and find another point the line hits
              ($np \over nq$ and $(nq,np)$). This is another
              way of showing the periodicity of this structure.
            </quiz-answer>
            <br/><br/>

            <b>Q5)</b> What additional requirement could you add to <i>make</i>
            it unique?
            <quiz-answer>
              If we want to find a <i>unique</i> point corresponding to any
              gradient, we can always simplify this fraction by cancelling all
              common factors between $p$ and $q$, corresponding to finding the
              first point we hit as we move out from the origin.
            </quiz-answer>
            <br/><br/>

            <b>Q6)</b> Do all possible gradients correspond to a point on the
            lattice?
            <quiz-answer>
              All this work <i>assumes</i> that we hit an atom in the first
              place. But what if we pick a gradient which <i>isn't</i>
              rational (meaning it's not a number which can be written
              $p \over q$, where $p$ and $q$ are integers - say like
              $\pi$, $\phi$, $\sqrt{2}$, or $\sqrt[7]{5}$)?
              Well, if the line ever <i>did</i> touch a point, that would
              mean it had a rational gradient - but we know it's an
              irrational number, so it never does. Hence, it only
              ever hits one atom (the one at the origin), and
              it never repeats. Hence, we've found a deterministic
              <i>non</i>-periodic structure. We haven't shown yet that it
              is aperiodic (i.e., that it doesn't ever have large runs
              of repeating words), which will be one of our major
              goals in investigating these.
            </quiz-answer>
            <br/><br/>
          </div>

          <div class="quiz-answer"></div>
        </span>


        <span>
          <h2>Offsets and Words</h2>

          Before we go further, let's take a look at how the offset slider
          affects the generated sequence.
          <br/><br/>

          <div class="questions">
            <b>Q1)</b> Can you spot the relationship between the pattern of
            atoms and the generated sequence of S's and L's?
            <quiz-answer>
              For gradients less than 1, we tend to label the atoms based
              on whether they correspond to short (S) or long (L) gaps.
              This corresponds to steps <i>up</i> on the staircase corresponding
              to the letter S, and steps <i>along</i> corresponding to the
              letter L.
            </quiz-answer>
            <br/><br/>

            <b>Q2)</b> Does this still hold if we increase the gradient past 45
            degrees?
            <quiz-answer>
              When the gradient is 1, this classification poses a
              problem - steps up and along are both the same length,
              and for gradients greater than 1, steps up are now
              the longer ones, and vice versa. In order to maintain
              some sense of continuity, however, we remain labelling
              steps up (such as the first point) with an S, even
              for gradients greater than 1. Practically, the exact
              spacing can be accounted for in other ways, and often
              isn't used, so the letters are mostly arbitrary.
              In other words, think of S as steps up, and L as steps
              along.
            </quiz-answer>
            <br/><br/>

            <b>Q3)</b> Can you spot any rough pattern between the length of
            runs of the same letter (known as its power), and the gradient?
            <quiz-answer>
              You might have also seen that the letter S will have
              a power of the gradient rounded either down or up.
              This turns out to generalise to the powers of more
              complicated structures, as we'll see later, and
              is part of how we'll prove aperiodicity.
            </quiz-answer>
            <br/><br/>
          </div>

          Since the structure of atoms is determined by this sequence of
          letters, this sequence is quite important, and sometimes
          referred to as the 'word' for a particular gradient.
          <br/><br/>

          <div class="questions">
            <b>Q4)</b> Pick a simple rational number for the gradient - say
            something like $1 \over 3$. By how much do you have to change
            the offset before atoms begin to jump?
            <quiz-answer>
              For a number of the form $p \over q$, we need to increase
              the offset to at least $1 \over q$ for the first hop to occur.
              For irrational numbers, the distance we have to move
              is infinitesimal. The graph of these distances is
              known as
              <a target="_blank" href="https://en.wikipedia.org/wiki/Thomae%27s_function">Thomae's function</a>,
              or the popcorn function. To a physicist's eye, this function
              is truly an abomination, it has the property that,
              despite being continuous almost everywhere, it's
              never continuous over any finite range (it's discontinuous
              at every rational number). It's a great example of
              why calculus and number theory tend to be so disjoint -
              good luck trying to write a differential equation
              which describes <i>this</i>!
            </quiz-answer>
            <br/><br/>

            <b>Q5)</b> Are atoms conserved as we change the offset?
            <quiz-answer>
              Atoms are, in fact, conserved (meaning this
              can happen in real quasicrystals - it's called a 'phason') -
              from the perspective of the 'step' argument, moving past a
              point corresponds from changing an along-then-up (i.e. LS)
              to an up-then-along (SL).
            </quiz-answer>
            <br/><br/>
          </div>

          Now, try an irrational number - say something like $\phi^{-1}$
          <br/><br/>

          <div class="questions">
            <b>Q6)</b> How far do you have to move the offset now, before atoms
            begin to jump (and how do you think this would change if we
            could zoom as far out as we liked)?
            <quiz-answer>
              For irrational numbers, any finite movement,
              however small, will correspond to a jump. Compared to
              rational numbers, where numbers of the form $p \over q$ change
              after a shift by $1 \over q$, this can be thought of as
              $p$ and $q$ being infinite, so ${1 \over q} = 0$.
            </quiz-answer>
            <br/><br/>

            <b>Q7)</b> Are the first atoms to move near, or far? Why?
            <quiz-answer>
              Hops also typically will occur far away, first. In the
              case of irrational numbers, a rough argument for this
              is that a change near the origin would require our
              line crossing a point near the origin before any
              further away, implying that the best approximation
              is near the origin. However, this implies that
              there exists a <i>best</i> rational approximation to a
              particular irrational number, and it should be fairly
              easy to convince yourself that given any rational
              approximation, we can always build another, better one.
            </quiz-answer>
            <br/><br/>

            <b>Q8)</b> If I suggest that you can view a change in offset
            as shifting the entire grid by an integer number of steps,
            am I right or wrong? Does your answer depend on whether
            or not the crystal is rational?
            <quiz-answer>
              As it turns out, only <i>certain</i> offsets correspond
              directly to a shift in our perspective. Specifically,
              it's those offsets which have <i>just</i> caused an atom to
              jump - our line now crosses through the atom which
              <i>just</i> jumped, and it's therefore equivalent to our
              origin. Hence, in the case of an irrational number,
              continuously changing the offset is equivalent to
              pinging us wildly across our crystal.
            </quiz-answer>
            <br/><br/>
          </div>

          <div class="quiz-answer"></div>
        </span>


        <span>
          <h2>Approximants</h2>

          <div class="questions">
            <b>Q1)</b> Given the structure of a particular irrational
            number (say $\phi^{-1}$), can you find a series of rational
            gradients (and therefore periodic structures, known
            as approximants) which tend towards $\phi^{-1}$ (you can do
            this roughly, visually, or mathematically)?
            <quiz-answer>
              One answer to this is to base this off all the
              truncated decimal expansions of $\phi^{-1}$, so:
              $${0 \over 1},{6 \over 10},{61 \over 100},{618 \over 1000},{61803 \over 100000},...$$
              Which, cancelling common factors, gives:
              $${0 \over 1},{3 \over 5},{61 \over 100},{309 \over 500},{61803 \over 100000},...$$
            </quiz-answer>
            <br/><br/>

            <b>Q2)</b> Is this sequence unique?
            <quiz-answer>
              Series of rational numbers approaching $\phi^{-1}$
              are far from unique: sequences don't even
              need to get closer at every step, so there
              are lots of ways one can safely add or remove
              points from a sequence without damaging
              its convergence.
            </quiz-answer>
            <br/><br/>

            <b>Q3)</b> If I add the condition that we have to
            get closer with <i>every</i> term added, and that we
            never add a fraction with a higher denominator
            if one with a lower denominator could do a
            better job, how does that narrow down your choices?
            <quiz-answer>
              Two sequences which satisfy this condition for $\phi^{-1}$
              can be expressed particularly nicely in terms of
              the Fibonacci numbers.
              $${1 \over 1},{1 \over 2},{2 \over 3},{3 \over 5},{5 \over 8},{8 \over 13},{13 \over 21},...$$
              $${1 \over 1},{2 \over 3},{5 \over 8},{13 \over 21},...$$
              In general, this condition will narrow down
              your options a lot, but it will be far from
              unique, so these aren't the only options you
              could have picked. If you didn't find any sequences
              like these, I'd suggest checking these out and
              getting a sense of their properties. In particular,
              the first one will be key later on, whilst the second
              may provide an interesting lens with which to contrast
              the decisions we take.
            </quiz-answer>
            <br/><br/>

            <b>Q4)</b> In what sense are these good approximations,
            and why might not all ways to define 'closeness to our
            limit' agree on whether or not we converge?
            <quiz-answer>
              Just as when we approximate irrational numbers, these
              are good approximations in that areas 'closer to home'
              (i.e. the first consecutive digits of a numerical
              approximation, or letters of a word) settle on the
              accurate values first, and the correct number in a row
              increases as we increase the order of the approximation.
              It's worth noting that the way in which we define
              convergence isn't immediately obvious. If we define
              this in terms of the proportion of the first period
              which matches an equivalent position in the Fibonacci
              word, then yes, this converges. But if we define this
              in terms of calculating the total proportion of letters
              matching between two series, then it becomes far less
              obvious (to me, at least), that we <i>will</i> get arbitrarily
              close to our limit within a finite number of steps.
              The sort of non-uniform convergence we see here <i>will</i>
              be good enough for us, but these questions are always
              good to ask (especially with physicists, since we often
              brush this kind of technical problem under the rug)!
            </quiz-answer>
            <br/><br/>

            <b>Q5)</b> How does the distribution of approximants
            change for other irrational numbers (say $\sqrt{2}$)?
            <quiz-answer>
              For $\phi^{-1}$, it seems like there's a nice (and maybe
              even complete, in some sense, in the set that a
              large class of other sets can be constructed from
              it) set of approximants meeting the condition that
              each gets progressively closer to $\phi^{-1}$, given
              earlier by:
              $${1 \over 1},{1 \over 2},{2 \over 3},{3 \over 5},{5 \over 8},{8 \over 13},{13 \over 21},...$$
              And, if you try to find these on the graph, you'll
              find they alternate. For $\sqrt{2}$, however, if we try to
              find something similar, close to the origin, we find
              a point which breaks the pattern of alternation:
              $(3,4)$, or $4 \over 3$. We'll see later that the sequence for
              $\phi^{-1}$ generalises nicely to other irrational numbers,
              but should always remember that, <i>unlike</i> in the
              case of $\phi^{-1}$, there in general may also be other
              numbers which <i>could</i> fit into our sequence.
            </quiz-answer>
            <br/><br/>
          </div>

          <div class="quiz-answer"></div>
        </span>


        <span>
          <h2>Moving Between Approximants</h2>

          We can now construct a series of approximants to ou
          quasicrystal, but that doesn't leave us better off,
          if the only way of calculating the next approximant
          is by drawing another line. If we have to do that,
          we might as well go right back to drawing the line
          for $\phi^{-1}$ and be done with this. To avoid this, we can
          try to understand simply the <i>differences</i> between
          successive approximants.<br/>
          Rational approximants have the advantage of periodicity
          - in order to understand an approximant's structure
          <i>everywhere</i>, we only actually need to understand a
          single period.
          <br/><br/>

          <div class="questions">
            <b>Q1)</b> Consider slowly moving the graph from a
            rational point near the origin to any other further
            out: Under what condition will a given atom hop?
            (Hint: This is similar to what we found when adjusting
            the offset earlier).
            <quiz-answer>
              The structure changes whenever the gradient line
              crosses a lattice point.
            </quiz-answer>
            <br/><br/>

            <b>Q2)</b> Where does the structure change the least?
            Is it close to the origin, or further away?
            <quiz-answer>
              The number of lattice points close to the line is the
              lowest near the origin, meaning it will cross the
              fewest points and typically behave the most simply,
              there, out of all the sections of the line we could
              consider. So, if we want to understand the difference
              in structure between the smaller and the larger
              approximants, it would be a good idea to base
              our understanding off of this section of the line.
            </quiz-answer>
            <br/><br/>

            <b>Q3)</b> Focusing now on the first period of the
            final structure, what determines how many changes
            occur between the two lines (I.e., how many times
            do atoms jump position as we move?).
            <quiz-answer>
              The number of changes between the two lines
              will depend slightly on if you're moving up
              or down. If you're moving up (i.e. $1 \over 1$ to
              $17 \over 16$, both approximations to $\sqrt[12]{2}$, the
              frequency multiplier for a semitone on a
              typical piano), you will instantly push out
              the staircase at all points equivalent to $1 \over 1$
              (i.e. $(n,n)$), whilst moving the gradient
              downwards makes no instant change at these
              points (this is all simply based on how the
              staircase structure was defined). Otherwise,
              the number of changes from a smaller
              approximant to a larger approximant within
              the first period is simply the number of
              points between those lines, plus those points
              possibly corresponding to the approximants themselves.
            </quiz-answer>
            <br/><br/>

            <b>Q4)</b> Consider our approximants to $\phi^{-1}$, as
            chosen above: how many points in the first
            period (as well as <i>which</i> points) change as we
            move between approximants (particularly
            successive approximants) from the sequence below?
            $${1 \over 1},{1 \over 2},{2 \over 3},{3 \over 5},{5 \over 8},{8 \over 13},{13 \over 21},...$$
            <quiz-answer>
              This sequence has the property (as for <i>why</i>
              this is the case, we'll find this out later) that
              the only changes within the first period of the
              larger approximation are those corresponding to the
              approximants themselves - there are no points between
              the lines until we get to much higher denominators
              (again, we'll prove this later). Therefore, there should
              be one change every time the line is moved, each time
              at the site of one of the approximants.
            </quiz-answer>
            <br/><br/>

            <b>Q5)</b> Can you find another sequence where even
            fewer points change between each step?
            <quiz-answer>
              Strictly speaking, yes, we can, but not in terms of
              rational approximants, for these, at least one point
              <i>will</i> change each time. However, we <i>can</i> still
              simplify things by picking a series also with the property
              that only one point changes each time, and which
              also converges faster. It turns out we can choose
              a strictly decreasing series of approximants, such
              as the other series we found earlier for $\phi^{-1}$:
              $${1 \over 1},{2 \over 3},{5 \over 8},{13 \over 21},...$$

              It's worth noting the reason we're able to make
              this gain to convergence, which we can see if we
              move from $5 \over 8$ down to $8 \over 13$ and back up
              to $13 \over 21$, whilst
              paying attention to, rather than the first period
              of $8 \over 13$, the first period of $13 \over 21$.
              The act of moving
              down to hit $8 \over 13$ changes one point, but moving back
              up to $13 \over 21$ undoes that change straight after.

              If I'm being honest, focusing on this sequence makes
              the maths for understanding this particular problem
              with quasicrystals significantly easier, but isn't
              as useful generally in number theory, hence why I'm
              not focusing on it, here. I should also note that
              another such sequence exists which approaches $\phi^{-1}$
              from <i>below</i>:
              $${0 \over 1},{1 \over 2},{3 \over 5},{8 \over 13},...$$
              A similar property holds for this sequence, with a
              similar argument - the sequence used above actually
              just hops back and forth between these two series.
            </quiz-answer>
            <br/><br/>

            <b>Q6)</b> Two approximants for $\sqrt{2}$ are given by $7 \over 5$,
            and $17 \over 12$, do the changes as you move
            between these two fit your intuition from $\phi^{-1}$?
            (Hint: In general, it tends to be easier to disentangle
            what's going on with points which are further from the origin.)
            <quiz-answer>
              For the approximants of $\sqrt 2$ given, something
              different does happen, although you may or
              may not have already built this into your
              model. The distance between the two approximants
              is sufficiently large that versions of the $7 \over 5$
              approximant occur before $17 \over 12$ (specifically, the
              points $(5,7)$ and $(10,14)$), meaning that rather than
              one point hopping, as in the case of $\phi^{-1}$, we see
              two points hopping, instead.
            </quiz-answer>
            <br/><br/>
          </div>

          <div class="quiz-answer"></div>
        </span>


        <!-- <div>
          YouTube embed:<br/>
          <youtube-embed src="AaQD-cyXH2A"></youtube-embed>
        </div> -->
      </slide-show>
    </div>
    <div id="middle">
      <canvas id="view" width="800" height="800"></canvas>
      <canvas id="crystal_view" width="800" height="40" class="hidden"></canvas>
    </div>
    <div id="right">
      Gradient: <input type="text" id="in_grad"/>
      <input type="range" id="ins_grad" min="0" max="1" step="0.001"/><br/>
      Offset: <input type="text" id="in_off"/>
      <input type="range" id="ins_off" min="0" max="0.999" step="0.001"/><br/>
      <br/>
      Sequence:<br/>
      <div id="word"></div>
      <br/>
      Continued Fraction:<br/>
      <div class="frac-row">
        <div id="cont_frac"></div>
        <div id="approx_equal"></div>
        <div id="approx_frac"></div>
      </div>
      <div id="coeff_slider_wrap" class="hidden">
        <input type="range" id="coeff_slider" min="1" max="30" step="1"/><br/>
      </div>
      <div id="z_slider_wrap" class="hidden">
        r:
        <input type="range" id="z_slider" min="0" max="1" step="0.01"
            value="0"/><br/>
      </div>
      <br/>
      <div class="flag">
        <input type="checkbox" id="flag_advanced"/>
        <span>Advanced options</span>
      </div>
      <div id="advanced_options" class="hidden">
      </div>
    </div>
  </div>
</div>
</body>
</html>
