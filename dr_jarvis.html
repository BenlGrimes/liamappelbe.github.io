<!DOCTYPE html>
<html>
<head>
<script type="text/javascript">const exports={};</script>
<script src="https://onlinesequencer.net/resources/google-protobuf.js"></script>
<script src="https://onlinesequencer.net/proto/js/instrumentsettings.js"></script>
<script src="https://onlinesequencer.net/proto/js/marker.js"></script>
<script src="https://onlinesequencer.net/proto/js/note.js"></script>
<script src="https://onlinesequencer.net/proto/js/notetype.js"></script>
<script src="https://onlinesequencer.net/proto/js/sequence.js"></script>
<script src="https://onlinesequencer.net/proto/js/sequencesettings.js"></script>
<script type="text/javascript">

function saveBlob(filename, data, type) {
  var file = new Blob(data, {type: type});
  if (window.navigator.msSaveOrOpenBlob) {
    window.navigator.msSaveOrOpenBlob(file, filename);
  } else {
    var a = document.createElement('a');
    var url = URL.createObjectURL(file);
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(function() {
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    }, 0);
  }
}

function protoToBlob(seq) {
  try {
    return seq.serializeBinary();
  } catch (e) {
    console.log('Serializing sequence failed', e);
    console.log(seq.toObject());
    return null;
  }
}

function mod(x, y) { return ((x % y) + y) % y; }
function randb(p = 0.5) { return Math.random() < p; }
function randf(h = 1, l = 0) { return l + Math.random() * (h - l); }
function randi(h = 1, l = 0) { return Math.floor(randf(h + 1, l)); }
function randfq(h = 1) { return h * (Math.random() ** 2); }
function randBeat(h, l, q) { return randi(h / q - 1, l / q) * q; }
function randVol(h, l = 0.2) { return 2 ** randf(Math.log2(h), Math.log2(l)); }
function choose(array) { return array[randi(array.length - 1)]; }
function chooseq(array) { return array[Math.floor(randfq(array.length))]; }
function lerp(a, b, t) { return (1 - t) * a + t * b; }
function ilerp(a, b, y) { return (y - a) / (b - a); }
function linmap(a1, b1, y1, a2, b2) { return lerp(a2, b2, ilerp(a1, b1, y1)); }

function randw(w) {
  let r = randf(w.reduce((x, y) => x + y));
  for (let i = 0; i < w.length; ++i) {
    r -= w[i];
    if (r <= 0) return i;
  }
  return w.length - 1;
}

function getWithOctaves(a, i) {
  const o = Math.floor(i / a.length);
  const j = i - o * a.length;
  console.assert(j < a.length && j >= 0, j);
  return o * 12 + a[j];
}

const kAdjectives = ["Abrupt", "Acidic", "Adorable", "Adventurous", "Aggressive", "Agitated", "Alert", "Aloof", "Amiable", "Amused", "Annoyed", "Antsy", "Anxious", "Appalling", "Appetizing", "Apprehensive", "Arrogant", "Ashamed", "Astonishing", "Attractive", "Average", "Batty", "Beefy", "Bewildered", "Biting", "Bitter", "Bland", "Blushing", "Bored", "Brave", "Bright", "Broad", "Bulky", "Burly", "Charming", "Cheeky", "Cheerful", "Chubby", "Clean", "Clear", "Cloudy", "Clueless", "Clumsy", "Colorful", "Colossal", "Combative", "Comfortable", "Condemned", "Condescending", "Confused", "Contemplative", "Convincing", "Convoluted", "Cooperative", "Corny", "Costly", "Courageous", "Crabby", "Creepy", "Crooked", "Cruel", "Cumbersome", "Curved", "Cynical", "Dangerous", "Dashing", "Decayed", "Deceitful", "Deep", "Defeated", "Defiant", "Delicious", "Delightful", "Depraved", "Depressed", "Despicable", "Determined", "Dilapidated", "Diminutive", "Disgusted", "Distinct", "Distraught", "Distressed", "Disturbed", "Dizzy", "Drab", "Drained", "Dull", "Eager", "Ecstatic", "Elated", "Elegant", "Emaciated", "Embarrassed", "Enchanting", "Encouraging", "Energetic", "Enormous", "Enthusiastic", "Envious", "Exasperated", "Excited", "Exhilarated", "Extensive", "Exuberant", "Fancy", "Fantastic", "Fierce", "Filthy", "Flat", "Floppy", "Fluttering", "Foolish", "Frantic", "Fresh", "Friendly", "Frightened", "Frothy", "Frustrating", "Funny", "Fuzzy", "Gaudy", "Gentle", "Ghastly", "Giddy", "Gigantic", "Glamorous", "Gleaming", "Glorious", "Gorgeous", "Graceful", "Greasy", "Grieving", "Gritty", "Grotesque", "Grubby", "Grumpy", "Handsome", "Happy", "Harebrained", "Healthy", "Helpful", "Helpless", "High", "Hollow", "Homely", "Horrific", "Huge", "Hungry", "Hurt", "Icy", "Ideal", "Immense", "Impressionable", "Intrigued", "Irate", "Irritable", "Itchy", "Jealous", "Jittery", "Jolly", "Joyous", "Filthy", "Flat", "Floppy", "Fluttering", "Foolish", "Frantic", "Fresh", "Friendly", "Frightened", "Frothy", "Frustrating", "Funny", "Fuzzy", "Gaudy", "Gentle", "Ghastly", "Giddy", "Gigantic", "Glamorous", "Gleaming", "Glorious", "Gorgeous", "Graceful", "Greasy", "Grieving", "Gritty", "Grotesque", "Grubby", "Grumpy", "Handsome", "Happy", "Harebrained", "Healthy", "Helpful", "Helpless", "High", "Hollow", "Homely", "Horrific", "Huge", "Hungry", "Hurt", "Icy", "Ideal", "Immense", "Impressionable", "Intrigued", "Irate", "Irritable", "Itchy", "Jealous", "Jittery", "Jolly", "Joyous", "Juicy", "Jumpy", "Kind", "Lackadaisical", "Large", "Lazy", "Lethal", "Little", "Lively", "Livid", "Lonely", "Loose", "Lovely", "Lucent", "Lucky", "Ludicrous", "Macho", "Magnificent", "Mammoth", "Maniacal", "Massive", "Melancholy", "Melted", "Miniature", "Minute", "Mistaken", "Misty", "Moody", "Mortified", "Motionless", "Muddy", "Mysterious", "Narrow", "Nasty", "Naughty", "Nervous", "Nonchalant", "Nonsensical", "Nutritious", "Nutty", "Obedient", "Oblivious", "Obnoxious", "Odd", "Old Fashioned", "Outrageous", "Panicky", "Perfect", "Perplexed", "Petite", "Petty", "Plain", "Pleasant", "Poised", "Pompous", "Precious", "Prickly", "Proud", "Pungent", "Puny", "Quaint", "Quizzical", "Ratty", "Reassured", "Relieved", "Repulsive", "Responsive", "Ripe", "Robust", "Rotten", "Rotund", "Rough", "Round", "Salty", "Sarcastic", "Scant", "Scary", "Scattered", "Scrawny", "Selfish", "Shaggy", "Shaky", "Shallow", "Sharp", "Shiny", "Short", "Silky", "Silly", "Skinny", "Slimy", "Slippery", "Small", "Smarmy", "Smiling", "Smoggy", "Smooth", "Smug", "Soggy", "Solid", "Sore", "Sour", "Sparkling", "Spicy", "Splendid", "Spotless", "Square", "Stale", "Steady", "Steep", "Responsive", "Sticky", "Stormy", "Stout", "Straight", "Strange", "Strong", "Stunning", "Substantial", "Successful", "Succulent", "Superficial", "Superior", "Swanky", "Sweet", "Tart", "Tasty", "Teeny", "Tender", "Tense", "Terrible", "Testy", "Thankful", "Thick", "Thoughtful", "Thoughtless", "Tight", "Timely", "Tricky", "Trite", "Troubled", "Twittering", "Uneven", "Unsightly", "Upset", "Uptight", "Vast", "Vexed", "Victorious", "Virtuous", "Vivacious", "Vivid", "Wacky", "Weary", "Whimsical", "Whopping", "Wicked", "Witty", "Wobbly", "Wonderful", "Worried", "Yummy", "Zany", "Zealous", "Zippy"];
const kColors = ["Alizarin", "Amaranth", "Amber", "Amethyst", "Apricot", "Aqua", "Aquamarine", "Asparagus", "Auburn", "Azure", "Beige", "Bistre", "Black", "Blue", "Blue Green", "Blue Violet", "Bondi Blue", "Brass", "Bronze", "Brown", "Buff", "Burgundy", "Burnt Orange", "Burnt Sienna", "Burnt Umber", "Caput Mortuum", "Cardinal", "Carmine", "Carrot Orange", "Celadon", "Cerise", "Cerulean", "Champagne", "Charcoal", "Chartreuse", "Chestnut", "Chocolate", "Cinnabar", "Cinnamon", "Cobalt", "Copper", "Coral", "Corn", "Cornflower", "Cream", "Crimson", "Cyan", "Dandelion", "Denim", "Ecru", "Emerald", "Eggplant", "Falu Red", "Fern Green", "Firebrick", "Flax", "Forest Green", "French Rose", "Fuchsia", "Gamboge", "Gold", "Goldenrod", "Green", "Grey", "Han Purple", "Harlequin", "Heliotrope", "Indigo", "Ivory", "Jade", "Kelly Green", "Khaki", "Lavender", "Lawn Green", "Lemon", "Lemon Chiffon", "Lilac", "Lime", "Lime Green", "Linen", "Magenta", "Magnolia", "Malachite", "Maroon", "Mauve", "Midnight Blue", "Mint Green", "Misty Rose", "Moss Green", "Mustard", "Myrtle", "Navajo White", "Navy Blue", "Ochre", "Office Green", "Olive", "Olivine", "Orange", "Orchid", "Papaya Whip", "Peach", "Pear", "Periwinkle", "Persimmon", "Pine Green", "Pink", "Platinum", "Plum", "Powder Blue", "Puce", "Prussian Blue", "Pumpkin", "Purple", "Quartz Grey", "Raw Umber", "Razzmatazz", "Red", "Robin Egg Blue", "Rose", "Royal Blue", "Royal Purple", "Ruby", "Russet", "Rust", "Safety Orange", "Saffron", "Salmon", "Sandy Brown", "Sangria", "Sapphire", "Scarlet", "Sea Green", "Seashell", "Sepia", "Shocking Pink", "Silver", "Sky Blue", "Slate Grey", "Smalt", "Spring Bud", "Spring Green", "Steel Blue", "Tan", "Tangerine", "Taupe", "Teal", "Tawny", "Terra Cotta", "Thistle", "Tomato", "Turquoise", "Tyrian Purple", "Ultramarine", "Van Dyke Brown", "Vermilion", "Violet", "Viridian", "Wheat", "White", "Wisteria", "Xanthic", "Yellow", "Zucchini"];
const kAnimals = ["Aardvark", "Albatross", "Alligator", "Alpaca", "Ant", "Anteater", "Antelope", "Ape", "Armadillo", "Baboon", "Badger", "Barracuda", "Bat", "Bear", "Beaver", "Bee", "Bird", "Bison", "Boar", "Buffalo", "Butterfly", "Camel", "Caribou", "Cassowary", "Cat", "Caterpillar", "Cattle", "Chamois", "Cheetah", "Chicken", "Chimpanzee", "Chinchilla", "Chough", "Coati", "Cobra", "Cockroach", "Cod", "Cormorant", "Coyote", "Crab", "Crane", "Crocodile", "Crow", "Curlew", "Deer", "Dinosaur", "Dog", "Dogfish", "Dolphin", "Donkey", "Dotterel", "Dove", "Dragonfly", "Duck", "Dugong", "Dunlin", "Eagle", "Echidna", "Eel", "Eland", "Elephant", "Elephant Seal", "Elk", "Emu", "Falcon", "Ferret", "Finch", "Fish", "Flamingo", "Fly", "Fox", "Frog", "Gaur", "Gazelle", "Gerbil", "Giant Panda", "Giraffe", "Gnat", "Gnu", "Goat", "Goldfinch", "Goosander", "Goose", "Gorilla", "Goshawk", "Grasshopper", "Grouse", "Guanaco", "Guinea Fowl", "Guinea Pig", "Gull", "Hamster", "Hare", "Hawk", "Hedgehog", "Heron", "Herring", "Hippo", "Hornet", "Horse", "Hummingbird", "Hyena", "Ibex", "Ibis", "Jackal", "Jaguar", "Jay", "Jellyfish", "Kangaroo", "Kinkajou", "Koala", "Komodo Dragon", "Kouprey", "Kudu", "Lapwing", "Lark", "Lemur", "Leopard", "Lion", "Llama", "Lobster", "Locust", "Loris", "Louse", "Lyrebird", "Magpie", "Mallard", "Mammoth", "Manatee", "Mandrill", "Mink", "Mole", "Mongoose", "Monkey", "Moose", "Mouse", "Mosquito", "Narwhal", "Newt", "Nightingale", "Octopus", "Okapi", "Opossum", "Ostrich", "Otter", "Owl", "Oyster", "Panther", "Parrot", "Panda", "Partridge", "Peafowl", "Pelican", "Penguin", "Pheasant", "Pig", "Pigeon", "Polar Bear", "Pony", "Porcupine", "Porpoise", "Prairie Dog", "Quail", "Quelea", "Quetzal", "Rabbit", "Raccoon", "Ram", "Rat", "Raven", "Reindeer", "Rhinoceros", "Rook", "Salamander", "Salmon", "Sand Dollar", "Sandpiper", "Sardine", "Sea Lion", "Seahorse", "Seal", "Shark", "Sheep", "Shrew", "Skunk", "Sloth", "Snail", "Snake", "Spider", "Squid", "Squirrel", "Starling", "Stegosaurus", "Swan", "Tapir", "Tarsier", "Termite", "Tiger", "Toad", "Turkey", "Turtle", "Vicuna", "Wallaby", "Walrus", "Wasp", "Water Buffalo", "Weasel", "Whale", "Wolf", "Wolverine", "Wombat", "Wren", "Yak", "Zebra"];
function genName() { return `The ${choose(kAdjectives)} ${choose(kColors)} ${choose(kAnimals)}.sequence`; }

function generate(generator) {
  const blob = protoToBlob(generator());
  if (!blob) return;
  const name = genName() + '';
  saveBlob(name, [blob], 'application/octet-stream');
}

function isNumber(n) { return !isNaN(parseFloat(n)) && isFinite(n); }

function noteTypeToProto(type) {
  return proto.NoteType[type.replace('#', 'S')];
}

function validNoteType(type) {
  try {
    return isNumber(noteTypeToProto(type));
  } catch {
    return false;
  }
}

const kNoteTypeNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
function noteType(key, octave) {
  const i = mod(key, 12);
  const o = octave + Math.floor((key - i) / 12);  // In case key >= 12 or < 0.
  return kNoteTypeNames[i] + o;
}

function buildDrumWeights(firstNote, volumes) {
  const offset = noteTypeToProto(firstNote);
  const m = new Map();
  for (let i = 0; i < volumes.length; ++i) m.set(i + offset, volumes[i]);
  return m;
}

const kDw0 = buildDrumWeights('D#2', [
  0.5,    0.8333, 0.6667, 0.5882, 0.5882, 0.5,    0.5,    0.7692, 0.5,
  0.5,    0.625,  0.625,  0.8333, 0.7143, 0.5556, 0.5556, 0.5,    0.5,
  0.5882, 1,      0.625,  0.7143, 1,      0.5,    0.5882, 1,      0.7143,
  0.6667, 0.7143, 0.6667, 0.8333, 0.6667, 0.625,  0.5,    0.5263, 0.5,
  0.5,    0.5,    0.6667, 0.6667, 0.625,  0.625,  0.6667, 0.5882, 0.7692,
  0.8333, 0.625,  0.625,  0.5882, 0.5,    0.5,    0.5,    0.5,    0.5714,
  0.7692, 0.6667, 0.6667, 0.5,    0.5,    0.5882, 0.6667
]);

const kDw1 = buildDrumWeights('D#2', [
  0.8,    0.625,  1,      1,      0.9091, 0.4,    0.5,    0.8,    0.9091,
  0.9091, 0.6897, 1,      1.5385, 1,      0.7692, 0.4545, 0.7143, 0.9091,
  1.1111, 1.3333, 1,      0.9524, 1,      0.7692, 0.6667, 1.0526, 0.6667,
  0.6667, 0.8,    0.9524, 1.4286, 1.4286, 0.9524, 0.625,  0.5263, 0.625,
  0.5,    0.5882, 0.7407, 0.8,    0.7407, 0.7692, 0.8696, 0.7692, 1.2,
  1.25,   0.8333, 1.25,   1,      0.5,    0.5,    0.6897, 0.6667, 1,
  1.25,   1.25,   1.3333, 1.3333, 0.7143, 0.6667, 0.625
]);

const kDw2 = buildDrumWeights('D#2', [
  1, 1, 1.5385, 2.8571, 4, 2.5, 2, 1.6667, 2.8571, 4, 2.2222, 1.6667, 1.6667,
  1.4286, 1.4286, 3.5714, 4, 2
]);

const kDw3 = buildDrumWeights('G2', [ 1.25, 1, 0.8333, 1.8182, 1.8182, 2.5 ]);

const kDw4 = buildDrumWeights('G2', [
  1.6667, 2.5,    2.5,    4,      3.6364, 2.2222, 1.5385,
  1.1111, 1.6667, 1.3333, 2.5,    0.9091, 1.4286, 2.2222,
  2.5,    1.5385, 1.25,   2.8571, 2,      2.5,    2.5,
  2.5,    2.5,    0.25,   2.5,    2.5,    3.3333, 1.6667
]);

const kDw5 = buildDrumWeights('D#2', [
  1.8182, 1.8182, 1.8182, 2,      2,      1.5385, 0.7692,
  0.9091, 0.7407, 0.8333, 0.8696, 1.1111, 1.25,   1.6667,
  0.8696, 1.25,   1.5385, 1.5385, 1.6667, 0.9524
]);

const kVolWeights = [
  1,     0.7692, kDw0,   1.25,   1.25,   1,      0.9091, 1.25,   1,
  1,     1.25,   1,      0.5882, 0.7143, 1.4286, 1.1111, 0.7692, 1.25,
  0.625, 1,      0.8333, 0.9091, 1.1765, 0.6667, 1,      1,      0.8696,
  1,     0.625,  1.1111, 1.1111, kDw1,   0.9091, 1.25,   1.1765, 1.3333,
  kDw2,  1.25,   1.1111, kDw3,   kDw4,   0.9524, kDw5,
];

function getVolWeight(inst, index) {
  const a = kVolWeights[inst];
  return (a instanceof Map ? a.get(index) : a) || 0;
}

// I'm representing note times and lengths as a float number of beats, whereas
// OS represents them as a number of quarter beats.
function noteTimeToOsFormat(time) { return 4 * time; }

class Note {
  constructor(type, time, len, inst, vol) {
    this.type = type;
    this.time = time;
    this.len = len;
    this.inst = inst;
    this.vol = vol;
  }

  shift(dt) {
    return new Note(this.type, this.time + dt, this.len, this.inst, this.vol);
  }

  swing(newMidpoint) {
    const intTime = Math.floor(this.time);
    const fractTime = this.time - intTime;
    const newTime = intTime + (fractTime < 0.5 ?
        linmap(0, 0.5, fractTime, 0, newMidpoint) :
        linmap(0.5, 1, fractTime, newMidpoint, 1));
    return new Note(this.type, newTime, this.len, this.inst, this.vol);
  }

  get asProto() {
    if (!validNoteType(this.type)) return null;
    const np = new proto.Note();
    const index = noteTypeToProto(this.type);
    np.setType(index);
    np.setTime(noteTimeToOsFormat(this.time));
    np.setLength(this.len > 0 ? noteTimeToOsFormat(this.len) : 1);
    np.setInstrument(this.inst);
    np.setVolume(this.vol / getVolWeight(this.inst, index));
    return np;
  }
}

// Note: Melody generator assumes these scales are the same length.
const kMajorScale = [0, 2, 4, 5, 7, 9, 11];
const kMinorScale = [0, 2, 3, 5, 7, 8, 10];  // Natural minor.
class Chord {
  constructor(base, minor, seventh = false, ninth = false, sus4 = false) {
    this.base = base;
    this.minor = minor;
    this.seventh = seventh;
    this.ninth = ninth;
    this.sus4 = sus4;
  }

  _apply(n) { return n.map(i => (i + this.base - (this.minor ? 3 : 0))); }

  triadIndexes() { return this._apply([ 0, 4 - this.minor, 7 ]); }
  noteIndexes() {
    const n = [ 0, this.sus4 ? 5 : 4 - this.minor, 7 ];  // In semitones.
    if (this.seventh) n.push(11 - this.minor);
    if (this.ninth) n.push(14);
    return this._apply(n);
  }

  noteIndexesFolded() {
    const n = this.noteIndexes().map(i => mod(i - this.base, 12) + this.base);
    n.sort((x, y) => x - y);
    return n;
  }

  scale() { return this._apply(this.minor ? kMinorScale : kMajorScale); }
}

const kChordBases = [0, 5, 7];  // I, IV, V, in semitones
function genChords(n, key) {
  const chords = [new Chord(key, randb())];
  for (let i = 1; i < n; ++i) {
    const kind = randw([4, 3, 2, 1]);
    chords.push(new Chord(
        choose(kChordBases) + key,
        randb(), kind == 1, kind == 2, kind == 3));
  }
  return chords;
}

function genTwinChords(n, key) {
  const m = Math.floor(n / 2);
  return merge(genChords(m, key), genChords(n - m, key));
}

function marker(time, setting, inst, value, blend = false) {
  var m = new proto.Marker();
  m.setTime(noteTimeToOsFormat(time));
  m.setSetting(setting);
  m.setInstrument(inst);
  m.setValue(value);
  m.setBlend(blend);
  return m;
}

const kMSInstVol = 1;
const kMSPan = 2;
const kMSEqH = 3;
const kMSEqM = 4;
const kMSEqL = 5;
const kMSVol = 8;
const kMSDetune = 11;

function eq(high, mid, low) { return { high: high, mid: mid, low: low }; }
const kEqNormal = eq(0, 0, 0);
const kFadedEqSettings = [ eq(10, 0, -48), eq(-48, 20, -48), eq(-48, 0, 20) ];

function drum(inst, type) { return { inst: inst, type: type }; }
function drumNote(drumType, time, vol = 1) {
  return new Note(drumType.type, time, 0, drumType.inst, vol);
}

const kDrumKicks = [
  drum(2, "B2"), drum(2, "C3"), drum(31, "B2"), drum(31, "C3"), drum(39, "G2"),
  drum(40, "G2"), drum(40, "G#2"), drum(36, "D#2"), drum(36, "E2"),
  drum(36, "F2"), drum(42, "D#2"), drum(42, "E2"), drum(42, "F2"),
];

const kDrumSnares = [
  drum(2, "G2"), drum(2, "D3"), drum(2, "C#3"), drum(2, "D#3"), drum(2, "E3"),
  drum(31, "G2"), drum(31, "C#3"), drum(31, "D3"), drum(31, "D#3"),
  drum(31, "E3"), drum(39, "A#2"), drum(39, "B2"), drum(39, "C3"),
  drum(39, "G#2"), drum(40, "A2"), drum(40, "A#2"), drum(40, "B2"),
  drum(40, "C3"), drum(40, "G#4"), drum(40, "A#4"), drum(36, "F#2"),
  drum(36, "G2"), drum(36, "G#2"), drum(36, "A2"), drum(36, "A#2"),
  drum(36, "G#3"), drum(42, "F#2"), drum(42, "G2"), drum(42, "G#2"),
  drum(42, "D#3"), drum(42, "E3"),
];

const kDrumHats = [
  drum(2, "F#3"), drum(2, "G#3"), drum(2, "A#3"), drum(2, "D#4"), drum(2, "F4"),
  drum(2, "B4"), drum(31, "F#3"), drum(31, "G#3"), drum(31, "A#3"),
  drum(31, "D#4"), drum(31, "F4"), drum(31, "B4"), drum(39, "A2"),
  drum(40, "D3"), drum(40, "E3"), drum(40, "F#3"), drum(40, "B3"),
  drum(40, "C#4"), drum(40, "F#4"), drum(40, "G4"), drum(36, "B2"),
  drum(36, "C3"), drum(42, "F3"), drum(42, "F#3"), drum(42, "G3"),
  drum(42, "G#3"), drum(42, "A#3"),
];

const kDrumCymbals = [
  drum(2, "C#4"), drum(2, "E4"), drum(2, "G4"), drum(2, "A4"), drum(31, "C#4"),
  drum(31, "E4"), drum(31, "G4"), drum(31, "A4"), drum(40, "A4"),
  drum(40, "F4"), drum(40, "D#4"), drum(40, "C4"), drum(40, "A3"),
  drum(42, "A3"),
];

const kDrumAll = function() {
  const ranges = [[2, 3, 63], [31, 3, 63], [39, 7, 12], [40, 7, 34],
                  [36, 3, 20], [42, 3, 22]];
  const n = [];
  for (const [inst, lo, hi] of ranges) {
    for (let i = lo; i <= hi; ++i) n.push(drum(inst, noteType(i, 2)));
  }
  return n;
}();

function chordInst(inst, susLen) { return { inst: inst, susLen: susLen }; }
const kChordsInst = [
  chordInst(0, 1), chordInst(1, 1), chordInst(3, 1), chordInst(4, 2),
  chordInst(6, 1), chordInst(7, 1), chordInst(8, 1), chordInst(11, 0.5),
  chordInst(12, 0.5), chordInst(13, 4), chordInst(16, 4), chordInst(18, 1),
  chordInst(20, 1), chordInst(23, 2), chordInst(24, 1), chordInst(25, 1),
  chordInst(26, 1), chordInst(30, 1), chordInst(32, 1), chordInst(34, 1),
  chordInst(35, 1), chordInst(38, 1), chordInst(41, 2),
];

function bassInst(inst) { return { inst: inst }; }
const kBassInst = [
  bassInst(21), bassInst(1), bassInst(5), bassInst(29), bassInst(32),
  bassInst(22), bassInst(3), bassInst(6), bassInst(13), bassInst(30),
  bassInst(14), bassInst(15), bassInst(16), bassInst(20), bassInst(24),
  bassInst(27),
];

function melodyInst(inst) { return { inst: inst }; }
const kMelodyInst = [
  melodyInst(0), melodyInst(8), melodyInst(17), melodyInst(25), melodyInst(26),
  melodyInst(19), melodyInst(34), melodyInst(21), melodyInst(1), melodyInst(4),
  melodyInst(32), melodyInst(22), melodyInst(33), melodyInst(6), melodyInst(7),
  melodyInst(13), melodyInst(14), melodyInst(15), melodyInst(16),
  melodyInst(11), melodyInst(18), melodyInst(20), melodyInst(23),
  melodyInst(41),
];

const kBar = 4;
const kSection = 8;

function lowestSetBit(x) { return x & -x; }
function beatEmphasis(t) {
  const kBeatRes = 8;
  const i = Math.floor(0.5 + mod(t, kBar) * kBeatRes);
  if (i == 0) return 1;
  return Math.log2(lowestSetBit(i)) / Math.log2(kBar * kBeatRes);
}

function chordsToNotes(chords, key = 0, octave = 4, instrument = 41) {
  const notes = [];
  for (let i = 0; i < chords.length; ++i) {
    for (const j of chords[i].noteIndexes(key)) {
      notes.push(new Note(noteType(j, octave), i * kBar, kBar, instrument, 1));
    }
  }
  return notes;
}

function merge(...args) {
  out = [];
  for (let i = 0; i < args.length; ++i) {
    for (const n of args[i]) out.push(n);
  }
  return out;
}

function joinBars(args) {
  out = [];
  for (let i = 0; i < args.length; ++i) {
    for (const n of args[i]) out.push(n.shift(i * kBar));
  }
  return out;
}

function joinSections(args) {
  out = [];
  for (let i = 0; i < args.length; ++i) {
    for (const n of args[i]) out.push(n.shift(i * kBar * kSection));
  }
  return out;
}

function genEmphasisEx(length, dt, p0, p1, emphCap, fn) {
  for (let t = 0; t < length; t += dt) {
    const e = Math.min(1, beatEmphasis(t) / emphCap);
    if (randb(lerp(p0, p1, e))) fn(t, e);
  }
}

function genEmphasisBar(p0, p1, fn) {
  return genEmphasisEx(kBar, 0.25, p0, p1, 1, fn);
}

function addNoteWithTrill(notes, inst, t, vol, trillLen, trillDt, trillVol) {
  notes.push(drumNote(inst, t, vol));
  for (let i = 1; i <= trillLen; ++i) {
    notes.push(drumNote(inst, t - i * trillDt, vol * trillVol));
  }
}

const kLoFiTrillDt = 0.125;
const kLoFiTrillVol = 0.25;
function genLoFiDrumsOneBar(ctx, first, vigor) {
  const notes = [
    drumNote(ctx.kick, 0),
    drumNote(ctx.kick, randb() ? 2 : 2.5),
  ];

  function addNoteMaybeTrill(inst, t, vol = 1) {
    addNoteWithTrill(notes, inst, t, vol, randb(0.2 * vigor) ? randi(2, 1) : 0,
                     kLoFiTrillDt, kLoFiTrillVol);
  }
  addNoteMaybeTrill(ctx.snare1, 1);
  addNoteMaybeTrill(ctx.snare1, randb(0.7) ? 3 : 3.5);

  if (first) notes.push(drumNote(ctx.cymbal, 0));

  genEmphasisBar(0.1, lerp(0.4, 1, vigor),
      (t, e) => addNoteMaybeTrill(ctx.kick, t, e * randf(1.2, 0.8)));
  genEmphasisBar(0.1, lerp(0.4, 1, vigor),
      (t, e) => addNoteMaybeTrill(ctx.snare2, t, e * randf(0.8, 0.5)));

  for (let i = 0; i < kBar; ++i) {
    if (vigor > 0.3) notes.push(drumNote(ctx.hat1, i + 0.5));
    if (vigor > 0.7) notes.push(drumNote(ctx.hat2, i + 0.25, randVol(0.5)));
    if (vigor > 0.7) notes.push(drumNote(ctx.hat2, i + 0.75, randVol(0.5)));
  }
  return notes;
}

function genLoFiDrumsOneBarBreak(ctx, vigor) {
  const notes = [];
  function addNoteMaybeTrill(inst, t, vol = 1) {
    addNoteWithTrill(notes, inst, t, vol, randb(0.5 * vigor) ? randi(4, 1) : 0,
                     kLoFiTrillDt, kLoFiTrillVol);
  }
  genEmphasisBar(0.1, lerp(0.4, 1, vigor),
      (t, e) => addNoteMaybeTrill(ctx.kick, t, e * randf(1.2, 0.8)));
  genEmphasisBar(0.1, lerp(0.4, 1, vigor),
      (t, e) => addNoteMaybeTrill(ctx.snare1, t, e * randf(1.2, 0.8)));
  genEmphasisBar(0.1, lerp(0.4, 1, vigor),
      (t, e) => addNoteMaybeTrill(ctx.snare2, t, e * randf(0.8, 0.5)));
  for (let i = 0; i < kBar; ++i) {
    if (vigor > 0.3) notes.push(drumNote(ctx.hat1, i + 0.5));
    if (vigor > 0.7) notes.push(drumNote(ctx.hat2, i + 0.25, randVol(0.5)));
    if (vigor > 0.7) notes.push(drumNote(ctx.hat2, i + 0.75, randVol(0.5)));
  }
  return notes;
}

function genLoFiDrums(ctx, vigor) {
  const bars = [];
  for (let i = 0; i < kSection - 1; ++i) {
    bars.push(genLoFiDrumsOneBar(ctx, i == 0, vigor));
  }
  bars.push(genLoFiDrumsOneBarBreak(ctx, vigor));
  return joinBars(bars);
}

function chordVoice(idx, octh = 0, octl = 0) {
  return 12 * randi(octh, octl) + idx;
}

kPossibleArpDirs = 4;
function arpIndex(x, n, d) {
  if (d == 0 || d == 1) {
    // Saw wave.
    return mod(d == 0 ? x : -1 - x, n);
  } else if (d == 2 || d == 3) {
    // Triangle wave.
    const m = n - 1;
    const y = mod(d == 2 ? x : x + m, 2 * m);
    return y < n ? y : m - 1 - mod(y, n);
  }
}

function genLoFiChords(ctx) {
  const notes = [];
  const style = randi(1);
  if (style == 0) {
    // Plain chords, optionally decimated.
    const dec = randb(0.3);
    const len = dec ? Math.min(2, ctx.chordInst.susLen) : ctx.chordInst.susLen;
    for (let i = 0; i < ctx.chords.length; ++i) {
      const ch = ctx.chords[i].noteIndexesFolded();
      for (let j = 0; j < ch.length; ++j) {
        for (let t = 0; t < kBar; t += len) {
          if (j != 0 && dec && randb(0.2)) continue;
          notes.push(new Note(
              noteType(chordVoice(ch[j], 2), 3), i * kBar + t, len,
              ctx.chordInst.inst, j == 0 ? 1 : randf(1, 0.5)));
        }
      }
    }
  } else if (style == 1) {
    // Arpegios, in a random direction.
    const dir = randi(kPossibleArpDirs - 1);
    const oct = randi(2, 1);
    const len = choose([0.25, 0.5, 1]);
    for (let i = 0; i < ctx.chords.length; ++i) {
      const ch = ctx.chords[i].noteIndexesFolded();
      for (let t = 0, j = 0; t < kBar; t += len, ++j) {
        const k = arpIndex(j, ch.length * oct, dir);
        notes.push(new Note(
            noteType(ch[mod(k, ch.length)], 3 + Math.floor(k / ch.length)),
            i * kBar + t, len, ctx.chordInst.inst,
            mod(k, ch.length) == 0 ? 1 : randf(1, 0.5)));
      }
    }
  }
  return notes;
}

function genLoFiBass(ctx) {
  const notes = [];
  const len = 0.5;
  for (let i = 0; i < ctx.chords.length; ++i) {
    const ch = ctx.chords[i].triadIndexes();
    for (let t = 0; t < kBar; t += len) {
      if (t == 0 || randb(0.4)) {
        notes.push(new Note(
            noteType(mod(choose(ch), 12), 2), i * kBar + t, len,
            ctx.bassInst.inst, randf(1, 0.5)));
      }
    }
  }
  return notes;
}

class MelodicRhythmNote {
  constructor(t, triad, index, index2, rep) {
    this.t = t;
    this.triad = triad;
    this.index = index;
    this.index2 = index2;
    this.rep = rep;
  }
}
class MelodicRhythm {
  constructor(t0, a = null) {
    this.t0 = t0;
    this.a = a === null ? [] : a;
  }
  add(t, triad, index, index2, rep = false) {
    this.a.push(new MelodicRhythmNote(t - this.t0, triad, index, index2, rep));
  }
  get length() { return this.a.length; }
  get last() { return this.length == 0 ? null : this.a[this.length - 1]; }
  forEach(toff, fn) {
    for (const n of this.a) {
      fn(toff + this.t0 + n.t, n.triad, n.index, n.index2);
    }
  }
  find(t) {
    for (const n of this.a) {
      if (this.t0 + n.t == t) return n;
    }
    return null;
  }
  repeat(rt, t) {
    const n = this.find(rt);
    if (n != null) this.add(t, n.triad, n.index, n.index2, true);
  }
  finish() {
    const n = this.last;
    n.triad = true;  // End the phrase on a triad note.
    n.index = randi(2);
    return this;
  }
};

function genLoFiMelodyChunk(length, dt, vigor) {
  // The most important constraint for melody generation is to end every phrase
  // on a note from the current chord's triad. Using the usual breatEmphasis
  // based rhythm generation, a new phrase is defined as any time there's more
  // than half a beat between notes. At this point we just generate the rhythms,
  // because some of the notes depend on which chord the chunk is in.
  console.assert(kMajorScale.length == kMinorScale.length);
  const phraseLimit = 0.5;
  const phrases = [];
  let phrase = null;
  let pt = -2 * phraseLimit;
  let lastNonTriadIndex = null;
  let repTime = 0;
  let repStop = 0;
  for (let t = 0; t < length; t += dt) {
    if (repTime >= repStop && phrase != null && t > (phrase.t0 + 2 * dt) &&
        randb(0.1)) {
      // Begin new repetition.
      repStop = t;
      repTime = randBeat(t - dt, phrase.t0, dt);
    }
    if (repTime < repStop) {
      // Continue the repetition.
      phrase.repeat(repTime, t);
      repTime += dt;
      continue;
    }
    const e = Math.min(1, beatEmphasis(t) / 0.8);
    if (!randb(lerp(0.3, lerp(0.5, 0.9, vigor), e))) continue;
    // Add a new beat here.
    if (phrase === null || t - pt > phraseLimit) {
      if (phrase !== null) phrases.push(phrase.finish());
      phrase = new MelodicRhythm(t);
    }
    const triad = randb(lerp(0, lerp(0.1, 0.5, vigor), e));
    let index;
    let index2 = -1;
    if (triad) {
      // Add a triad note.
      index = randi(2);
      if (randb(0.3)) {
        // Add a second triad note.
        index2 = index;
        while (index2 == index) index2 = randi(2);
      }
    } else {
      // Add a non-triad note.
      if (lastNonTriadIndex === null) {
        // Pick a random note from the scale.
        index = randi(kMajorScale.length - 1);
      } else {
        // Step up or down from the last non-triad note.
        index = lastNonTriadIndex + [-2, -1, 0, 1, 2][randw([2, 3, 1, 3, 2])];
      }
      lastNonTriadIndex = index;
    }
    phrase.add(t, triad, index, index2);
    pt = t;
  }
  if (phrase !== null) phrases.push(phrase.finish());
  return phrases;
}

function genLoFiMelody(ctx, inst, secondary, vigor) {
  const dt = secondary ? 0.5 : 0.25;
  const oct = secondary ? 6 : 5;
  const vol = secondary ? 0.7 : 1;
  const all = ctx.chords[0].scale();
  const notes = [];
  let pj = null;
  function wrap(j) {
    if (pj === null) return j;
    j = mod(j, 12);
    while (pj - j > 7) j += 12;
    while (j - pj > 7) j -= 12;
    return j;
  }
  function addChunk(phrases, barOffset) {
    const toff = barOffset * kBar;
    for (const phrase of phrases) {
      phrase.forEach(toff, (t, triad, index, index2) => {
        const ch = ctx.chords[mod(Math.floor(t / kBar), kSection)];
        const tri = ch.triadIndexes();
        const j = triad ? wrap(getWithOctaves(tri, index))
                             : getWithOctaves(all, index);
        const v = lerp(0.6, 1, beatEmphasis(t)) * vol;
        notes.push(new Note(noteType(j, oct), t, dt, inst.inst, v));
        if (triad && index2 != -1) {
          const j2 = wrap(getWithOctaves(tri, index2));
          notes.push(new Note(noteType(j2, oct), t, dt, inst.inst, v));
        }
        pj = j;
      });
    }
  }
  const a = genLoFiMelodyChunk(2 * kBar, dt, vigor);
  const b = genLoFiMelodyChunk(1 * kBar, dt, vigor);
  const c = genLoFiMelodyChunk(2 * kBar, dt, vigor);
  addChunk(a, 0);
  addChunk(b, 2);
  addChunk(b, 3);
  addChunk(a, 4);
  addChunk(c, 6);

  // Add an extra triad note at the start of the next section.
  notes.push(new Note(
      noteType(choose(ctx.chords[0].triadIndexes()), oct),
      kSection * kBar, dt, inst.inst, vol));

  return notes;
}

function genLoFiAtmo(ctx) {
  const notes = [];
  const dt = 0.25;
  for (let k = 0; k < kSection; ++k) {
    const end = randBeat(kBar * kSection, 0, 0.5);
    const start = Math.max(0, end - randBeat(1.5, 0.25, 0.25));
    for (let t = start; t <= end; t += dt) {
      const vol = 0.8 * (t == end ? 1 : Math.min(1, beatEmphasis(t) + 0.4));
      const n = choose(ctx.atmo);
      notes.push(new Note(n.type, t, dt, n.inst, vol));
    }
  }
  return notes;
}

function genLoFiInstSettings(ctx) {
  function setEq(settings, eq) {
    settings.setEnableEq(true);
    settings.setEqHigh(eq.high);
    settings.setEqMid(eq.mid);
    settings.setEqLow(eq.low);
  }
  ctx.instSettings = new Map();
  function settings(inst) {
    if (!ctx.instSettings.has(inst)) {
      const settings = new proto.InstrumentSettings();
      ctx.instSettings.set(inst, settings);
      settings.setVolume(1);
      setEq(settings, eq(randf(3, -3), randf(3, -3), randf(3, -3)));
    }
    return ctx.instSettings.get(inst);
  }
  for (const i of ctx.allInst) settings(i.inst);

  // Panning.
  settings(ctx.chordInst.inst).setPan(randf(-0.3, 0.3));
  const m1pan = randf(-0.8, 0.8);
  settings(ctx.melody1Inst.inst).setPan(m1pan);
  settings(ctx.melody2Inst.inst).setPan(-m1pan);
  for (const a of ctx.atmo) settings(a.inst).setPan(randf(-1, 1));

  // Overwrite panning on drums and bass, in case they're the same as one of the
  // other instruments. These instruments should always have little to no pan.
  settings(ctx.kick.inst).setPan(randf(-0.1, 0.1));
  settings(ctx.snare1.inst).setPan(randf(-0.1, 0.1));
  settings(ctx.snare2.inst).setPan(randf(-0.1, 0.1));
  settings(ctx.hat1.inst).setPan(randf(-0.1, 0.1));
  settings(ctx.hat2.inst).setPan(randf(-0.1, 0.1));
  settings(ctx.cymbal.inst).setPan(randf(-0.1, 0.1));
  settings(ctx.bassInst.inst).setPan(randf(-0.1, 0.1));

  // Drum detunes.
  function randomDetune(inst) { settings(inst).setDetune(randf(-1200, 1200)); }
  for (const d of ctx.drums) randomDetune(d.inst);

  // For lo-fi, the snares and cymbals should be faded.
  setEq(settings(ctx.snare1.inst), choose(kFadedEqSettings));
  setEq(settings(ctx.snare2.inst), choose(kFadedEqSettings));
  setEq(settings(ctx.cymbal.inst), choose(kFadedEqSettings));

  // Bass and chords eq.
  setEq(settings(ctx.bassInst.inst), eq(-48, 0, 20));
  setEq(settings(ctx.chordInst.inst), eq(0, 0, 10));

  // Randomize reverb effects.
  const kEffects = [
    [1, 1], [2, 1], [3, 1], [4, 1], [5, 0.5], [6, 0.5], [7, 0.5],
    [8, 0.5], [9, 0.1], [10, 0.5], [11, 0.3],
  ];
  function chooseEffect(inst) {
    const s = settings(inst);
    if (randb(0.5)) {
      const [e, v] = choose(kEffects);
      s.setReverb(e != 0);
      s.setReverbType(e);
      s.setOneMinusReverbVolume(1 - randf(1, 0.2) * v);
    } else {
      s.setReverb(false);
    }
  }
  chooseEffect(ctx.kick.inst);
  chooseEffect(ctx.snare1.inst);
  chooseEffect(ctx.snare2.inst);
  chooseEffect(ctx.hat1.inst);
  chooseEffect(ctx.hat2.inst);
  chooseEffect(ctx.cymbal.inst);
  chooseEffect(ctx.bassInst.inst);
  chooseEffect(ctx.chordInst.inst);
  chooseEffect(ctx.melody1Inst.inst);
  chooseEffect(ctx.melody2Inst.inst);
}

function genLoFiMarkers(ctx, sections) {
  const markers = [];

  function eqMarker(time, inst, eq, fade = false) {
    markers.push(marker(time, kMSEqH, inst, eq.high, fade));
    markers.push(marker(time, kMSEqM, inst, eq.mid, fade));
    markers.push(marker(time, kMSEqL, inst, eq.low, fade));
  }

  function getDefaultEq(inst) {
    const s = ctx.instSettings.get(inst);
    return eq(s.getEqHigh(), s.getEqMid(), s.getEqLow());
  }

  // Fade in at the start of the song.
  const endOfIntro = kSection * kBar;
  const isFaded = new Set();
  function introFade(inst, eq) {
    const i = inst.inst;
    if (isFaded.has(i)) return;
    isFaded.add(i);
    eqMarker(0, i, eq);
    eqMarker(endOfIntro, i, getDefaultEq(i), true);
  }
  const drumFadedEq = choose(kFadedEqSettings);
  for (d of ctx.drums) introFade(d, drumFadedEq);
  const chordFadedEq = choose(kFadedEqSettings);
  introFade(ctx.chordInst, chordFadedEq);
  markers.push(marker(0, kMSVol, 0, 0.5));
  markers.push(marker(endOfIntro - kBar - 0.25, kMSVol, 0, 0.5));
  markers.push(marker(endOfIntro + 0.25, kMSVol, 0, 1, true));

  // Fade out at the end of the song.
  const startOfFinalSection = (sections.length - 1) * kSection * kBar;
  const endOfSong = sections.length * kSection * kBar;
  eqMarker(startOfFinalSection, ctx.chordInst.inst, getDefaultEq(ctx.chordInst.inst));
  eqMarker(endOfSong - 4 * kBar, ctx.chordInst.inst, chordFadedEq, true);
  markers.push(marker(startOfFinalSection, kMSVol, 0, 1));
  markers.push(marker(endOfSong - 4 * kBar, kMSVol, 0, 0.5, true));
  markers.push(marker(endOfSong, kMSVol, 0, 0, true));

  // Apply marker effects.
  function effectMarkers(e) {
    if (e.volumePulses != 0) {
      const kBeats = [0, 2, 1, 3];
      for (let i = 0; i < e.volumePulses; ++i) {
        const t = e.t0 + kBeats[i];
        markers.push(marker(t, kMSVol, 0, 1));
        markers.push(marker(t + 0.25, kMSVol, 0, 0, true));
      }
      markers.push(marker(e.t0 + kBar, kMSVol, 0, 1));
    }
    function allInstrumentEq(t, eq, fade = false) {
      for (const i of ctx.allInst) {
        eqMarker(t, i.inst, eq === null ? getDefaultEq(i.inst) : eq, fade);
      }
    }
    if (e.eqFade == 1) {
      allInstrumentEq(e.t0, choose(kFadedEqSettings));
      allInstrumentEq(e.t0 + kBar - 0.25, null, true);
    } else if (e.eqFade == -1) {
      allInstrumentEq(e.t0, null);
      allInstrumentEq(e.t0 + kBar - 0.25, choose(kFadedEqSettings), true);
      allInstrumentEq(e.t0 + kBar, null);
    }
    if (e.detuneDescent) {
      for (const i of ctx.allInst) {
        const dd = ctx.instSettings.get(i.inst).getDetune();
        markers.push(marker(e.t0, kMSDetune, i.inst, dd));
        markers.push(marker(e.t0 + kBar - 1, kMSDetune, i.inst, -1200, true));
        markers.push(marker(e.t0 + kBar, kMSDetune, i.inst, dd));
      }
    }
    if (e.crossPan) {
      for (const i of ctx.allInst) {
        const dp = ctx.instSettings.get(i.inst).getPan();
        const p = randb() ? -1 : 1;
        markers.push(marker(e.t0, kMSPan, i.inst, dp));
        markers.push(marker(e.t0 + kBar - 1, kMSPan, i.inst, p, true));
        markers.push(marker(e.t0 + kBar, kMSPan, i.inst, dp));
      }
    }
    function dropInst(drop, insts) {
      if (!drop) return;
      for (const i of insts) {
        markers.push(marker(e.t0 + 0.25, kMSInstVol, i.inst, 1));
        markers.push(marker(e.t0 + 0.5, kMSInstVol, i.inst, 0, true));
        markers.push(marker(e.t0 + kBar, kMSInstVol, i.inst, 1));
      }
    }
    dropInst(e.dropDrums, ctx.drums);
    dropInst(e.dropMelody, [ctx.melody1Inst, ctx.melody2Inst]);
    dropInst(e.dropChords, [ctx.chordInst]);
    dropInst(e.dropBass, [ctx.bassInst]);
  }
  effectMarkers(ctx.effectIntro);
  effectMarkers(ctx.effectBridge);

  return markers;
}

class MarkerEffect {
  constructor(t0) {
    this.t0 = t0;
    this.volumePulses = 0;  // 0, 1, 2, 3, 4
    this.eqFade = 0;  // -1, 0, 1
    this.detuneDescent = false;
    this.crossPan = false;
    this.dropDrums = false;
    this.dropMelody = false;
    this.dropChords = false;
    this.dropBass = false;
  }
}

function genLoFiMarkerEffect(t) {
  const effect = new MarkerEffect(t);
  const type = randw([10, 3, 1, 2, 10]);
  if (type == 0) {
    effect.volumePulses = randi(4, 1);
  } else if (type == 1) {
    effect.eqFade = randb() ? -1 : 1;
  } else if (type == 2) {
    effect.detuneDescent = true;
  } else if (type == 3) {
    effect.crossPan = true;
  } else if (type == 4) {
    effect.dropDrums = randb();
    effect.dropMelody = randb();
    effect.dropChords = randb();
    effect.dropBass = randb();
  }
  return effect;
}

function genLoFi() {
  const key = randi(11);
  const ctx = {
    key: key,
    chords: genTwinChords(kSection, key),
    kick: choose(kDrumKicks),
    snare1: choose(kDrumSnares),
    snare2: choose(kDrumSnares),
    hat1: choose(kDrumHats),
    hat2: choose(kDrumHats),
    cymbal: choose(kDrumCymbals),
    bassInst: choose(kBassInst),
    chordInst: choose(kChordsInst),
    melody1Inst: choose(kMelodyInst),
    melody2Inst: choose(kMelodyInst),
    atmo: [choose(kDrumAll), choose(kDrumAll), choose(kDrumAll)],
    drums: null,
    tunedInst: null,
    allInst: null,
    effectIntro: genLoFiMarkerEffect((1 * kSection - 1) * kBar),
    effectBridge: genLoFiMarkerEffect((6 * kSection - 1) * kBar),
  };
  ctx.drums = new Set([ctx.kick, ctx.snare1, ctx.snare2, ctx.hat1, ctx.hat2, ctx.cymbal, ...ctx.atmo]);
  ctx.tunedInst = new Set([ctx.chordInst, ctx.bassInst, ctx.melody1Inst, ctx.melody2Inst]);
  ctx.allInst = new Set([...ctx.drums, ...ctx.tunedInst]);

  const chords = genLoFiChords(ctx);
  const bass = genLoFiBass(ctx);
  const melody1v1 = genLoFiMelody(ctx, ctx.melody1Inst, false, 0);
  const melody1v2 = genLoFiMelody(ctx, ctx.melody1Inst, false, 0);
  const melody1c = genLoFiMelody(ctx, ctx.melody1Inst, false, 1);
  const melody2 = genLoFiMelody(ctx, ctx.melody2Inst, true, 1);
  const melody2b = genLoFiMelody(ctx, ctx.melody2Inst, false, 0.5);

  const secIntro = merge(genLoFiDrums(ctx, 0), chords, bass, genLoFiAtmo(ctx));
  const secVerse1 = merge(genLoFiDrums(ctx, 0.5), chords, bass, melody1v1, genLoFiAtmo(ctx));
  const secChorus1 = merge(genLoFiDrums(ctx, 1), chords, bass, melody1c, melody2, genLoFiAtmo(ctx));
  const secVerse2 = merge(genLoFiDrums(ctx, 0.5), chords, bass, melody1v2, genLoFiAtmo(ctx));
  const secChorus2 = merge(genLoFiDrums(ctx, 1), chords, bass, melody1c, melody2, genLoFiAtmo(ctx));
  const secBridge = merge(genLoFiDrums(ctx, 0), bass, melody2b, genLoFiAtmo(ctx));
  const secChorus3 = merge(genLoFiDrums(ctx, 1), chords, bass, melody1c, melody2, genLoFiAtmo(ctx));
  const secOutro = merge(genLoFiDrums(ctx, 0), chords, bass, genLoFiAtmo(ctx));
  const secOutro2 = merge(chords, bass);

  const sections = [
      secIntro, secVerse1, secChorus1, secVerse2, secChorus2, secBridge,
      secChorus3, secOutro, secOutro2];
  const notes = joinSections(sections);

  // Dummy note after the end of the song to prevent loops.
  notes.push(drumNote(ctx.cymbal, sections.length * kSection * kBar + kBar, 0));

  // Instrument settings.
  genLoFiInstSettings(ctx);

  // Markers.
  const markers = genLoFiMarkers(ctx, sections);

  // Apply swing.
  const beatMidpoint = randb() ? 0.5 : 0.666666;
  const finalNotes = notes.map(n => n.swing(beatMidpoint));

  // Generate proto.
  const seq = new proto.Sequence();
  const seqSettings = new proto.SequenceSettings();
  seqSettings.setBpm(randi(100, 70));
  seq.setSettings(seqSettings);
  for (const [inst, settings] of ctx.instSettings) {
    seqSettings.getInstrumentsMap().set(inst, settings);
  }
  for (const m of markers) seq.addMarkers(m);
  for (const note of finalNotes) {
    const p = note.asProto;
    if (p !== null) seq.addNotes(p);
  }

  return seq;
}

function genChordsImpl(genChordsFn, len) {
  const key = randi(11);
  const chords = genChordsFn(len, key);
  const notes = [];
  for (let i = 0; i < chords.length; ++i) {
    const ch = chords[i].noteIndexes();
    for (let j = 0; j < ch.length; ++j) {
      notes.push(new Note(
          noteType(ch[j], 4), i * kBar, kBar, 41, j == 0 ? 1 : 0.5));
    }
  }
  const seq = new proto.Sequence();
  for (const note of notes) {
    const p = note.asProto;
    if (p !== null) seq.addNotes(p);
  }
  return seq;
}

function genShortChords() { return genChordsImpl(genChords, 4); }
function genLongChords() { return genChordsImpl(genTwinChords, 8); }

</script>
<style>
body {
  background-color: #212121;
  margin: 0;
}
#head {
  background-color: #424242;
  width: 100%;
  display: flex;
  justify-content: space-around;
  margin-bottom: 16px;
}
h1, #index {
  color: #ffc107;
  text-align: center;
  font-family: monospace;
  font-size: 42px;
  flex-grow: 1;
  padding: 16px;
  margin: 0;
}
#index {
  color: #ff5722;
  text-decoration: none;
  flex-grow: 0;
}
#wrap {
  padding: 0 16px;
  color: #f5f5f5;
  font-family: monospace;
  font-size: 16px;
}
a {
  color: #ff5722;
  font-family: monospace;
  font-size: 16px;
  cursor: pointer;
  text-decoration: underline;
}
</style>
<body>
<div id="head">
  <a id="index" href="index.html">&lt;</a>
  <h1>Dr. Jarvis</h1>
</div>
<div id="wrap">
  Hi, I'm Dr. Jarvis, a bot that generates random
  <a href="https://onlinesequencer.net/">Online Sequencer</a> songs. Click below
  and I'll write you a song and send you the sequence file. You can drag and
  drop that file into OS. Check out my
  <a href="https://onlinesequencer.net/members/65405">OS profile</a> to listen
  to some of my songs.
  <br/>
  <br/>
  <a onclick="generate(genShortChords)">Generate Short Chord Progression</a>
  <br/>
  <a onclick="generate(genLongChords)">Generate Long Chord Progression</a>
  <br/>
  <a onclick="generate(genLoFi)">Generate Lo-Fi</a>
</div>
</body>
</html>
