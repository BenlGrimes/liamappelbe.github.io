<!DOCTYPE html>
<html>
<head>
<script type="text/javascript">const exports={};</script>
<script src="https://onlinesequencer.net/resources/google-protobuf.js"></script>
<script src="https://onlinesequencer.net/proto/js/instrumentsettings.js"></script>
<script src="https://onlinesequencer.net/proto/js/marker.js"></script>
<script src="https://onlinesequencer.net/proto/js/note.js"></script>
<script src="https://onlinesequencer.net/proto/js/notetype.js"></script>
<script src="https://onlinesequencer.net/proto/js/sequence.js"></script>
<script src="https://onlinesequencer.net/proto/js/sequencesettings.js"></script>
<script type="text/javascript">

function saveBlob(filename, data, type) {
  var file = new Blob(data, {type: type});
  if (window.navigator.msSaveOrOpenBlob) {
    window.navigator.msSaveOrOpenBlob(file, filename);
  } else {
    var a = document.createElement('a');
    var url = URL.createObjectURL(file);
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(function() {
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    }, 0);
  }
}

function protoToBlob(seq) {
  try {
    return seq.serializeBinary();
  } catch (e) {
    console.log('Serializing sequence failed', e);
    console.log(seq.toObject());
    return null;
  }
}

function mod(x, y) { return ((x % y) + y) % y; }
function randb(p = 0.5) { return Math.random() < p; }
function randf(h = 1, l = 0) { return l + Math.random() * (h - l); }
function randi(h = 1, l = 0) { return Math.floor(randf(h + 1, l)); }
function randfq(h = 1) { return h * (Math.random() ** 2); }
function randBeat(h, l, q) { return randi(h * q - 1, l * q) / q; }
function randVol(h, l = 0.2) { return 2 ** randf(Math.log2(h), Math.log2(l)); }
function choose(array) { return array[randi(array.length - 1)]; }
function chooseq(array) { return array[Math.floor(randfq(array.length))]; }
function lerp(a, b, t) { return (1 - t) * a + t * b; }
function ilerp(a, b, y) { return (y - a) / (b - a); }
function linmap(a1, b1, y1, a2, b2) { return lerp(a2, b2, ilerp(a1, b1, y1)); }

const kAdjectives = ["Abrupt", "Acidic", "Adorable", "Adventurous", "Aggressive", "Agitated", "Alert", "Aloof", "Amiable", "Amused", "Annoyed", "Antsy", "Anxious", "Appalling", "Appetizing", "Apprehensive", "Arrogant", "Ashamed", "Astonishing", "Attractive", "Average", "Batty", "Beefy", "Bewildered", "Biting", "Bitter", "Bland", "Blushing", "Bored", "Brave", "Bright", "Broad", "Bulky", "Burly", "Charming", "Cheeky", "Cheerful", "Chubby", "Clean", "Clear", "Cloudy", "Clueless", "Clumsy", "Colorful", "Colossal", "Combative", "Comfortable", "Condemned", "Condescending", "Confused", "Contemplative", "Convincing", "Convoluted", "Cooperative", "Corny", "Costly", "Courageous", "Crabby", "Creepy", "Crooked", "Cruel", "Cumbersome", "Curved", "Cynical", "Dangerous", "Dashing", "Decayed", "Deceitful", "Deep", "Defeated", "Defiant", "Delicious", "Delightful", "Depraved", "Depressed", "Despicable", "Determined", "Dilapidated", "Diminutive", "Disgusted", "Distinct", "Distraught", "Distressed", "Disturbed", "Dizzy", "Drab", "Drained", "Dull", "Eager", "Ecstatic", "Elated", "Elegant", "Emaciated", "Embarrassed", "Enchanting", "Encouraging", "Energetic", "Enormous", "Enthusiastic", "Envious", "Exasperated", "Excited", "Exhilarated", "Extensive", "Exuberant", "Fancy", "Fantastic", "Fierce", "Filthy", "Flat", "Floppy", "Fluttering", "Foolish", "Frantic", "Fresh", "Friendly", "Frightened", "Frothy", "Frustrating", "Funny", "Fuzzy", "Gaudy", "Gentle", "Ghastly", "Giddy", "Gigantic", "Glamorous", "Gleaming", "Glorious", "Gorgeous", "Graceful", "Greasy", "Grieving", "Gritty", "Grotesque", "Grubby", "Grumpy", "Handsome", "Happy", "Harebrained", "Healthy", "Helpful", "Helpless", "High", "Hollow", "Homely", "Horrific", "Huge", "Hungry", "Hurt", "Icy", "Ideal", "Immense", "Impressionable", "Intrigued", "Irate", "Irritable", "Itchy", "Jealous", "Jittery", "Jolly", "Joyous", "Filthy", "Flat", "Floppy", "Fluttering", "Foolish", "Frantic", "Fresh", "Friendly", "Frightened", "Frothy", "Frustrating", "Funny", "Fuzzy", "Gaudy", "Gentle", "Ghastly", "Giddy", "Gigantic", "Glamorous", "Gleaming", "Glorious", "Gorgeous", "Graceful", "Greasy", "Grieving", "Gritty", "Grotesque", "Grubby", "Grumpy", "Handsome", "Happy", "Harebrained", "Healthy", "Helpful", "Helpless", "High", "Hollow", "Homely", "Horrific", "Huge", "Hungry", "Hurt", "Icy", "Ideal", "Immense", "Impressionable", "Intrigued", "Irate", "Irritable", "Itchy", "Jealous", "Jittery", "Jolly", "Joyous", "Juicy", "Jumpy", "Kind", "Lackadaisical", "Large", "Lazy", "Lethal", "Little", "Lively", "Livid", "Lonely", "Loose", "Lovely", "Lucent", "Lucky", "Ludicrous", "Macho", "Magnificent", "Mammoth", "Maniacal", "Massive", "Melancholy", "Melted", "Miniature", "Minute", "Mistaken", "Misty", "Moody", "Mortified", "Motionless", "Muddy", "Mysterious", "Narrow", "Nasty", "Naughty", "Nervous", "Nonchalant", "Nonsensical", "Nutritious", "Nutty", "Obedient", "Oblivious", "Obnoxious", "Odd", "Old Fashioned", "Outrageous", "Panicky", "Perfect", "Perplexed", "Petite", "Petty", "Plain", "Pleasant", "Poised", "Pompous", "Precious", "Prickly", "Proud", "Pungent", "Puny", "Quaint", "Quizzical", "Ratty", "Reassured", "Relieved", "Repulsive", "Responsive", "Ripe", "Robust", "Rotten", "Rotund", "Rough", "Round", "Salty", "Sarcastic", "Scant", "Scary", "Scattered", "Scrawny", "Selfish", "Shaggy", "Shaky", "Shallow", "Sharp", "Shiny", "Short", "Silky", "Silly", "Skinny", "Slimy", "Slippery", "Small", "Smarmy", "Smiling", "Smoggy", "Smooth", "Smug", "Soggy", "Solid", "Sore", "Sour", "Sparkling", "Spicy", "Splendid", "Spotless", "Square", "Stale", "Steady", "Steep", "Responsive", "Sticky", "Stormy", "Stout", "Straight", "Strange", "Strong", "Stunning", "Substantial", "Successful", "Succulent", "Superficial", "Superior", "Swanky", "Sweet", "Tart", "Tasty", "Teeny", "Tender", "Tense", "Terrible", "Testy", "Thankful", "Thick", "Thoughtful", "Thoughtless", "Tight", "Timely", "Tricky", "Trite", "Troubled", "Twittering", "Uneven", "Unsightly", "Upset", "Uptight", "Vast", "Vexed", "Victorious", "Virtuous", "Vivacious", "Vivid", "Wacky", "Weary", "Whimsical", "Whopping", "Wicked", "Witty", "Wobbly", "Wonderful", "Worried", "Yummy", "Zany", "Zealous", "Zippy"];
const kColors = ["Alizarin", "Amaranth", "Amber", "Amethyst", "Apricot", "Aqua", "Aquamarine", "Asparagus", "Auburn", "Azure", "Beige", "Bistre", "Black", "Blue", "Blue Green", "Blue Violet", "Bondi Blue", "Brass", "Bronze", "Brown", "Buff", "Burgundy", "Burnt Orange", "Burnt Sienna", "Burnt Umber", "Caput Mortuum", "Cardinal", "Carmine", "Carrot Orange", "Celadon", "Cerise", "Cerulean", "Champagne", "Charcoal", "Chartreuse", "Chestnut", "Chocolate", "Cinnabar", "Cinnamon", "Cobalt", "Copper", "Coral", "Corn", "Cornflower", "Cream", "Crimson", "Cyan", "Dandelion", "Denim", "Ecru", "Emerald", "Eggplant", "Falu Red", "Fern Green", "Firebrick", "Flax", "Forest Green", "French Rose", "Fuchsia", "Gamboge", "Gold", "Goldenrod", "Green", "Grey", "Han Purple", "Harlequin", "Heliotrope", "Indigo", "Ivory", "Jade", "Kelly Green", "Khaki", "Lavender", "Lawn Green", "Lemon", "Lemon Chiffon", "Lilac", "Lime", "Lime Green", "Linen", "Magenta", "Magnolia", "Malachite", "Maroon", "Mauve", "Midnight Blue", "Mint Green", "Misty Rose", "Moss Green", "Mustard", "Myrtle", "Navajo White", "Navy Blue", "Ochre", "Office Green", "Olive", "Olivine", "Orange", "Orchid", "Papaya Whip", "Peach", "Pear", "Periwinkle", "Persimmon", "Pine Green", "Pink", "Platinum", "Plum", "Powder Blue", "Puce", "Prussian Blue", "Pumpkin", "Purple", "Quartz Grey", "Raw Umber", "Razzmatazz", "Red", "Robin Egg Blue", "Rose", "Royal Blue", "Royal Purple", "Ruby", "Russet", "Rust", "Safety Orange", "Saffron", "Salmon", "Sandy Brown", "Sangria", "Sapphire", "Scarlet", "Sea Green", "Seashell", "Sepia", "Shocking Pink", "Silver", "Sky Blue", "Slate Grey", "Smalt", "Spring Bud", "Spring Green", "Steel Blue", "Tan", "Tangerine", "Taupe", "Teal", "Tawny", "Terra Cotta", "Thistle", "Tomato", "Turquoise", "Tyrian Purple", "Ultramarine", "Van Dyke Brown", "Vermilion", "Violet", "Viridian", "Wheat", "White", "Wisteria", "Xanthic", "Yellow", "Zucchini"];
const kAnimals = ["Aardvark", "Albatross", "Alligator", "Alpaca", "Ant", "Anteater", "Antelope", "Ape", "Armadillo", "Baboon", "Badger", "Barracuda", "Bat", "Bear", "Beaver", "Bee", "Bird", "Bison", "Boar", "Buffalo", "Butterfly", "Camel", "Caribou", "Cassowary", "Cat", "Caterpillar", "Cattle", "Chamois", "Cheetah", "Chicken", "Chimpanzee", "Chinchilla", "Chough", "Coati", "Cobra", "Cockroach", "Cod", "Cormorant", "Coyote", "Crab", "Crane", "Crocodile", "Crow", "Curlew", "Deer", "Dinosaur", "Dog", "Dogfish", "Dolphin", "Donkey", "Dotterel", "Dove", "Dragonfly", "Duck", "Dugong", "Dunlin", "Eagle", "Echidna", "Eel", "Eland", "Elephant", "Elephant Seal", "Elk", "Emu", "Falcon", "Ferret", "Finch", "Fish", "Flamingo", "Fly", "Fox", "Frog", "Gaur", "Gazelle", "Gerbil", "Giant Panda", "Giraffe", "Gnat", "Gnu", "Goat", "Goldfinch", "Goosander", "Goose", "Gorilla", "Goshawk", "Grasshopper", "Grouse", "Guanaco", "Guinea Fowl", "Guinea Pig", "Gull", "Hamster", "Hare", "Hawk", "Hedgehog", "Heron", "Herring", "Hippo", "Hornet", "Horse", "Hummingbird", "Hyena", "Ibex", "Ibis", "Jackal", "Jaguar", "Jay", "Jellyfish", "Kangaroo", "Kinkajou", "Koala", "Komodo Dragon", "Kouprey", "Kudu", "Lapwing", "Lark", "Lemur", "Leopard", "Lion", "Llama", "Lobster", "Locust", "Loris", "Louse", "Lyrebird", "Magpie", "Mallard", "Mammoth", "Manatee", "Mandrill", "Mink", "Mole", "Mongoose", "Monkey", "Moose", "Mouse", "Mosquito", "Narwhal", "Newt", "Nightingale", "Octopus", "Okapi", "Opossum", "Ostrich", "Otter", "Owl", "Oyster", "Panther", "Parrot", "Panda", "Partridge", "Peafowl", "Pelican", "Penguin", "Pheasant", "Pig", "Pigeon", "Polar Bear", "Pony", "Porcupine", "Porpoise", "Prairie Dog", "Quail", "Quelea", "Quetzal", "Rabbit", "Raccoon", "Ram", "Rat", "Raven", "Reindeer", "Rhinoceros", "Rook", "Salamander", "Salmon", "Sand Dollar", "Sandpiper", "Sardine", "Sea Lion", "Seahorse", "Seal", "Shark", "Sheep", "Shrew", "Skunk", "Sloth", "Snail", "Snake", "Spider", "Squid", "Squirrel", "Starling", "Stegosaurus", "Swan", "Tapir", "Tarsier", "Termite", "Tiger", "Toad", "Turkey", "Turtle", "Vicuna", "Wallaby", "Walrus", "Wasp", "Water Buffalo", "Weasel", "Whale", "Wolf", "Wolverine", "Wombat", "Wren", "Yak", "Zebra"];
function genName() { return `The ${choose(kAdjectives)} ${choose(kColors)} ${choose(kAnimals)}.sequence`; }

function generate(generator) {
  const blob = protoToBlob(generator());
  if (!blob) return;
  const name = genName() + '';
  saveBlob(name, [blob], 'application/octet-stream');
}

function noteTypeToProto(type) {
  return Object.keys(proto.NoteType).indexOf(type.replace('#', 'S'));
}

const kNoteTypeNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
function noteType(key, octave) {
  const i = mod(key, 12);
  const o = octave + Math.floor((key - i) / 12);  // In case key >= 12 or < 0.
  return kNoteTypeNames[i] + o;
}

// I'm representing note times and lengths as a float number of beats, whereas
// OS represents them as a number of quarter beats.
function noteTimeToOsFormat(time) { return 4 * time; }

class Note {
  constructor(type, time, len, inst, vol) {
    this.type = type;
    this.time = time;
    this.len = len;
    this.inst = inst;
    this.vol = vol;
  }

  shift(dt) {
    return new Note(this.type, this.time + dt, this.len, this.inst, this.vol);
  }

  swing(newMidpoint) {
    const intTime = Math.floor(this.time);
    const fractTime = this.time - intTime;
    const newTime = intTime + (fractTime < 0.5 ?
        linmap(0, 0.5, fractTime, 0, newMidpoint) :
        linmap(0.5, 1, fractTime, newMidpoint, 1));
    return new Note(this.type, newTime, this.len, this.inst, this.vol);
  }

  get asProto() {
    const np = new proto.Note();
    np.setType(noteTypeToProto(this.type));
    np.setTime(noteTimeToOsFormat(this.time));
    np.setLength(this.len > 0 ? noteTimeToOsFormat(this.len) : 1);
    np.setInstrument(this.inst);
    np.setVolume(this.vol);
    return np;
  }
}

const kMajorScale = [0, 2, 4, 5, 7, 9, 11];
const kMinorScale = [0, 2, 3, 5, 7, 8, 10];
class Chord {
  constructor(base, minor, seventh = false, ninth = false, sus4 = false) {
    this.base = base;
    this.minor = minor;
    this.seventh = seventh;
    this.ninth = ninth;
    this.sus4 = sus4;
  }

  _apply(n) { return n.map(i => (i + this.base - (this.minor ? 3 : 0))); }

  triadIndexes() { return this._apply([ 0, 4 - this.minor, 7 ]); }
  noteIndexes() {
    const n = [ 0, this.sus4 ? 5 : 4 - this.minor, 7 ];  // In semitones.
    if (this.seventh) n.push(11 - this.minor);
    if (this.ninth) n.push(14);
    return this._apply(n);
  }

  noteIndexesFolded() {
    const n = this.noteIndexes().map(i => mod(i - this.base, 12) + this.base);
    n.sort((x, y) => x - y);
    return n;
  }

  scale() { return this._apply(this.minor ? kMinorScale : kMajorScale); }
}

const kChordBases = [0, 5, 7];  // I, IV, V, in semitones
function genChords(n, key) {
  const chords = [new Chord(key, randb())];
  for (let i = 1; i < n; ++i) {
    chords.push(new Chord(
        choose(kChordBases) + key,
        randb(), randb(0.3), randb(0.2), randb(0.1)));
  }
  return chords;
}

function genTwinChords(n, key) {
  const m = Math.floor(n / 2);
  return merge(genChords(m, key), genChords(n - m, key));
}

function marker(time, setting, inst, value, blend = false) {
  var m = new proto.Marker();
  m.setTime(noteTimeToOsFormat(time));
  m.setSetting(setting);
  m.setInstrument(inst);
  m.setValue(value);
  m.setBlend(blend);
  return m;
}

const kMSVol = 8;

function drum(inst, type) { return { inst: inst, type: type }; }
function drumNote(drumType, time, vol = 1) {
  return new Note(drumType.type, time, 0, drumType.inst, vol);
}

const kDrumKicks = [
  drum(2, "B2"), drum(2, "C3"), drum(31, "B2"), drum(31, "C3"), drum(39, "G2"),
  drum(40, "G2"), drum(40, "G#2"), drum(36, "D#2"), drum(36, "E2"),
  drum(36, "F2"), drum(42, "D#2"), drum(42, "E2"), drum(42, "F2"),
];

const kDrumSnares = [
  drum(2, "G2"), drum(2, "D3"), drum(2, "C#3"), drum(2, "D#3"), drum(2, "E3"),
  drum(31, "G2"), drum(31, "C#3"), drum(31, "D3"), drum(31, "D#3"),
  drum(31, "E3"), drum(39, "A#2"), drum(39, "B2"), drum(39, "C3"),
  drum(39, "G#2"), drum(40, "A2"), drum(40, "A#2"), drum(40, "B2"),
  drum(40, "C3"), drum(40, "G#4"), drum(40, "A#4"), drum(36, "F#2"),
  drum(36, "G2"), drum(36, "G#2"), drum(36, "A2"), drum(36, "A#2"),
  drum(36, "G#3"), drum(42, "F#2"), drum(42, "G2"), drum(42, "G#2"),
  drum(42, "D#3"), drum(42, "E3"),
];

const kDrumHats = [
  drum(2, "F#3"), drum(2, "G#3"), drum(2, "A#3"), drum(2, "D#4"), drum(2, "F4"),
  drum(2, "B4"), drum(31, "F#3"), drum(31, "G#3"), drum(31, "A#3"),
  drum(31, "D#4"), drum(31, "F4"), drum(31, "B4"), drum(39, "A2"),
  drum(40, "D3"), drum(40, "E3"), drum(40, "F#3"), drum(40, "B3"),
  drum(40, "C#4"), drum(40, "F#4"), drum(40, "G4"), drum(36, "B2"),
  drum(36, "C3"), drum(42, "F3"), drum(42, "F#3"), drum(42, "G3"),
  drum(42, "G#3"), drum(42, "A#3"),
];

const kDrumCymbals = [
  drum(2, "C#4"), drum(2, "E4"), drum(2, "G4"), drum(2, "A4"), drum(31, "C#4"),
  drum(31, "E4"), drum(31, "G4"), drum(31, "A4"), drum(40, "A4"),
  drum(40, "F4"), drum(40, "D#4"), drum(40, "C4"), drum(40, "A3"),
  drum(42, "A3"),
];

const kDrumAll = function() {
  const ranges = [[2, 3, 63], [31, 3, 63], [39, 7, 12], [40, 7, 34],
                  [36, 3, 20], [42, 3, 22]];
  const n = [];
  for (const [inst, lo, hi] of ranges) {
    for (let i = lo; i <= hi; ++i) n.push(drum(inst, noteType(i, 2)));
  }
  return n;
}();

function chordInst(inst, susLen) { return { inst: inst, susLen: susLen }; }
const kChordsInst = [
  chordInst(0, 1), chordInst(1, 1), chordInst(3, 1), chordInst(4, 2),
  chordInst(6, 1), chordInst(7, 1), chordInst(8, 1), chordInst(11, 0.5),
  chordInst(12, 0.5), chordInst(13, 4), chordInst(14, 4), chordInst(15, 4),
  chordInst(16, 4), chordInst(18, 1), chordInst(20, 1), chordInst(23, 2),
  chordInst(24, 1), chordInst(25, 1), chordInst(26, 1), chordInst(30, 1),
  chordInst(32, 1), chordInst(34, 1), chordInst(35, 1), chordInst(38, 1),
  chordInst(41, 2),
];

function bassInst(inst) { return { inst: inst }; }
const kBassInst = [
  bassInst(21), bassInst(1), bassInst(5), bassInst(29), bassInst(32),
  bassInst(22), bassInst(33), bassInst(3), bassInst(6), bassInst(13),
  bassInst(14), bassInst(15), bassInst(16), bassInst(20), bassInst(24),
  bassInst(27), bassInst(30),
];

function melodyInst(inst) { return { inst: inst }; }
const kMelodyInst = [
  melodyInst(0), melodyInst(8), melodyInst(17), melodyInst(25), melodyInst(26),
  melodyInst(19), melodyInst(34), melodyInst(21), melodyInst(1), melodyInst(4),
  melodyInst(32), melodyInst(22), melodyInst(33), melodyInst(6), melodyInst(7),
  melodyInst(13), melodyInst(14), melodyInst(15), melodyInst(16),
  melodyInst(11), melodyInst(18), melodyInst(20), melodyInst(23),
  melodyInst(41),
];

const kBar = 4;
const kSection = 8;

function lowestSetBit(x) { return x & -x; }
function beatEmphasis(t) {
  const kBeatRes = 8;
  const i = Math.floor(0.5 + mod(t, kBar) * kBeatRes);
  if (i == 0) return 1;
  return Math.log2(lowestSetBit(i)) / Math.log2(kBar * kBeatRes);
}

function chordsToNotes(chords, key = 0, octave = 4, instrument = 41) {
  const notes = [];
  for (let i = 0; i < chords.length; ++i) {
    for (const j of chords[i].noteIndexes(key)) {
      notes.push(new Note(noteType(j, octave), i * kBar, kBar, instrument, 1));
    }
  }
  return notes;
}

function merge(...args) {
  out = [];
  for (let i = 0; i < args.length; ++i) {
    for (const n of args[i]) out.push(n);
  }
  return out;
}

function joinBars(args) {
  out = [];
  for (let i = 0; i < args.length; ++i) {
    for (const n of args[i]) out.push(n.shift(i * kBar));
  }
  return out;
}

function joinSections(args) {
  out = [];
  for (let i = 0; i < args.length; ++i) {
    for (const n of args[i]) out.push(n.shift(i * kBar * kSection));
  }
  return out;
}

function genEmphasisBar(p0, p1, fn) {
  const dt = 0.25;
  for (let t = 0; t < kBar; t += dt) {
    const e = beatEmphasis(t);
    if (randb(lerp(p0, p1, e))) fn(t, e);
  }
}

function genLoFiDrumsOneBar(ctx, first) {
  const notes = [
    drumNote(ctx.kick, 0),
    drumNote(ctx.snare1, 1),
    drumNote(ctx.kick, randb() ? 2 : 2.5),
    drumNote(ctx.snare1, randb(0.7) ? 3 : 3.5),
  ];

  if (first) notes.push(drumNote(ctx.cymbal, 0));

  genEmphasisBar(0.1, 0.8,
      (t, e) => notes.push(drumNote(ctx.kick, t, e * randf(1.2, 0.8))));
  genEmphasisBar(0.1, 0.8,
      (t, e) => notes.push(drumNote(ctx.snare2, t, e * randf(0.8, 0.5))));

  for (let i = 0; i < kBar; ++i) {
    notes.push(drumNote(ctx.hat1, i + 0.5));
    notes.push(drumNote(ctx.hat2, i + 0.25, randVol(0.5)));
    notes.push(drumNote(ctx.hat2, i + 0.75, randVol(0.5)));
  }
  return notes;
}

function genLoFiDrumsOneBarBreak(ctx) {
  const notes = [];
  genEmphasisBar(0.1, 0.8,
      (t, e) => notes.push(drumNote(ctx.kick, t, e * randf(1.2, 0.8))));
  genEmphasisBar(0.1, 0.8,
      (t, e) => notes.push(drumNote(ctx.snare1, t, e * randf(1.2, 0.8))));
  genEmphasisBar(0.1, 0.8,
      (t, e) => notes.push(drumNote(ctx.snare2, t, e * randf(0.8, 0.5))));
  for (let i = 0; i < kBar; ++i) {
    notes.push(drumNote(ctx.hat1, i + 0.5));
    notes.push(drumNote(ctx.hat2, i + 0.25, randVol(0.5)));
    notes.push(drumNote(ctx.hat2, i + 0.75, randVol(0.5)));
  }
  return notes;
}

function genLoFiDrums(ctx) {
  const bars = [];
  for (let i = 0; i < kSection - 1; ++i) {
    bars.push(genLoFiDrumsOneBar(ctx, i == 0));
  }
  bars.push(genLoFiDrumsOneBarBreak(ctx));
  return joinBars(bars);
}

function chordVoice(idx, octh = 0, octl = 0) {
  return 12 * randi(octh, octl) + idx;
}

kPossibleArpDirs = 4;
function arpIndex(x, n, d) {
  if (d == 0 || d == 1) {
    // Saw wave.
    return mod(d == 0 ? x : -1 - x, n);
  } else if (d == 2 || d == 3) {
    // Triangle wave.
    const m = n - 1;
    const y = mod(d == 2 ? x : x + m, 2 * m);
    return y < n ? y : m - 1 - mod(y, n);
  }
}

function genLoFiChords(ctx) {
  const notes = [];
  const style = randi(1);
  if (style == 0) {
    // Plain chords, optionally decimated.
    const dec = randb(0.3);
    const len = dec ? Math.min(2, ctx.chordInst.susLen) : ctx.chordInst.susLen;
    for (let i = 0; i < ctx.chords.length; ++i) {
      const ch = ctx.chords[i].noteIndexesFolded();
      for (let j = 0; j < ch.length; ++j) {
        for (let t = 0; t < kBar; t += len) {
          if (j != 0 && dec && randb(0.2)) continue;
          notes.push(new Note(
              noteType(chordVoice(ch[j], 2), 3), i * kBar + t, len,
              ctx.chordInst.inst, j == 0 ? 1 : randf(1, 0.5)));
        }
      }
    }
  } else if (style == 1) {
    // Arpegios, in a random direction.
    const dir = randi(kPossibleArpDirs - 1);
    const oct = randi(2, 1);
    const len = choose([0.25, 0.5, 1]);
    for (let i = 0; i < ctx.chords.length; ++i) {
      const ch = ctx.chords[i].noteIndexesFolded();
      for (let t = 0, j = 0; t < kBar; t += len, ++j) {
        const k = arpIndex(j, ch.length * oct, dir);
        notes.push(new Note(
            noteType(ch[mod(k, ch.length)], 3 + Math.floor(k / ch.length)),
            i * kBar + t, len, ctx.chordInst.inst,
            mod(k, ch.length) == 0 ? 1 : randf(1, 0.5)));
      }
    }
  }
  return notes;
}

function genLoFiBass(ctx) {
  const notes = [];
  const len = 0.5;
  for (let i = 0; i < ctx.chords.length; ++i) {
    const ch = ctx.chords[i].triadIndexes();
    for (let t = 0; t < kBar; t += len) {
      if (t == 0 || randb(0.4)) {
        notes.push(new Note(
            noteType(mod(choose(ch), 12), 2), i * kBar + t, len,
            ctx.bassInst.inst, randf(1, 0.5)));
      }
    }
  }
  return notes;
}

function genLoFiMelody(ctx, secondary) {
  const notes = [];
  const len = secondary ? 0.5 : 0.25;
  const inst = secondary ? ctx.melody2Inst.inst : ctx.melody1Inst.inst;
  const oct = secondary ? 6 : 5;
  const vol = secondary ? 0.6 : 1;
  let de = 0;
  let pj = null;
  const all = ctx.chords[0].scale();
  function wrap(j) {
    const mj = mod(j, 12);
    if (pj === null) return mj;
    if (pj - mj > 7) return mj + 12;
    if (mj - pj > 7) return mj - 12;
    return mj;
  }
  for (let i = 0; i < ctx.chords.length; ++i) {
    const tri = ctx.chords[i].triadIndexes();
    for (let t = 0; t < kBar; t += len) {
      const e = beatEmphasis(t) + de;
      if (randb(lerp(0.2, 1, e))) {
        const chooseTriadNote = secondary ? false : randb(lerp(0.2, 1.2, e));
        let j = chooseTriadNote ? choose(tri) : choose(all);
        if (!secondary) de = chooseTriadNote ? 0 : de + 0.2;
        notes.push(new Note(
            noteType(wrap(j), oct), i * kBar + t, len,
            inst, lerp(0.6, 1, e) * vol));
        if (chooseTriadNote && randb(0.3)) {
          notes.push(new Note(
              noteType(wrap(choose(tri)), oct), i * kBar + t, len,
              inst, lerp(0.6, 1, e) * vol));
        }
        pj = j;
      }
    }
  }
  return notes;
}

function genLoFiAtmo(ctx) {
  const notes = [];
  const dt = 0.25;
  for (let k = 0; k < kSection; ++k) {
    const end = randBeat(kBar * kSection, 0, 2);
    const start = Math.max(0, end - randBeat(1.5, 0.25, 4));
    for (let t = start; t <= end; t += dt) {
      const vol = 0.8 * (t == end ? 1 : Math.min(1, beatEmphasis(t) + 0.4));
      const n = choose(ctx.atmo);
      notes.push(new Note(n.type, t, dt, n.inst, vol));
    }
  }
  return notes;
}

function genLoFiInstSettings(ctx) {
  const instSettings = new Map();
  function settings(inst) {
    if (!instSettings.has(inst)) {
      const settings = new proto.InstrumentSettings();
      instSettings.set(inst, settings);
      settings.setVolume(1);
    }
    return instSettings.get(inst);
  }

  // Panning.
  settings(ctx.chordInst.inst).setPan(randf(-0.3, 0.3));
  const m1pan = randf(-0.8, 0.8);
  settings(ctx.melody1Inst.inst).setPan(m1pan);
  settings(ctx.melody2Inst.inst).setPan(-m1pan);
  for (const a of ctx.atmo) settings(a.inst).setPan(randf(-1, 1));

  // Overwrite panning on drums and bass, in case they're the same as one of the
  // other instruments.
  settings(ctx.kick.inst).setPan(0);
  settings(ctx.snare1.inst).setPan(0);
  settings(ctx.snare2.inst).setPan(0);
  settings(ctx.hat1.inst).setPan(0);
  settings(ctx.hat2.inst).setPan(0);
  settings(ctx.cymbal.inst).setPan(0);
  settings(ctx.bassInst.inst).setPan(0);

  // Drum detunes.
  function randomDetune(inst) { settings(inst).setDetune(randf(-1200, 1200)); }
  randomDetune(ctx.kick.inst);
  randomDetune(ctx.snare1.inst);
  randomDetune(ctx.snare2.inst);
  randomDetune(ctx.hat1.inst);
  randomDetune(ctx.hat2.inst);
  randomDetune(ctx.cymbal.inst);
  for (const a of ctx.atmo) randomDetune(a.inst);

  return instSettings;
}

function genLoFiMarkers(ctx, sections) {
  const markers = [];

  // Fade out at the end of the song.
  const endOfSong = sections.length * kSection * kBar;
  markers.push(marker(endOfSong - 4 * kBar, kMSVol, 0, 1));
  markers.push(marker(endOfSong, kMSVol, 0, 0, true));

  return markers;
}

function genLoFi() {
  // TODO:
  //  - Eq settings
  //  - Fade markers
  //  - Break markers
  //  - Eq markers

  const key = randi(11);
  const ctx = {
    key: key,
    chords: genTwinChords(kSection, key),
    kick: choose(kDrumKicks),
    snare1: choose(kDrumSnares),
    snare2: choose(kDrumSnares),
    hat1: choose(kDrumHats),
    hat2: choose(kDrumHats),
    cymbal: choose(kDrumCymbals),
    bassInst: choose(kBassInst),
    chordInst: choose(kChordsInst),
    melody1Inst: choose(kMelodyInst),
    melody2Inst: choose(kMelodyInst),
    atmo: [choose(kDrumAll), choose(kDrumAll), choose(kDrumAll)],
  };

  const chords = genLoFiChords(ctx);
  const bass = genLoFiBass(ctx);
  const melody1v1 = genLoFiMelody(ctx, false);
  const melody1v2 = genLoFiMelody(ctx, false);
  const melody1c = genLoFiMelody(ctx, false);
  const melody2 = genLoFiMelody(ctx, true);

  const secIntro = merge(genLoFiDrums(ctx), chords, bass, genLoFiAtmo(ctx));
  const secVerse1 = merge(genLoFiDrums(ctx), chords, bass, melody1v1, genLoFiAtmo(ctx));
  const secChorus1 = merge(genLoFiDrums(ctx), chords, bass, melody1c, melody2, genLoFiAtmo(ctx));
  const secVerse2 = merge(genLoFiDrums(ctx), chords, bass, melody1v2, genLoFiAtmo(ctx));
  const secChorus2 = merge(genLoFiDrums(ctx), chords, bass, melody1c, melody2, genLoFiAtmo(ctx));
  const secBridge = merge(genLoFiDrums(ctx), bass, melody2, genLoFiAtmo(ctx));
  const secChorus3 = merge(genLoFiDrums(ctx), chords, bass, melody1c, melody2, genLoFiAtmo(ctx));
  const secOutro = merge(genLoFiDrums(ctx), chords, bass, genLoFiAtmo(ctx));
  const secOutro2 = merge(chords, bass);

  const sections = [
      secIntro, secVerse1, secChorus1, secVerse2, secChorus2, secBridge,
      secChorus3, secOutro, secOutro2];
  const notes = joinSections(sections);

  // Dummy note after the end of the song to prevent loops.
  notes.push(drumNote(ctx.cymbal, sections.length * kSection * kBar + kBar, 0));

  // Instrument settings.
  const instSettings = genLoFiInstSettings(ctx);

  // Markers.
  const markers = genLoFiMarkers(ctx, sections);

  // Apply swing.
  const beatMidpoint = randb() ? 0.5 : 0.666666;
  const finalNotes = notes.map(n => n.swing(beatMidpoint));

  // Generate proto.
  const seq = new proto.Sequence();
  const seqSettings = new proto.SequenceSettings();
  seqSettings.setBpm(randi(100, 70));
  seq.setSettings(seqSettings);
  for (const [inst, settings] of instSettings) {
    seqSettings.getInstrumentsMap().set(inst, settings);
  }
  for (const note of finalNotes) seq.addNotes(note.asProto);
  for (const m of markers) seq.addMarkers(m);

  return seq;
}

function genChordsImpl(genChordsFn, len) {
  const key = randi(11);
  const chords = genChordsFn(len, key);
  const notes = [];
  for (let i = 0; i < chords.length; ++i) {
    const ch = chords[i].noteIndexes();
    for (let j = 0; j < ch.length; ++j) {
      notes.push(new Note(
          noteType(ch[j], 4), i * kBar, kBar, 41, j == 0 ? 1 : 0.5));
    }
  }
  const seq = new proto.Sequence();
  for (const note of notes) seq.addNotes(note.asProto);
  return seq;
}

function genShortChords() { return genChordsImpl(genChords, 4); }
function genLongChords() { return genChordsImpl(genTwinChords, 8); }

</script>
<style>
body {
  background-color: #212121;
  margin: 0;
}
#head {
  background-color: #424242;
  width: 100%;
  display: flex;
  justify-content: space-around;
  margin-bottom: 16px;
}
h1, #index {
  color: #ffc107;
  text-align: center;
  font-family: monospace;
  font-size: 42px;
  flex-grow: 1;
  padding: 16px;
  margin: 0;
}
#index {
  color: #ff5722;
  text-decoration: none;
  flex-grow: 0;
}
#wrap {
  padding: 0 16px;
  color: #f5f5f5;
  font-family: monospace;
  font-size: 16px;
}
a {
  color: #ff5722;
  font-family: monospace;
  font-size: 16px;
  cursor: pointer;
  text-decoration: underline;
}
</style>
<body>
<div id="head">
  <a id="index" href="../index.html">&lt;</a>
  <h1>Dr. Jarvis</h1>
</div>
<div id="wrap">
  Hi, I'm Dr. Jarvis, a bot that generates random
  <a href="https://onlinesequencer.net/">Online Sequencer</a> songs. Click below
  and I'll write you a song and send you the sequence file. You can drag and
  drop that file into OS. Check out my
  <a href="https://onlinesequencer.net/members/65405">OS profile</a> to listen
  to some of my songs.
  <br/>
  <br/>
  <a onclick="generate(genShortChords)">Generate Short Chord Progression</a>
  <br/>
  <a onclick="generate(genLongChords)">Generate Long Chord Progression</a>
  <br/>
  <a onclick="generate(genLoFi)">Generate Lo-Fi</a>
</div>
</body>
</html>
