<!DOCTYPE html>
<html>
<head>
<title>Metronome</title>
<link rel="icon" href="res/favicon.ico">
<script type="text/javascript">

function lerp(t, x0, x1) {
  return t * (x1 - x0) + x0;
}

function unlerp(x, x0, x1) {
  return (x - x0) / (x1 - x0);
}

function wrap(x) {
  return ((x % 1) + 1) % 1;
}

function cubicEaseOut(x) {
  return (3 - x * x) * x / 2;
}

async function asyncXMLHttpRequest(url, type) {
  return new Promise((resolve, reject) => {
    const request = new XMLHttpRequest();
    request.open('GET', url, true);
    request.responseType = type;
    request.onload = () => resolve(request.response);
    request.onerror = reject;
    request.send();
  });
}

class LiveValue {
  constructor(id, format) {
    this.value = null;
    this._input = document.getElementById(id);
    this._view = document.getElementById(`${id}_view`);
    this._format = format;
    this.update();
  }

  update() {
    this.value = parseFloat(this._input.value);
    this._view.innerText = this._format(this.value);
    return this.value;
  }
}

class Metronome {
  constructor() {
    this.spb = null;
    this.swing = null;
    this.nextTickTime = 0;
    this.nextTick = null;
    this.lastBeatTime = 0;
    this.nextBeatTime = 0;
    this.tickSound = null;
    this.ctx = new AudioContext();
    window.setTimeout(async () => {
      const response = await asyncXMLHttpRequest(
          'https://tiusic.com/res/tick.wav', 'arraybuffer');
      this.tickSound = await this.ctx.decodeAudioData(response);
    }, 0);
  }

  play() {
    this.ctx.resume();
    this.nextTick = 0;
    this.nextTickTime = this.ctx.currentTime + 0.1;
    this.nextBeatTime = this.nextTickTime;
    this.lastBeatTime = this.nextBeatTime - (60 / this.bpm);
    this._update();
  }

  stop() {
    this.ctx.suspend();
    this.nextTick = null;
  }

  update(bpm, swing) {
    this.bpm = bpm;
    this.swing = swing;
    this._update();
  }

  isPlaying() {
    return this.nextTick != null;
  }

  _update() {
    if (!this.isPlaying()) return;

    // Schedule the next tick if it's going to happen in the 0.1 seconds, and
    // then calculate when the following tick will be. Due to our BPM limit of
    // 300, the shortest possible gap is 0.2 seconds, so the following tick
    // should be outside our scheduling horizon.
    const t = this.ctx.currentTime;
    if (this.nextTickTime > t + 0.1) {
      // Too distant. Wait.
      return;
    }

    // Play the tick.
    const downBeat = this.nextTick % 2 == 0;
    const gainNode = this.ctx.createGain();
    gainNode.gain.value = downBeat ? 1.0 : 0.1;
    const tickNode = this.ctx.createBufferSource();
    tickNode.detune.value = downBeat ? 1000 : 500;
    tickNode.buffer = this.tickSound;
    tickNode.connect(gainNode);
    gainNode.connect(this.ctx.destination);
    tickNode.start(this.nextTickTime);

    // If this was a down beat, update the beat times.
    if (downBeat) {
      this.lastBeatTime = this.nextBeatTime;
      this.nextBeatTime = this.lastBeatTime + (60 / this.bpm);
    }

    // Calculate when the following tick will be.
    ++this.nextTick;
    const f = downBeat ? lerp(this.swing / 100, 1 / 2, 2 / 3) : 1;
    this.nextTickTime = lerp(f, this.lastBeatTime, this.nextBeatTime);
  }

  beatFrac() {
    return wrap(unlerp(
        this.ctx.currentTime, this.lastBeatTime, this.nextBeatTime));
  }
}

const kPlayButton = "M1 12C1 5.92487 5.92487 1 12 1C18.0751 1 23 5.92487 23 12C23 18.0751 18.0751 23 12 23C5.92487 23 1 18.0751 1 12ZM9.64109 7.19733C9.14132 6.89192 8.5 7.2516 8.5 7.83729V16.1627C8.5 16.7484 9.14132 17.1081 9.64109 16.8027L16.4528 12.64C16.9313 12.3475 16.9313 11.6525 16.4528 11.36L9.64109 7.19733Z";
const kPauseButton = "M1 12C1 5.92487 5.92487 1 12 1C18.0751 1 23 5.92487 23 12C23 18.0751 18.0751 23 12 23C5.92487 23 1 18.0751 1 12ZM8 8C8 7.44772 8.44772 7 9 7H10C10.5523 7 11 7.44772 11 8V16C11 16.5523 10.5523 17 10 17H9C8.44772 17 8 16.5523 8 16V8ZM13 8C13 7.44772 13.4477 7 14 7H15C15.5523 7 16 7.44772 16 8V16C16 16.5523 15.5523 17 15 17H14C13.4477 17 13 16.5523 13 16V8Z";

function emptyDiv(n) {
  while (n.hasChildNodes()) n.removeChild(n.lastChild);
}

function makeElementNS(ns, tag, parent, attr) {
  const node = document.createElementNS(ns, tag);
  if (parent != null) parent.appendChild(node);
  for (const [k, v] of attr) node.setAttribute(k, v);
  return node;
}

function makeButtonSvg(path) {
  const ns = 'http://www.w3.org/2000/svg';
  const svg = makeElementNS(ns, 'svg', null, [['viewBox', '0 0 24 24']]);
  makeElementNS(ns, 'path', svg, [
    ['fill-rule', 'evenodd'], ['clip-rule', 'evenodd'],
    ['fill', 'var(--svgcolor)'], ['d', path],
  ]);
  return svg;
}

function onLoad() {
  const bpm = new LiveValue('bpm', x => `${x}`);
  const swing = new LiveValue('swing', x => `${x}%`);

  const svgPlay = makeButtonSvg(kPlayButton);
  const svgPause = makeButtonSvg(kPauseButton);

  const setupToggle = (id, onChange) => {
    const button = document.getElementById(id);
    let value = true;
    const update = () => {
      value = !value;
      onChange(button, value);
    };
    button.addEventListener('click', update);
    update();
  };

  const metronome = new Metronome();

  setupToggle('play_button', (playButton, value) => {
    emptyDiv(playButton);
    if (value) {
      playButton.appendChild(svgPause);
      metronome.play();
    } else {
      playButton.appendChild(svgPlay);
      metronome.stop();
    }
  });

  const bgColor = (playing, x) => {
    if (!playing) return '#212121';
    const g = Math.floor(lerp(cubicEaseOut(x), 0x42, 0x21));
    return `rgb(${g}, ${g}, ${g})`;
  };

  const frame = () => {
    const bpmVal = bpm.update();
    const swingVal = swing.update();
    metronome.update(bpmVal, swingVal);
    const clr = bgColor(metronome.isPlaying(), metronome.beatFrac());
    document.body.style.setProperty('background-color', clr);
    window.requestAnimationFrame(frame);
  };
  frame();
}
window.addEventListener('load', onLoad);
</script>
<style>
body {
  background-color: #212121;
  margin: 0;
}
#head {
  background-color: #424242;
  width: 100%;
  display: flex;
  justify-content: space-around;
  margin-bottom: 16px;
}
h1, #index {
  color: #ffc107;
  text-align: center;
  font-family: monospace;
  font-size: 42px;
  flex-grow: 1;
  padding: 16px;
  margin: 0;
}
#index {
  color: #ff5722;
  text-decoration: none;
  flex-grow: 0;
}
#wrap {
  padding: 0 16px;
  color: #f5f5f5;
  font-family: monospace;
  font-size: 32px;
  display: flex;
  flex-direction: column;
  align-items: center;
}
.row {
  display: flex;
  flex-direction: row;
}
.view {
  width: 96px;
}
.label {
  width: 128px;
}
input {
  width: 196px;
}
#play_button {
  display: block;
  width: 128px;
  height: 128px;
  font-weight: bold;
  cursor: pointer;
}
#play_button svg path {
  --svgcolor: #ffc107;
}
#play_button:hover svg path {
  --svgcolor: #f5f5f5;
}
</style>
</head>
<body>
<div id="head">
  <a id="index" href="index.html">&lt;</a>
  <h1>Metronome</h1>
</div>
<div id="wrap">
  <div class="row">
    <span class="label">BPM:</span>
    <span class="view" id="bpm_view"></span>
    <input type="range" id="bpm" min="30" max="300" step="1" value="60"/>
  </div>
  <div class="row">
    <span class="label">Swing:</span>
    <span class="view" id="swing_view"></span>
    <input type="range" id="swing" min="0" max="150" step="5" value="0"/>
  </div>
  <div class="row">
    <span id="play_button"></span>
  </div>
</div>
</body>
</html>
