<!DOCTYPE html>
<html>
<head>
<title>Graph Game</title>
<link rel="icon" href="res/favicon.ico">
<script type="text/javascript">

// Config
const kLinkFactor = 0.5;
const kFastFreeze = true;
const kRepelForce = kFastFreeze ? -0.001 : -0.0001;
const kAttractForce = kFastFreeze ? 0.1 : 0.01;
const kDamping = kFastFreeze ? 0.8 : 0.2;
const kUpdateItrs = kFastFreeze ? 10 : 1;
const kFreezeThreshold = kFastFreeze ? 1e-4 : 1e-6;

const kAiTestingMode = false;
const kAiTestingRuns = 1000;
const kAiTestingPhils = ['Foolish AI', 'Easy AI', 'Easy H1 AI', 'Easy H2 AI', 'Easy H3 AI', 'Medium AI', 'Medium H1 AI', 'Medium H2 AI', 'Medium H3 AI'];
const kAiTestingEmmys = kAiTestingPhils;
const kAiTestingGraphSize = 12;
const kAiDefaultHeurVer = kAiTestingMode ? 0 : 3;

const kAiHeurRecursive = 3;
const kAiHeurDegree = 1;
const kAiHeurAdjClr = 1;
const kAiHeurColor = 10;
const kAiColorCalcRand = 1;

const tau = 2 * Math.PI;

function randInt(n) {
  return Math.floor(n * Math.random());
}

function randPos() {
  return 2 * Math.random() - 1;
}

function swap(a, i, j) {
  const x = a[i];
  a[i] = a[j];
  a[j] = x;
}

async function wait(seconds) {
  return new Promise((resolve, reject) => {
    window.setTimeout(resolve, 1000 * seconds);
  });
}

function randPermutation(n) {
  const a = [];
  for (let i = 0; i < n; ++i) a.push(i);
  for (let i = 0; i < n; ++i) {
    swap(a, i, randInt(n - i) + i);
  }
  return a;
}

function clamp(x, hi = 1, lo = 0) {
  return x <= lo ? lo : x >= hi ? hi : x;
}

function fmod(x, y = 1) {
  const z = x / y;
  return (z - Math.floor(z)) * y;
}

function popSwap(a, i) {
  const x = a[i];
  const y = a.pop();
  if (i < a.length) a[i] = y;
  return x;
}

function rgb2str(r, g, b) {
  const ch = x => {
    const s = Math.floor(clamp(x * 256, 255)).toString(16);
    if (s.length > 2) return 'ff';
    if (s.length == 0) return '00';
    if (s.length == 1) return '0' + s;
    return s;
  }
  return `#${ch(r)}${ch(g)}${ch(b)}ff`;
}

function hsv2rgb(h, s = 1, v = 1) {
  const i = fmod(h) * 6.0;
  const c = v * s;
  const m = v - c;
  const x = c * (1 - Math.abs(fmod(i, 2) - 1)) + m;
  const d = c + m;
  if (i < 1) return rgb2str(d, x, m);
  if (i < 2) return rgb2str(x, d, m);
  if (i < 3) return rgb2str(m, d, x);
  if (i < 4) return rgb2str(m, x, d);
  if (i < 5) return rgb2str(x, m, d);
  return rgb2str(d, m, x);
}

function newElement(type, parent, classes = [], text = null) {
  const n = document.createElement(type);
  if (text != null) n.innerText = text;
  for (const cls of classes) n.classList.add(cls);
  if (parent != null) parent.appendChild(n);
  return n;
}

function newDiv(parent, classes = [], text = null) {
  return newElement('div', parent, classes, text);
}

function newSelect(parent, classes = [], options = []) {
  const sel = newElement('select', parent, classes);
  for (const opt of options) {
    newElement('option', sel, [], opt).setAttribute('value', opt);
  }
  return sel;
}

function newSlider(parent, classes = [], min = 0, max = 100, step = 1) {
  const slider = newElement('input', parent, classes);
  slider.setAttribute('type', 'range');
  slider.setAttribute('min', min);
  slider.setAttribute('max', max);
  slider.setAttribute('step', step);
  slider.setAttribute('value', min);
  return slider;
}

function newCanvas(parent, classes = [], width = 100, height = 100) {
  const slider = newElement('canvas', parent, classes);
  slider.setAttribute('width', width);
  slider.setAttribute('height', height);
  return slider;
}

function newBtn(
    parent, classes = [], text = null, onclick = null) {
  const btn = newDiv(parent, classes, text);
  if (onclick != null) btn.addEventListener('click', onclick);
  return btn;
}

function emptyDiv(n) {
  while (n.hasChildNodes()) n.removeChild(n.lastChild);
}

let game = null;
function onLoad() {
  game = new Game(document.getElementById('game'));
  if (kAiTestingMode) {
    game.transitionToAiTestingMode();
  } else {
    game.transitionToSetup();
  }
}
window.addEventListener('load', onLoad);

class Move {
  constructor(nodeId, color) {
    this.nodeId = nodeId;
    this.color = color;
  }
}

class HumanCtrl {
  constructor(graph, isPhil, ui, doMove) {
    newDiv(ui, ['game-status'], `It's ${isPhil ? 'Phil' : 'Emmy'}'s turn`);
    newDiv(ui, [], '1) Choose a color ⮟');
    const clrRow = newDiv(ui, ['game-ctrl-clr-row']);
    const clrBtns = [];
    let selectedClr = null;
    const setClr = i => {
      for (const btn of clrBtns) btn.classList.remove('selected');
      selectedClr = (selectedClr == i) ? null : i;
      if (selectedClr != null) clrBtns[selectedClr].classList.add('selected');
    };
    for (let i = 0; i < graph.numColors; ++i) {
      const btn = newBtn(clrRow, ['game-ctrl-clr'], null, () => setClr(i));
      btn.style.backgroundColor = graph.colors[i];
      clrBtns.push(btn);
    }
    newDiv(ui, [], '2) Choose an empty node ⮞');
    const applyRow = newDiv(ui, ['game-ctrl-row']);
    newDiv(applyRow, [], '3)');
    let error = null;
    const fillBtn = newBtn(applyRow, ['game-ctrl-fill'], '[FILL NODE]', () => {
      error.innerText = '';
      if (selectedClr == null) {
        error.innerText = 'You have to choose a color first.';
      } else if (graph.selectedNode == null) {
        error.innerText = 'You have to choose a node first.';
      } else {
        const move = new Move(graph.selectedNode, selectedClr);
        if (!graph.isValidMove(move)) {
          error.innerText =
              'The node must be a different color to all its neighbors.';
        } else {
          setClr(null);
          doMove(move);
        }
      }
    });
    error = newDiv(ui, ['game-ctrl-error']);
  }

  onTurn() {}
}

function aiCalculateScoreImplForPhil(graph, heurVer, isColorCalc) {
  const status = graph.getStatus();
  if (status != -1) {
    return status == 1 ? Infinity : -Infinity;
  }
  if (heurVer == 0) return 0.1 * Math.random();

  // Sum the score of each node. Node score is proportional to its degree. If a
  // node is full or has no empty neighbors, that score is positive. Otherwise
  // it's negative.
  let score = (isColorCalc ? kAiColorCalcRand : 1e-9) * Math.random();
  const size = graph.nodes.length;
  for (const n of graph.nodes) {
    let inPlay = n.isEmpty() && n.hasEmptyNeighbors();
    let degreeScore = n.links.size / size;
    score += kAiHeurDegree * (inPlay ? -degreeScore : degreeScore);
  }

  if (heurVer == 1) return score;

  // Number of colors adjacent to each node is negative.
  const temp = [];
  for (const n of graph.nodes) {
    for (let i = 0; i < graph.numColors; ++i) temp[i] = 0;
    for (const m of n.links) temp[m.clr] = 1;
    let clrScore = 0;
    for (let i = 0; i < graph.numColors; ++i) clrScore += temp[i];
    score += -kAiHeurAdjClr * clrScore / graph.numColors;
  }

  if (heurVer == 2) return score;

  // Number of colors in use is negative.
  for (let i = 0; i < graph.numColors; ++i) {
    if (graph.nodesPerColor[i] != 0) {
      score += -kAiHeurColor / graph.numColors;
    }
  }

  return score;
}

function aiCalculateScore(graph, move, isPhil, heurVer, isColorCalc = false) {
  // Invariant: Must leave graph how it was found.
  graph.doMove(move);
  const score = aiCalculateScoreImplForPhil(graph, heurVer, isColorCalc);
  graph.undoMove(move);
  return isPhil ? score : -score;
};

function aiCombineScores(score, recScore) {
  if (!isFinite(score)) return score;
  recScore = -recScore;
  if (!isFinite(recScore)) return recScore;
  return score + kAiHeurRecursive * recScore;
};

class AiCtrl {
  constructor(kind, graph, isPhilCtrl, ui, doMove) {
    const maxDepth = {
      'Foolish AI': -1,
      'Easy AI': 0,
      'Easy H1 AI': 0,
      'Easy H2 AI': 0,
      'Easy H3 AI': 0,
      'Medium AI': 2,
      'Medium H1 AI': 2,
      'Medium H2 AI': 2,
      'Medium H3 AI': 2,
      'Hard AI': 4,
      'Hard H1 AI': 4,
      'Hard H2 AI': 4,
      'Hard H3 AI': 4,
    }[kind];
    const heurVer = {
      'Easy H1 AI': 1,
      'Medium H1 AI': 1,
      'Hard H1 AI': 1,
      'Easy H2 AI': 2,
      'Medium H2 AI': 2,
      'Hard H2 AI': 2,
      'Easy H3 AI': 3,
      'Medium H3 AI': 3,
      'Hard H3 AI': 3,
    }[kind] ?? kAiDefaultHeurVer;
    let setStatus = null;
    let setMood = null;
    let setMoodValue = null;
    if (ui) {
      const status = newDiv(ui, ['game-status']);
      setStatus = (s) => {
        status.innerText =`${isPhilCtrl ? 'Phil' : 'Emmy'} is ${s}...`;
      };
      const clrRow = newDiv(ui, ['game-ctrl-clr-row']);
      for (let i = 0; i < graph.numColors; ++i) {
        const btn = newDiv(clrRow, ['game-ctrl-clr-ai']);
        btn.style.backgroundColor = graph.colors[i];
      }
      const happyMoods = ['🙂', '😉', '🤭', '😄', '🤣', '😎', '🥳'];
      const neutralMoods = ['🤨', '🤔', '😑', '😐', '🧐', '😯', '😪'];
      const sadMoods = ['😅', '😬', '😵', '😒', '🥺', '😭', '💀'];
      const moodRow = newDiv(ui, ['ai-mood-row']);
      const mood = newDiv(moodRow, ['ai-mood']);
      setMood = (m) => mood.innerText = m;
      setMoodValue = (x) => {
        const neutralRange = 10;
        const maxRange = 1200;
        const y = (Math.abs(x) - neutralRange) / (maxRange - neutralRange);
        if (y <= 0) {
          setMood(neutralMoods[randInt(neutralMoods.length)]);
          return;
        }
        const moods = x < 0 ? sadMoods : happyMoods;
        if (!isFinite(x)) {
          setMood(moods[moods.length - 1]);
          return;
        }
        const z = (y * (moods.length - 1)) + (randInt(2) - 1);
        setMood(moods[clamp(Math.floor(z), moods.length - 2)]);
      };
      setMoodValue(0);
    }
    if (maxDepth == -1) {
      this.onTurn = async () => {
        if (ui) {
          setStatus('"thinking"');
          setMood('🤪');
          await wait(1);
        }

        const moves = [];
        graph.forEachValidMove((node, color) => {
          moves.push(new Move(node, color));
        });
        const move = moves[randInt(moves.length)];

        if (ui) {
          setStatus('coloring');
          setMood('🤠');
          await wait(1);
        }

        doMove(move);
      };
    } else {
      this.onTurn = async () => {
        if (ui) {
          setStatus('thinking');
          await wait(0);
        }

        // Returns [Move, Score]
        let time = performance.now();
        const runAi = async (depth, isPhil) => {
          // Allow a frame to render at 20Hz.
          const newTime = performance.now();
          if (newTime > time + (1000 / 20)) {
            await wait(0);
            time = newTime;
          }

          const mss = [];  // Array{Tuple{Move, Score}}
          graph.forEachUsefulMove((node, color) => {
            // Invariant: Must leave graph how it was found.
            const move = new Move(node, color);
            const score = aiCalculateScore(graph, move, isPhil, heurVer);
            if (score != -Infinity) mss.push([move, score]);
          });
          if (mss.length == 0) {
            // No useful moves, so do a random move.
            const moves = [];
            graph.forEachValidMove((node, color) => {
              moves.push(new Move(node, color));
            });
            const move = moves[randInt(moves.length)];
            return [move, aiCalculateScore(graph, move, isPhil, heurVer)];
          }
          for (const [move, score] of mss) {
            // Bail early to avoid recursion if there's a winning move.
            if (score == Infinity) return [move, score];
          }
          if (depth > 0) {
            for (let i = 0; i < mss.length; ++i) {
              // Invariant: Must leave graph how it was found.
              const [move, score] = mss[i];
              if (!isFinite(score)) continue;
              graph.doMove(move);
              const [revMove, recScore] = await runAi(depth - 1, !isPhil);
              const combinedScore = aiCombineScores(score, recScore);
              graph.undoMove(move);
              mss[i] = [move, combinedScore];
            }
          }
          let bestIndex = 0;
          let bestScore = mss[0][1];
          for (let i = 1; i < mss.length; ++i) {
            const [move, score] = mss[i];
            if (score > bestScore) {
              bestScore = score;
              bestIndex = i;
            }
          }
          return mss[bestIndex];
        };
        const [move, score] = await runAi(maxDepth, isPhilCtrl);

        if (ui) {
          console.log(move, score);
          const thinkTime = (performance.now() - time) / 1000;
          if (thinkTime < 1) await wait(1 - thinkTime);
          setStatus('coloring');
          setMoodValue(score);
          await wait(1);
        }

        doMove(move);
      };
    }
  }
}

class SyncAiCtrl {
  constructor(graph, isPhilCtrl, doMove) {
    /*this.onTurn = () => {
      const moves = [];
      graph.forEachValidMove((node, color) => {
        moves.push(new Move(node, color));
      });
      const move = moves[randInt(moves.length)];
      doMove(move);
    };*/
    const maxDepth = 0;
    const heurVer = 3;
    this.onTurn = () => {
      // Returns [Move, Score]
      const runAi = (depth, isPhil) => {
        const mss = [];  // Array{Tuple{Move, Score}}
        graph.forEachUsefulMove((node, color) => {
          // Invariant: Must leave graph how it was found.
          const move = new Move(node, color);
          const score = aiCalculateScore(graph, move, isPhil, heurVer, true);
          if (score != -Infinity) mss.push([move, score]);
        });
        if (mss.length == 0) {
          // No useful moves, so do a random move.
          const moves = [];
          graph.forEachValidMove((node, color) => {
            moves.push(new Move(node, color));
          });
          const move = moves[randInt(moves.length)];
          return [move, aiCalculateScore(graph, move, isPhil, heurVer, true)];
        }
        for (const [move, score] of mss) {
          // Bail early to avoid recursion if there's a winning move.
          if (score == Infinity) return [move, score];
        }
        if (depth > 0) {
          for (let i = 0; i < mss.length; ++i) {
            // Invariant: Must leave graph how it was found.
            const [move, score] = mss[i];
            if (!isFinite(score)) continue;
            graph.doMove(move);
            const [revMove, recScore] = runAi(depth - 1, !isPhil);
            const combinedScore = aiCombineScores(score, recScore);
            graph.undoMove(move);
            mss[i] = [move, combinedScore];
          }
        }
        let bestIndex = 0;
        let bestScore = mss[0][1];
        for (let i = 1; i < mss.length; ++i) {
          const [move, score] = mss[i];
          if (score > bestScore) {
            bestScore = score;
            bestIndex = i;
          }
        }
        return mss[bestIndex];
      };
      const [move, score] = runAi(maxDepth, isPhilCtrl);
      doMove(move);
    };
  }
}

class GraphNode {
  constructor(id, total) {
    this.id = id;
    this.color = -1;
    this.links = new Set();
    this.resetPos(total);
  }

  resetPos(total) {
    const t = tau * this.id / total;
    this.px = Math.cos(t);
    this.py = Math.sin(t);
    // this.px = randPos();
    // this.py = randPos();
    this.vx = 0;
    this.vy = 0;
  }

  link(other) {
    if (this == other) return false;
    if (this.links.has(other)) return false;
    this.links.add(other);
    other.links.add(this);
    return true;
  }

  isEmpty() {
    return this.color == -1;
  }

  hasEmptyNeighbors() {
    for (const m of this.links) {
      if (m.isEmpty()) return true;
    }
    return false;
  }
}

class Graph {
  constructor() {
    this.zoom = 1;
    this.camx = 0;
    this.camy = 0;
    this.heldNode = null;
    this.selectedNode = null;
    this.culpritNode = null;
    this.nodes = [];
    this.numColors = 0;
    this.colors = [];
    this.nodesPerColor = [];
    this.frozen = false;
  }

  createNodes(size) {
    this.frozen = false;
    this.nodes = [];
    for (let i = 0; i < size; ++i) {
      this.nodes.push(new GraphNode(i, size));
    }
  }

  fillColors() {
    this.colors = [];
    this.nodesPerColor = [];
    const offset = Math.random();
    for (let i = 0; i < this.numColors; ++i) {
      this.colors.push(hsv2rgb(offset + i / this.numColors));
      this.nodesPerColor.push(0);
    }
  }

  newDenseGraph(size) {
    // Straigtforward random graph generator.
    while (true) {
      // Create nodes.
      this.nodes = [];
      for (let i = 0; i < size; ++i) this.nodes.push(new GraphNode(i, size));

      // Calculate number of links to create.
      const minLinks = size - 1;
      const maxLinks = size * (size - 1) / 2;
      let remainingLinks = kLinkFactor * (maxLinks - minLinks) + minLinks;

      const randLink = from => {
        let to = from;
        while (to == from) to = randInt(size);
        if (this.nodes[from].link(this.nodes[to])) {
          --remainingLinks;
        }
      };

      // Start by creating one link from each node.
      for (let i = 0; i < size; ++i) randLink(i);

      // Then continue generating random links until we've made the right number.
      while (remainingLinks > 0) randLink(randInt(size));

      // If we have any disconnected components, start over.
      const visited = new Set();
      this.dfs(this.nodes[0], visited);
      if (visited.size == this.nodes.length) break;
    }

    // Calculate the number of colors we want.
    this.chooseNumColors(this.maxLinksPerNode());
    this.fillColors();
  }

  maxLinksPerNode() {
    let x = 0;
    for (const n of this.nodes) {
      x = Math.max(x, n.links.size);
    }
    return x;
  }

  newPlanarGraph(size) {
    // A region is defined by the ordered list of points that bound it. The
    // order of the list matters because the edges that bound the region are
    // between each adjacent node in the list, and the first and last node too.
    // Start with a single point.
    const regions = [[0]];
    // const nodePos = [[1, 0]];

    // Create new nodes by subdividing the regions.
    for (let i = 1; i < size; ++i) {
      // Pick a random region, and pull it out of the list.
      const r = popSwap(regions, randInt(regions.length));

      // Place the new node in the center of the region.
      /*if (i <= 2) {
        nodePos.push([-0.5, i == 1 ? 0.707 : -0.707]);
      } else {
        // Find the center.
        let cx = 1e-6 * randPos();
        let cy = 1e-6 * randPos();
        for (const i of r) {
          cx += nodePos[i][0];
          cy += nodePos[i][1];
        }
        nodePos.push([cx / r.length, cy / r.length]);
      }*/

      // We're going to add a node inside this region, and connect it to a
      // random number of the surrounding nodes (at least 1).
      const p = randPermutation(r.length);
      p.length = 1 + randInt(r.length);
      p.sort();
      for (let j = 0; j < p.length; ++j) {
        const k0 = p[j];
        const k1 = p[(j + 1) % p.length];

        // Cut r from r[k0] to r[k1].
        const s = [r[k1], i, r[k0]];
        let k = k0;
        while (true) {
          k = (k + 1) % r.length;
          s.push(r[k]);
          if (k == k1) break;
        }
        regions.push(s);
      }
    }

    // Create nodes.
    this.createNodes(size);
    // for (let i = 0; i < size; ++i) {
    //   this.nodes[i].px = nodePos[i][0];
    //   this.nodes[i].py = nodePos[i][1];
    // }

    // Turn the region set into links.
    for (const r of regions) {
      for (let i = 0; i < r.length; ++i) {
        const k0 = r[i];
        const k1 = r[(i + 1) % r.length];
        this.nodes[k0].link(this.nodes[k1]);
      }
    }

    // Choose the right number of colors for this graph.
    this.chooseNumColors(4);
    this.fillColors();
  }

  newCompleteGraph(size) {
    this.createNodes(size);
    for (const n of this.nodes) {
      for (const m of this.nodes) {
        n.link(m);
      }
    }
    this.numColors = size;
    this.fillColors();
  }

  newLineGraph(size, loop) {
    this.createNodes(size);
    const end = loop ? size : size - 1;
    for (let i = 0; i < end; ++i) {
      this.nodes[i].link(this.nodes[(i + 1) % size]);
    }
    this.numColors = 2;
    this.fillColors();
  }

  newTreeGraph(size) {
    this.createNodes(size);
    for (let i = 1; i < size; ++i) {
      while (true) {
        const r = randInt(size);
        if (r == i) continue;
        const visited = new Set();
        this.dfs(this.nodes[r], visited);
        if (visited.has(this.nodes[i])) continue;
        this.nodes[i].link(this.nodes[r]);
        break;
      }
    }
    this.chooseNumColors(3);
    this.fillColors();
  }

  chooseNumColors(guess) {
    // If Phil wins more than half of the games, there are too many colors. If
    // Emmy wins more than half of the games, there are too few colors. So
    // starting with our initial guess, go up and down searching for the closest
    // to an equal win rate we can find.
    const kTestGames = 100;
    const kTargWins = kTestGames / 2;
    const rates = [];
    const runTest = n => {
      if (rates[n] != null) return;
      this.numColors = n;
      let philWins = 0;
      for (let i = 0; i < kTestGames; ++i) {
        philWins += this.runTestGame();
      }
      rates[n] = philWins;
    };
    const score = philWins => {
      // 50% is best. For rates near 50%, bias slightly towards Phil. Further
      // away, the bias gets stronger. 100% is scores the same as 17%.
      const x = philWins / kTestGames;
      const y = Math.sqrt(x) - Math.sqrt(0.5);
      return y * y;
    };
    const runTests = d => {
      for (let n = guess; ; n += d) {
        if (n < 2 || n > this.nodes.length) break;
        runTest(n);
        const pr = rates[n - d];
        if (pr == null) continue;
        const r = rates[n];
        const sr = score(r);
        const sp = score(pr);
        if (sr > sp || (r == (d > 0 ? kTestGames : 0))) break;
      }
    };
    runTests(1);
    runTests(-1);
    console.log(rates);
    let mins = kTestGames;
    let mini = -1;
    for (let i = 0; i < rates.length; ++i) {
      const r = rates[i];
      if (r == null) continue;
      const s = score(r);
      if (s < mins) {
        mins = s;
        mini = i;
      }
    }
    this.numColors = mini;
    const philWinRate = rates[mini] / kTestGames;
    console.log(
        `Phil win rate for this graph: ${philWinRate * 100}%.`,
        `Using ${this.numColors} colors.`);
  }

  runTestGame() {
    let onTurn = null;
    let status = -2;
    const move = (isPhil, move) => {
      this.doMove(move);
      status = this.getStatus();
      if (status == -1) onTurn(isPhil);
    };
    const phil = new SyncAiCtrl(this, true, m => move(true, m));
    const emmy = new SyncAiCtrl(this, false, m => move(false, m));
    onTurn = (isPhil) => (isPhil ? emmy : phil).onTurn();
    phil.onTurn();
    this.resetColors();
    return status;
  }

  resetColors() {
    for (const n of this.nodes) n.color = -1;
    for (let i = 0; i < this.nodesPerColor.length; ++i) {
      this.nodesPerColor[i] = 0;
    }
  }

  dfs(node, visited) {
    if (visited.has(node)) return;
    visited.add(node);
    for (const m of node.links) this.dfs(m, visited);
  }

  resetPos() {
    this.frozen = false;
    for (const n of this.nodes) n.resetPos(this.nodes.length);
  }

  update() {
    for (let i = 0; i < kUpdateItrs; ++i) {
      // Stop updating if we've reached equilibrium.
      if (this.frozen) return;
      this.updateImpl();
    }
  }

  updateImpl() {
    // Calculate the forces.
    this.frozen = true;
    const size = this.nodes.length;
    for (let i = 0; i < size; ++i) {
      const n = this.nodes[i];

      // Apply a weak spring force towards the origin.
      const dist = Math.sqrt(n.px * n.px + n.py * n.py);
      const ux = n.px / dist;
      const uy = n.py / dist;
      const fa = -kAttractForce * Math.sqrt(dist);
      n.vx += fa * ux;
      n.vy += fa * uy;

      for (let j = 0; j < size; ++j) {
        if (i == j) continue;
        const m = this.nodes[j];
        const dx = m.px - n.px;
        const dy = m.py - n.py;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const ux = dx / dist;
        const uy = dy / dist;

        // Push the nodes apart, as if they're same pole magnets.
        const fr = kRepelForce / (dist * dist);
        n.vx += fr * ux;
        n.vy += fr * uy;

        if (n.links.has(m)) {
          // Pull the nodes together, as if they're joined by springs.
          const fa = kAttractForce * dist;
          n.vx += fa * ux;
          n.vy += fa * uy;
        }
      }

      // Damping.
      n.vx *= 1 - kDamping;
      n.vy *= 1 - kDamping;

      // Check if we've reached equilibrium.
      if (n.vx > kFreezeThreshold || n.vy > kFreezeThreshold) {
        this.frozen = false;
      }
    }

    // Apply the forces, and calculate the bounding box.
    let minx = Infinity;
    let maxx = -Infinity;
    let miny = Infinity;
    let maxy = -Infinity;
    for (let i = 0; i < size; ++i) {
      const n = this.nodes[i];
      n.px += n.vx;
      n.py += n.vy;
      minx = Math.min(minx, n.px);
      maxx = Math.max(maxx, n.px);
      miny = Math.min(miny, n.py);
      maxy = Math.max(maxy, n.py);
    }

    // Zoom and center.
    this.zoom = 0.52 * Math.max(maxx - minx, maxy - miny);
    this.camx = 0.5 * (minx + maxx);
    this.camy = 0.5 * (miny + maxy);

    if (this.frozen) console.log('FREEZE!', this.zoom);
  }

  draw(drawLink, drawNode) {
    // Draw all the links.
    const tx = x => (x - this.camx) / this.zoom;
    const ty = y => (y - this.camy) / this.zoom;
    const size = this.nodes.length;
    const nodeClr = n => n.isEmpty() ? '#444' : this.colors[n.color];
    for (let i = 1; i < size; ++i) {
      const n = this.nodes[i];
      for (let j = 0; j < i; ++j) {
        const m = this.nodes[j];
        if (n.links.has(m)) {
          let clrn = nodeClr(n);
          let clrm = nodeClr(m);
          if (this.selectedNode == i || this.selectedNode == j) {
            clrn = clrm = '#FFF';
          } else if (n.isEmpty()) {
            clrn = clrm;
          } else if (m.isEmpty()) {
            clrm = clrn;
          }
          drawLink(tx(n.px), ty(n.py), tx(m.px), ty(m.py), clrn, clrm);
        }
      }
    }

    // Draw all the nodes.
    for (let i = 0; i < size; ++i) {
      const n = this.nodes[i];
      const c = (this.selectedNode == i || this.culpritNode == i) ?
          '#FFF' : nodeClr(n);
      drawNode(tx(n.px), ty(n.py), c);
    }
  }

  onClickDown(rawx, rawy, hitrad) {
    const px = this.camx + rawx * this.zoom;
    const py = this.camy + rawy * this.zoom;
    let minr = Infinity;
    let mini = -1;
    for (let i = 0; i < this.nodes.length; ++i) {
      const n = this.nodes[i];
      const dx = px - n.px;
      const dy = py - n.py;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < minr) {
        minr = dist;
        mini = i;
      }
    }
    if (minr < hitrad * this.zoom) {
      this.heldNode = mini;
      this.selectedNode = (this.nodes[mini].color == -1) ? mini : null;
    } else {
      this.heldNode = null;
      this.selectedNode = null;
    }
  }

  onClickMove(rawx, rawy) {
    if (this.heldNode == null) return;
    const px = this.camx + rawx * this.zoom;
    const py = this.camy + rawy * this.zoom;
    this.nodes[this.heldNode].px = px;
    this.nodes[this.heldNode].py = py;
  }

  onClickUp() {
    this.heldNode = null;
  }

  isValidMove(move) {
    // Move is valid if the target node is empty and all its neighbors have a
    // different color to the target color.
    const n = this.nodes[move.nodeId];
    if (n.color != -1) return false;
    for (const m of n.links) {
      if (m.color == move.color) return false;
    }
    return true;
  }

  doMove(move) {
    // console.log(move);
    console.assert(this.nodes[move.nodeId].color == -1);
    this.nodes[move.nodeId].color = move.color;
    this.nodesPerColor[move.color] += 1;
  }

  undoMove(move) {
    console.assert(this.nodes[move.nodeId].color == move.color);
    this.nodes[move.nodeId].color = -1;
    this.nodesPerColor[move.color] -= 1;
  }

  // Returns -1 if game is not over, 0 if Emmy won, and 1 if Phil won.
  getStatus(uiMode = false) {
    // If all nodes are filled, Phil has won. Otherwise, if any node has no
    // valid moves, Emmy has won (and that node is the culprit). Otherwise, if
    // all empty nodes have only full neighbors, Phil has won (but in uiMode we
    // ignore this case). Otherwise, the game is not over.
    if (uiMode) this.culpritNode = null;
    let anyEmpty = false;
    let anyEmptyWithEmptyNeighbors = false;
    for (const n of this.nodes) {
      if (n.isEmpty()) {
        anyEmpty = true;

        // Are there any colors not used by the neighbors?
        const usedColors = new Set();
        for (const m of n.links) {
          if (m.isEmpty()) {
            anyEmptyWithEmptyNeighbors = true;
          } else {
            usedColors.add(m.color);
          }
        }
        if (usedColors.size == this.numColors) {
          if (uiMode) this.culpritNode = n.id;
          return 0;
        }
      }
    }
    if (!anyEmpty) return 1;
    if (!anyEmptyWithEmptyNeighbors && !uiMode) return 1;
    return -1;
  }

  forEachValidMove(fn, nodePredicate = n => true) {
    let unusedColorIsDone = false;
    for (let i = 0; i < this.numColors; ++i) {
      if (this.nodesPerColor[i] == 0) {
        if (unusedColorIsDone) {
          // Unused colors are fungible, so only iterate one of them.
          continue;
        } else {
          unusedColorIsDone = true;
        }
      }
      for (const n of this.nodes) {
        if (n.isEmpty() && nodePredicate(n)) {
          let validColor = true;
          for (const m of n.links) {
            if (m.color == i) {
              validColor = false;
              break;
            }
          }
          if (validColor) {
            fn(n.id, i);
          }
        }
      }
    }
  }

  forEachUsefulMove(fn) {
    // A useful move is a valid move on a node with at least one empty neighbor.
    this.forEachValidMove(fn, n => n.hasEmptyNeighbors());
  }
}

class Game {
  constructor(div) {
    this.div = div;
    this.graph = null;
    this.philCtrl = null;
    this.emmyCtrl = null;
  }

  transitionToSetup() {
    emptyDiv(this.div);
    newDiv(this.div, ['game-heading'], 'New Game');
    const makeRow = name => {
      const row = newDiv(this.div, ['game-setup-row']);
      newDiv(row, ['game-setup-name'], name);
      return row;
    };
    const makePlayerSelect = name =>
        newSelect(makeRow(name), ['game-setup-select'],
            ['Human', 'Foolish AI', 'Easy AI', 'Medium AI', 'Hard AI']);
    const phil = makePlayerSelect('Phil');
    const emmy = makePlayerSelect('Emmy');
    const makeSlider = (name, min, max) => {
      const row = makeRow(name);
      const number = newDiv(row, ['game-setup-slider-number']);
      const slider = newSlider(row, ['game-setup-slider'], min, max);
      number.innerText = slider.value = 7;
      slider.addEventListener('change', () => number.innerText = slider.value);
      return slider;
    };
    const size = makeSlider('Nodes', 4, 20);
    const graphType = newSelect(makeRow(name), ['game-setup-select'],
        ['Planar', 'Tree', 'Line', 'Loop', 'Complete', 'Dense']);
    newBtn(this.div, ['game-setup-play-button'], '[PLAY]', () =>
      this.transitionToGame(
          phil.value, emmy.value, parseInt(size.value), graphType.value));
  }

  makeCtrl(kind, isPhil, ui, onMove) {
    return kind.endsWith('AI') ?
        new AiCtrl(kind, this.graph, isPhil, ui, onMove) :
        new HumanCtrl(this.graph, isPhil, ui, onMove);
  }

  transitionToGame(phil, emmy, size, graphType) {
    emptyDiv(this.div);
    const wrap = newDiv(this.div, ['game-wrapper']);
    const ui = newDiv(wrap, ['game-ui']);
    const philUi = newDiv(ui, []);
    const emmyUi = newDiv(ui, ['hidden']);
    const view = newDiv(wrap, ['game-view']);

    const canvas = newCanvas(view, [], 800, 800);
    const ctx = canvas.getContext('2d');
    const halfWidth = canvas.width / 2;
    const halfHeight = canvas.height / 2;
    const viewSize = 2.5;
    const nodeSize = 0.02 * viewSize;
    const posX = 0;
    const posY = 0;
    ctx.setTransform(
        2 * halfWidth / viewSize, 0, 0, 2 * halfHeight / viewSize,
        halfWidth * (1 + 2 * posX / viewSize),
        halfHeight * (1 + 2 * posY / viewSize));
    ctx.lineWidth = viewSize / (halfWidth + halfHeight);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    this.graph = new Graph();
    if (graphType == 'Tree') {
      this.graph.newTreeGraph(size);
    } else if (graphType == 'Line') {
      this.graph.newLineGraph(size, false);
    } else if (graphType == 'Loop') {
      this.graph.newLineGraph(size, true);
    } else if (graphType == 'Complete') {
      this.graph.newCompleteGraph(size);
    } else if (graphType == 'Dense') {
      this.graph.newDenseGraph(size);
    } else {
      this.graph.newPlanarGraph(size);
    }
    canvas.addEventListener('mousedown', e => {
      this.graph.onClickDown(
          (e.offsetX / canvas.width - 0.5) * viewSize,
          (e.offsetY / canvas.height - 0.5) * viewSize,
          nodeSize);
    });
    canvas.addEventListener('mousemove', e => {
      this.graph.onClickMove(
          (e.offsetX / canvas.width - 0.5) * viewSize,
          (e.offsetY / canvas.height - 0.5) * viewSize);
    });
    canvas.addEventListener('mouseout', e => this.graph.onClickUp());
    canvas.addEventListener('mouseup', e => this.graph.onClickUp());

    const drawCircle = (px, py, r, clr) => {
      ctx.fillStyle = clr;
      ctx.beginPath();
      ctx.ellipse(px, py, r, r, 0, 0, tau);
      ctx.fill();
    };

    const drawNode = (px, py, clr) => drawCircle(px, py, nodeSize, clr);

    const drawLine = (px, py, qx, qy, clrp, clrq) => {
      const grd = ctx.createLinearGradient(px, py, qx, qy);
      grd.addColorStop(0, clrp);
      grd.addColorStop(1, clrq);
      ctx.strokeStyle = grd;
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.lineTo(qx, qy);
      ctx.stroke();
    };

    const update = () => {
      if (this.graph == null) {
        // Game is over.
        return;
      }

      this.graph.update();

      // Clear to black.
      ctx.fillStyle = '#000';
      ctx.fillRect(-2 * viewSize, -2 * viewSize, 4 * viewSize, 4 * viewSize);

      this.graph.draw(drawLine, drawNode);
      window.requestAnimationFrame(update);
    }
    update();

    const maybeDoEndTransition = status => {
      if (status == -1) return false;
      update();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.font = '50px monospace';
      ctx.fillStyle = '#FFF';
      ctx.fillText(`${status == 1 ? 'Phil' : 'Emmy'} wins!!!`, 400, 400);
      window.setTimeout(() => {
        this.graph = null;
        this.transitionToSetup();
      }, 5000);
      return true;
    };

    let onTurn = null;
    const onMove = (isPhil, move) => {
      this.graph.doMove(move);
      this.graph.selectedNode = null;
      if (!maybeDoEndTransition(this.graph.getStatus(true))) {
        (isPhil ? philUi : emmyUi).classList.add('hidden');
        (isPhil ? emmyUi : philUi).classList.remove('hidden');
        onTurn(isPhil);
      }
    };
    this.philCtrl = this.makeCtrl(phil, true, philUi, m => onMove(true, m));
    this.emmyCtrl = this.makeCtrl(emmy, false, emmyUi, m => onMove(false, m));
    onTurn = (isPhil) => (isPhil ? this.emmyCtrl : this.philCtrl).onTurn();
    this.philCtrl.onTurn();
  }

  async transitionToAiTestingMode() {
    // Build UI.
    emptyDiv(this.div);
    newDiv(this.div, ['game-heading'], 'AI Testing');
    const table = newElement('table', this.div, ['ai-test-table']);
    newDiv(this.div, [], "These are Phil's win rates ⮝");
    newElement('br', this.div);
    const eloTable = newElement('table', this.div, ['ai-test-table']);
    newElement('br', this.div);
    const runCount = newDiv(this.div);

    const tests = [];
    for (let p = -1; p < kAiTestingPhils.length; ++p) {
      const row = newElement('tr', table);
      for (let e = -1; e < kAiTestingEmmys.length; ++e) {
        const cell = newElement('td', row);
        if (p == -1) {
          if (e == -1) {
            cell.classList.add('ai-test-table-corner');
            cell.innerText = 'Phil⮟ Emmy⮞';
          } else {
            cell.classList.add('ai-test-table-heading-top');
            cell.innerText = kAiTestingEmmys[e];
          }
        } else {
          if (e == -1) {
            cell.classList.add('ai-test-table-heading-left');
            cell.innerText = kAiTestingPhils[p];
          } else {
            tests.push({
              philAi: kAiTestingPhils[p],
              emmyAi: kAiTestingEmmys[e],
              cell: cell,
              philWins: 0,
            });
          }
        }
      }
    }

    const aiElos = new Map();
    const eloTopRow = newElement('tr', eloTable);
    newElement('td', eloTopRow, ['ai-test-table-heading-corner']);
    newElement('td', eloTopRow, ['ai-test-table-heading-top'], 'Elo Rating');
    for (const ai of new Set(kAiTestingPhils.concat(kAiTestingEmmys))) {
      const row = newElement('tr', eloTable);
      newElement('td', row, ['ai-test-table-heading-left'], ai);
      const cell = newElement('td', row);
      aiElos.set(ai, {
        cell: cell,
        elo: 1000,
      });
    }

    await wait(0);

    // Run tests.
    const runTest = (philAi, emmyAi) => new Promise((resolve, reject) => {
      const g = new Graph();
      g.newPlanarGraph(kAiTestingGraphSize);
      let onTurn = null;
      const move = (isPhil, move) => {
        g.doMove(move);
        const status = g.getStatus();
        if (status == -1) {
          onTurn(isPhil);
        } else {
          resolve(status == 1);
        }
      };
      const phil = new AiCtrl(philAi, g, true, null, m => move(true, m));
      const emmy = new AiCtrl(emmyAi, g, false, null, m => move(false, m));
      onTurn = (isPhil) => (isPhil ? emmy : phil).onTurn();
      phil.onTurn();
    });
    const updateElos = (a, b, sa) => {
      const ra = a.elo;
      const rb = b.elo;
      const ea = 1 / (1 + Math.pow(10, (rb - ra) / 400));
      const da = 32 * (sa - ea);
      a.elo += da;
      b.elo -= da;
    };
    for (let run = 0; run < kAiTestingRuns; ++run) {
      runCount.innerText = `Run ${run + 1}...`;
      for (const test of tests) {
        test.cell.classList.add('running');
        await wait(0);
        const philWon = await runTest(test.philAi, test.emmyAi);
        if (philWon) ++test.philWins;
        const philElo = aiElos.get(test.philAi);
        const emmyElo = aiElos.get(test.emmyAi);
        updateElos(philElo, emmyElo, philWon ? 1 : 0);
        await wait(0);
        test.cell.innerText = `${Math.floor(test.philWins * 100 / (run + 1))}%`;
        test.cell.classList.remove('running');
        philElo.cell.innerText = Math.floor(philElo.elo);
        emmyElo.cell.innerText = Math.floor(emmyElo.elo);
      }
    }
    runCount.innerText = `Finished ${kAiTestingRuns} runs`;
  }
}

</script>
<style>
body {
  background-color: #212121;
  margin: 0;
}
#head {
  background-color: #424242;
  width: 100%;
  display: flex;
  justify-content: space-around;
  margin-bottom: 16px;
}
h1, #index {
  color: #ffc107;
  text-align: center;
  font-family: monospace;
  font-size: 42px;
  flex-grow: 1;
  padding: 16px;
  margin: 0;
}
#index {
  color: #ff5722;
  text-decoration: none;
  flex-grow: 0;
}
h2 {
  color: #ff5722;
  font-family: monospace;
}
a {
  color: #ffc107;
  font-family: monospace;
  font-size: 16px;
  cursor: pointer;
  text-decoration: underline;
}
#wrap {
  padding: 0 16px;
  color: #f5f5f5;
  font-family: monospace;
  font-size: 16px;
}
#game {
  display: flex;
  flex-direction: column;
  align-items: center;
}
.game-setup-row {
  display: flex;
  flex-direction: row;
  margin-top: 16px;
}
.game-heading {
  font-size: 24px;
  color: #ffc107;
}
.game-setup-name {
  margin-right: 16px;
}
.game-setup-slider-number {
  margin-right: 8px;
}
.game-setup-play-button {
  margin-top: 16px;
  cursor: pointer;
  font-size: 20px;
  color: #ff5722;
}
.game-wrapper {
  display: flex;
  flex-direction: row;
  gap: 16px;
}
.game-ui {
  width: 300px;
  display: flex;
  flex-direction: column;
}
.game-status {
  color: #ffc107;
  font-size: 24px;
}
.ai-mood-row {
  display: flex;
  flex-direction: row;
  justify-content: center;
  gap: 8px;
}
.ai-mood {
  font-size: 100px;
}
.game-ctrl-clr-row {
  margin: 8px;
  display: flex;
  flex-direction: row;
  gap: 12px;
  flex-wrap: wrap;
}
.game-ctrl-clr, .game-ctrl-clr-ai {
  width: 32px;
  height: 32px;
  border-radius: 10px;
}
.game-ctrl-clr {
  cursor: pointer;
}
.game-ctrl-clr.selected {
  width: 24px;
  height: 24px;
  border: 4px solid white;
}
.game-ctrl-row {
  display: flex;
  flex-direction: row;
  gap: 8px;
}
.game-ctrl-fill {
  color: #f44336;
}
.game-ctrl-fill {
  cursor: pointer;
  color: #ff5722;
}
.game-ctrl-error {
  color: #f44336;
}
.hidden {
  display: none;
}
.ai-test-table {
  border-spacing: 0px;
}
.ai-test-table-heading-left {
  border-left: 1px solid #424242;
}
.ai-test-table-heading-top {
  border-top: 1px solid #424242;
}
.ai-test-table td {
  border-bottom: 1px solid #424242;
  border-right: 1px solid #424242;
  padding: 4px 8px;
  text-align: center;
}
.ai-test-table td.running {
  background-color: #8bc34a;
}
</style>
</head>
<body>
<div id="head">
  <a id="index" href="index.html">&lt;</a>
  <h1>Graph Coloring Game</h1>
</div>
<div id="wrap">
  Two players, Phil and Emmy, take turns coloring nodes of a graph. Connected
  nodes must always be different colors. The game continues until no more nodes
  can be colored. Phil wins if all the nodes are filled, and Emmy wins if some
  of the nodes are empty.
  <br/><br/>
  <div id="game"></div>
</div>
</body>
</html>
