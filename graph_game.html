<!DOCTYPE html>
<html>
<head>
<title>Graph Game</title>
<link rel="icon" href="res/favicon.ico">
<script type="text/javascript">

// Config
const kLinkFactor = 0.5;
const kFastFreeze = true;
const kRepelForce = kFastFreeze ? -0.001 : -0.0001;
const kAttractForce = kFastFreeze ? 0.1 : 0.01;
const kDamping = kFastFreeze ? 0.5 : 0.2;
const kUpdateItrs = kFastFreeze ? 10 : 1;
const kFreezeThreshold = kFastFreeze ? 1e-4 : 1e-6;

const tau = 2 * Math.PI;

function randInt(n) {
  return Math.floor(n * Math.random());
}

function randPos() {
  return 2 * Math.random() - 1;
}

function swap(a, i, j) {
  const x = a[i];
  a[i] = a[j];
  a[j] = x;
}

async function wait(seconds) {
  return new Promise((resolve, reject) => {
    window.setTimeout(resolve, 1000 * seconds);
  });
}

function randPermutation(n) {
  const a = [];
  for (let i = 0; i < n; ++i) a.push(i);
  for (let i = 0; i < n; ++i) {
    swap(a, i, randInt(n - i) + i);
  }
  return a;
}

function fclamp(x, hi = 1, lo = 0) {
  return x <= lo ? lo : x >= hi ? hi : x;
}

function fmod(x, y = 1) {
  const z = x / y;
  return (z - Math.floor(z)) * y;
}

function popSwap(a, i) {
  const x = a[i];
  const y = a.pop();
  if (i < a.length) a[i] = y;
  return x;
}

function rgb2str(r, g, b) {
  const ch = x => {
    const s = Math.floor(fclamp(x * 256, 255)).toString(16);
    if (s.length > 2) return 'ff';
    if (s.length == 0) return '00';
    if (s.length == 1) return '0' + s;
    return s;
  }
  return `#${ch(r)}${ch(g)}${ch(b)}ff`;
}

function hsv2rgb(h, s = 1, v = 1) {
  const i = fmod(h) * 6.0;
  const c = v * s;
  const m = v - c;
  const x = c * (1 - Math.abs(fmod(i, 2) - 1)) + m;
  const d = c + m;
  if (i < 1) return rgb2str(d, x, m);
  if (i < 2) return rgb2str(x, d, m);
  if (i < 3) return rgb2str(m, d, x);
  if (i < 4) return rgb2str(m, x, d);
  if (i < 5) return rgb2str(x, m, d);
  return rgb2str(d, m, x);
}

function newElement(type, parent, classes = [], text = null) {
  const n = document.createElement(type);
  if (text != null) n.innerText = text;
  for (const cls of classes) n.classList.add(cls);
  if (parent != null) parent.appendChild(n);
  return n;
}

function newDiv(parent, classes = [], text = null) {
  return newElement('div', parent, classes, text);
}

function newSelect(parent, classes = [], options = []) {
  const sel = newElement('select', parent, classes);
  for (const opt of options) {
    newElement('option', sel, [], opt).setAttribute('value', opt);
  }
  return sel;
}

function newSlider(parent, classes = [], min = 0, max = 100, step = 1) {
  const slider = newElement('input', parent, classes);
  slider.setAttribute('type', 'range');
  slider.setAttribute('min', min);
  slider.setAttribute('max', max);
  slider.setAttribute('step', step);
  slider.setAttribute('value', min);
  return slider;
}

function newCanvas(parent, classes = [], width = 100, height = 100) {
  const slider = newElement('canvas', parent, classes);
  slider.setAttribute('width', width);
  slider.setAttribute('height', height);
  return slider;
}

function newBtn(
    parent, classes = [], text = null, onclick = null) {
  const btn = newDiv(parent, classes, text);
  if (onclick != null) btn.addEventListener('click', onclick);
  return btn;
}

function emptyDiv(n) {
  while (n.hasChildNodes()) n.removeChild(n.lastChild);
}

let game = null;
function onLoad() {
  game = new Game(document.getElementById('game'));
  game.transitionToSetup();
}
window.addEventListener('load', onLoad);

class Move {
  constructor(nodeId, color) {
    this.nodeId = nodeId;
    this.color = color;
  }
}

class HumanCtrl {
  constructor(graph, isPhil, ui, doMove) {
    newDiv(ui, ['game-status'], `It's ${isPhil ? 'Phil' : 'Emmy'}'s turn`);
    newDiv(ui, [], '1) Choose a color â®Ÿ');
    const clrRow = newDiv(ui, ['game-ctrl-clr-row']);
    const clrBtns = [];
    let selectedClr = null;
    const setClr = i => {
      for (const btn of clrBtns) btn.classList.remove('selected');
      selectedClr = (selectedClr == i) ? null : i;
      if (selectedClr != null) clrBtns[selectedClr].classList.add('selected');
    };
    for (let i = 0; i < graph.numColors; ++i) {
      const btn = newBtn(clrRow, ['game-ctrl-clr'], null, () => setClr(i));
      btn.style.backgroundColor = graph.colors[i];
      clrBtns.push(btn);
    }
    newDiv(ui, [], '2) Choose an empty node â®ž');
    const applyRow = newDiv(ui, ['game-ctrl-row']);
    newDiv(applyRow, [], '3)');
    let error = null;
    const fillBtn = newBtn(applyRow, ['game-ctrl-fill'], '[FILL NODE]', () => {
      error.innerText = '';
      if (selectedClr == null) {
        error.innerText = 'You have to choose a color first.';
      } else if (graph.selectedNode == null) {
        error.innerText = 'You have to choose a node first.';
      } else {
        const move = new Move(graph.selectedNode, selectedClr);
        if (!graph.isValidMove(move)) {
          error.innerText =
              'The node must be a different color to all its neighbors.';
        } else {
          setClr(null);
          doMove(move);
        }
      }
    });
    error = newDiv(ui, ['game-ctrl-error']);
  }

  onTurn() {}
}

class AiCtrl {
  constructor(kind, graph, isPhil, ui, doMove) {
    const depth = {
      'Random AI': -1,
      'Easy AI': 2,
      'Medium AI': 4,
      'Hard AI': 6,
    }[kind];
    let setStatus = null;
    let setMood = null;
    if (ui) {
      const status = newDiv(ui, ['game-status']);
      setStatus = (s) => {
        status.innerText =`${isPhil ? 'Phil' : 'Emmy'} is ${s}...`;
      };
      const moods = [
          'ðŸ˜­', 'ðŸ¥º', 'ðŸ˜’', 'ðŸ˜µ', 'ðŸ˜¬', 'ðŸ˜…', 'ðŸ¤¨',
          'ðŸ¤”',
          'ðŸ™‚', 'ðŸ˜‰', 'ðŸ¤­', 'ðŸ˜„', 'ðŸ¤£', 'ðŸ˜Ž', 'ðŸ¥³'];
      const mood = newDiv(ui, ['ai-mood']);
      setMood = (m) => {
        mood.innerText = `Mood: ${m}`;
      };
      setMood(moods[7]);
    }
    if (depth == -1) {
      this.onTurn = async () => {
        if (ui) {
          setStatus('"thinking"');
          setMood('ðŸ¤ª');
          await wait(1);
        }

        const moves = [];
        graph.forEachValidMove((node, color) => {
          moves.push(new Move(node, color));
        });
        const move = moves[randInt(moves.length)];

        if (ui) {
          setStatus('coloring');
          setMood('ðŸ¤ ');
          await wait(0.5);
        }

        doMove(move);
      };
    } else {
      if (ui) {
        setStatus('thinking');
        // TODO.
      }
    }
  }
}

class GraphNode {
  constructor(id, total) {
    this.id = id;
    this.color = -1;
    this.links = new Set();
    this.resetPos(total);
  }

  resetColor() {
    this.color = -1;
  }

  resetPos(total) {
    const t = tau * this.id / total;
    this.px = Math.cos(t);
    this.py = Math.sin(t);
    // this.px = randPos();
    // this.py = randPos();
    this.vx = 0;
    this.vy = 0;
  }

  link(other) {
    if (this == other) return false;
    if (this.links.has(other)) return false;
    this.links.add(other);
    other.links.add(this);
    return true;
  }
}

class Graph {
  constructor() {
    this.zoom = 1;
    this.camx = 0;
    this.camy = 0;
    this.heldNode = null;
    this.selectedNode = null;
    this.nodes = [];
    this.numColors = 0;
    this.colors = [];
    this.frozen = false;
  }

  newGraph(size) {
    // Straigtforward random graph generator.
    while (true) {
      // Create nodes.
      this.nodes = [];
      for (let i = 0; i < size; ++i) this.nodes.push(new GraphNode(i, size));

      // Calculate number of links to create.
      const minLinks = size - 1;
      const maxLinks = size * (size - 1) / 2;
      let remainingLinks = kLinkFactor * (maxLinks - minLinks) + minLinks;

      const randLink = from => {
        let to = from;
        while (to == from) to = randInt(size);
        if (this.nodes[from].link(this.nodes[to])) {
          --remainingLinks;
        }
      };

      // Start by creating one link from each node.
      for (let i = 0; i < size; ++i) randLink(i);

      // Then continue generating random links until we've made the right number.
      while (remainingLinks > 0) randLink(randInt(size));

      // If we have any disconnected components, start over.
      const visited = new Set();
      this.dfs(this.nodes[0], visited);
      if (visited.size == this.nodes.length) break;
    }

    // Calculate the number of colors we want.
    let maxLinksPerNode = 0;
    for (const n of this.nodes) {
      maxLinksPerNode = Math.max(maxLinksPerNode, n.links.size);
    }
    // TODO: Tune this heuristic. It's probably an overestimate at higher sizes.
    const numColors = maxLinksPerNode + 1;
    this.colors = [];
    const offset = Math.random();
    for (let i = 0; i < numColors; ++i) {
      this.colors.push(hsv2rgb(offset + i / numColors));
    }
    this.frozen = false;
  }

  newPlanarGraph(size) {
    // A region is defined by the ordered list of points that bound it. The
    // order of the list matters because the edges that bound the region are
    // between each adjacent node in the list, and the first and last node too.
    // Start with a single point.
    const regions = [[0]];
    // const nodePos = [[1, 0]];

    // Create new nodes by subdividing the regions.
    for (let i = 1; i < size; ++i) {
      // Pick a random region, and pull it out of the list.
      const r = popSwap(regions, randInt(regions.length));

      // Place the new node in the center of the region.
      /*if (i <= 2) {
        nodePos.push([-0.5, i == 1 ? 0.707 : -0.707]);
      } else {
        // Find the center.
        let cx = 1e-6 * randPos();
        let cy = 1e-6 * randPos();
        for (const i of r) {
          cx += nodePos[i][0];
          cy += nodePos[i][1];
        }
        nodePos.push([cx / r.length, cy / r.length]);
      }*/

      // We're going to add a node inside this region, and connect it to a
      // random number of the surrounding nodes (at least 1).
      const p = randPermutation(r.length);
      p.length = 1 + randInt(r.length);
      p.sort();
      for (let j = 0; j < p.length; ++j) {
        const k0 = p[j];
        const k1 = p[(j + 1) % p.length];

        // Cut r from r[k0] to r[k1].
        const s = [r[k1], i, r[k0]];
        let k = k0;
        while (true) {
          k = (k + 1) % r.length;
          s.push(r[k]);
          if (k == k1) break;
        }
        regions.push(s);
      }
    }

    // Create nodes.
    this.nodes = [];
    for (let i = 0; i < size; ++i) {
      this.nodes.push(new GraphNode(i, size));
      // this.nodes[i].px = nodePos[i][0];
      // this.nodes[i].py = nodePos[i][1];
    }

    // Turn the region set into links.
    for (const r of regions) {
      for (let i = 0; i < r.length; ++i) {
        const k0 = r[i];
        const k1 = r[(i + 1) % r.length];
        this.nodes[k0].link(this.nodes[k1]);
      }
    }

    // Choose the right number of colors for this graph.
    const philWinRate = this.chooseNumColors(4);
    console.log(`Phil win rate for this graph: ${philWinRate * 100}%`);

    // Define colors.
    this.colors = [];
    const offset = Math.random();
    for (let i = 0; i < this.numColors; ++i) {
      this.colors.push(hsv2rgb(offset + i / this.numColors));
    }
    this.frozen = false;
  }

  chooseNumColors(guess) {
    // If Phil wins more than half of the games, there are too many colors. If
    // Emmy wins more than half of the games, there are too few colors. So
    // starting with our initial guess, go up and down searching for the closest
    // to an equal win rate we can find.
    const kTestGames = 100;
    const kTargWins = kTestGames / 2;
    const rates = [];
    const runTest = n => {
      if (rates[n] != null) return;
      this.numColors = n;
      let philWins = 0;
      for (let i = 0; i < kTestGames; ++i) {
        philWins += this.runTestGame();
      }
      rates[n] = philWins;
    };
    const runTests = d => {
      for (let n = guess; ; n += d) {
        if (n < 2 || n >= this.nodes.length) break;
        runTest(n);
        const pr = rates[n - d];
        if (pr == null) continue;
        const r = rates[n];
        if (Math.abs(r - kTargWins) > Math.abs(pr - kTargWins)) break;
      }
    };
    runTests(1);
    runTests(-1);
    console.log(rates);
    let mins = kTestGames;
    let mini = -1;
    for (let i = 0; i < rates.length; ++i) {
      const r = rates[i];
      if (r == null) continue;
      const s = Math.abs(r - kTargWins);
      if (s < mins) {
        mins = s;
        mini = i;
      }
    }
    this.numColors = mini;
    return rates[mini] / kTestGames;
  }

  runTestGame() {
    let onTurn = null;
    let status = -2;
    const onMove = (isPhil, move) => {
      this.doMove(move);
      status = this.getStatus();
      if (status == -1) onTurn(isPhil);
    };
    const phil = new AiCtrl(
        'Random AI', this, true, null, m => onMove(true, m));
    const emmy = new AiCtrl(
        'Random AI', this, false, null, m => onMove(false, m));
    onTurn = (isPhil) => (isPhil ? emmy : phil).onTurn();
    phil.onTurn();
    for (const n of this.nodes) n.resetColor();
    return status;
  }

  dfs(node, visited, fn = null) {
    if (visited.has(node)) return;
    visited.add(node);
    if (fn) fn(node);
    for (const m of node.links) this.dfs(m, visited);
  }

  resetPos() {
    this.frozen = false;
    for (const n of this.nodes) n.resetPos(this.nodes.length);
  }

  update() {
    for (let i = 0; i < kUpdateItrs; ++i) {
      // Stop updating if we've reached equilibrium.
      if (this.frozen) return;
      this.updateImpl();
    }
  }

  updateImpl() {
    // Calculate the forces.
    this.frozen = true;
    const size = this.nodes.length;
    for (let i = 0; i < size; ++i) {
      const n = this.nodes[i];

      // Apply a weak spring force towards the origin.
      const dist = Math.sqrt(n.px * n.px + n.py * n.py);
      const ux = n.px / dist;
      const uy = n.py / dist;
      const fa = -kAttractForce * Math.sqrt(dist);
      n.vx += fa * ux;
      n.vy += fa * uy;

      for (let j = 0; j < size; ++j) {
        if (i == j) continue;
        const m = this.nodes[j];
        const dx = m.px - n.px;
        const dy = m.py - n.py;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const ux = dx / dist;
        const uy = dy / dist;

        // Push the nodes apart, as if they're same pole magnets.
        const fr = kRepelForce / (dist * dist);
        n.vx += fr * ux;
        n.vy += fr * uy;

        if (n.links.has(m)) {
          // Pull the nodes together, as if they're joined by springs.
          const fa = kAttractForce * dist;
          n.vx += fa * ux;
          n.vy += fa * uy;
        }
      }

      // Damping.
      n.vx *= 1 - kDamping;
      n.vy *= 1 - kDamping;

      // Check if we've reached equilibrium.
      if (n.vx > kFreezeThreshold || n.vy > kFreezeThreshold) {
        this.frozen = false;
      }
    }

    // Apply the forces, and calculate the bounding box.
    let minx = Infinity;
    let maxx = -Infinity;
    let miny = Infinity;
    let maxy = -Infinity;
    for (let i = 0; i < size; ++i) {
      const n = this.nodes[i];
      n.px += n.vx;
      n.py += n.vy;
      minx = Math.min(minx, n.px);
      maxx = Math.max(maxx, n.px);
      miny = Math.min(miny, n.py);
      maxy = Math.max(maxy, n.py);
    }

    // Zoom and center.
    this.zoom = 0.52 * Math.max(maxx - minx, maxy - miny);
    this.camx = 0.5 * (minx + maxx);
    this.camy = 0.5 * (miny + maxy);

    if (this.frozen) console.log('FREEZE!', this.zoom);
  }

  draw(drawLink, drawNode) {
    // Draw all the links.
    const tx = x => (x - this.camx) / this.zoom;
    const ty = y => (y - this.camy) / this.zoom;
    const size = this.nodes.length;
    for (let i = 1; i < size; ++i) {
      const n = this.nodes[i];
      for (let j = 0; j < i; ++j) {
        const m = this.nodes[j];
        if (n.links.has(m)) {
          const clr = (this.selectedNode == i || this.selectedNode == j) ?
              '#FFF' : '#444';
          drawLink(tx(n.px), ty(n.py), tx(m.px), ty(m.py), clr);
        }
      }
    }

    // Draw all the nodes.
    for (let i = 0; i < size; ++i) {
      const n = this.nodes[i];
      const c = (this.selectedNode == i) ? '#FFF' :
          (n.color == -1) ? '#444' : this.colors[n.color];
      drawNode(tx(n.px), ty(n.py), c);
    }
  }

  onClickDown(rawx, rawy, hitrad) {
    const px = this.camx + rawx * this.zoom;
    const py = this.camy + rawy * this.zoom;
    let minr = Infinity;
    let mini = -1;
    for (let i = 0; i < this.nodes.length; ++i) {
      const n = this.nodes[i];
      const dx = px - n.px;
      const dy = py - n.py;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < minr) {
        minr = dist;
        mini = i;
      }
    }
    if (minr < hitrad * this.zoom) {
      this.heldNode = mini;
      this.selectedNode = (this.nodes[mini].color == -1) ? mini : null;
    } else {
      this.heldNode = null;
      this.selectedNode = null;
    }
  }

  onClickMove(rawx, rawy) {
    if (this.heldNode == null) return;
    const px = this.camx + rawx * this.zoom;
    const py = this.camy + rawy * this.zoom;
    this.nodes[this.heldNode].px = px;
    this.nodes[this.heldNode].py = py;
  }

  onClickUp() {
    this.heldNode = null;
  }

  isValidMove(move) {
    // Move is valid if the target node is empty and all its neighbors have a
    // different color to the target color.
    const n = this.nodes[move.nodeId];
    if (n.color != -1) return false;
    for (const m of n.links) {
      if (m.color == move.color) return false;
    }
    return true;
  }

  // Returns -1 if game is not over, 0 if Emmy won, and 1 if Phil won.
  doMove(move) {
    // console.log(move);
    this.selectedNode = null;
    this.nodes[move.nodeId].color = move.color;
  }

  getStatus() {
    // If all nodes are filled, Phil has won. Otherwise, if there are no valid
    // moves left, Emmy has won.
    let anyEmpty = false;
    let anyMoves = false;
    for (const n of this.nodes) {
      if (n.color == -1) {
        anyEmpty = true;

        // Are there any colors not used by the neighbors?
        const usedColors = new Set();
        for (const m of n.links) {
          if (m.color != -1) usedColors.add(m.color);
        }
        if (usedColors.size < this.numColors) {
          anyMoves = true;
          break;
        }
      }
    }
    if (!anyEmpty) return 1;
    if (!anyMoves) return 0;
    return -1;
  }

  forEachValidMove(fn) {
    for (const n of this.nodes) {
      if (n.color == -1) {
        for (let i = 0; i < this.numColors; ++i) {
          let validColor = true;
          for (const m of n.links) {
            if (m.color == i) {
              validColor = false;
              break;
            }
          }
          if (validColor) {
            fn(n.id, i);
          }
        }
      }
    }
  }
}

class Game {
  constructor(div) {
    this.div = div;
    this.graph = null;
    this.philCtrl = null;
    this.emmyCtrl = null;
  }

  transitionToSetup() {
    emptyDiv(this.div);
    newDiv(this.div, ['game-heading'], 'New Game');
    const makeRow = name => {
      const row = newDiv(this.div, ['game-setup-row']);
      newDiv(row, ['game-setup-name'], name);
      return row;
    };
    const makePlayerSelect = name =>
        newSelect(makeRow(name), ['game-setup-player-select'],
            ['Human', 'Easy AI', 'Medium AI', 'Hard AI', 'Random AI']);
    const phil = makePlayerSelect('Phil');
    const emmy = makePlayerSelect('Emmy');
    const makeSlider = (name, min, max) => {
      const row = makeRow(name);
      const number = newDiv(row, ['game-setup-slider-number']);
      const slider = newSlider(row, ['game-setup-slider'], min, max);
      number.innerText = slider.value = 7;
      slider.addEventListener('change', () => number.innerText = slider.value);
      return slider;
    };
    const size = makeSlider('Nodes', 4, 20);
    newBtn(this.div, ['game-setup-play-button'], '[PLAY]', () =>
      this.transitionToGame(phil.value, emmy.value, parseInt(size.value)));
  }

  makeCtrl(kind, isPhil, ui, onMove) {
    return kind.endsWith('AI') ?
        new AiCtrl(kind, this.graph, isPhil, ui, onMove) :
        new HumanCtrl(this.graph, isPhil, ui, onMove);
  }

  transitionToGame(phil, emmy, size) {
    emptyDiv(this.div);
    const wrap = newDiv(this.div, ['game-wrapper']);
    const ui = newDiv(wrap, ['game-ui']);
    const philUi = newDiv(ui, []);
    const emmyUi = newDiv(ui, ['hidden']);
    const view = newDiv(wrap, ['game-view']);

    const canvas = newCanvas(view, [], 800, 800);
    const ctx = canvas.getContext('2d');
    const halfWidth = canvas.width / 2;
    const halfHeight = canvas.height / 2;
    const viewSize = 2.5;
    const nodeSize = 0.03 * viewSize;
    const posX = 0;
    const posY = 0;
    ctx.setTransform(
        2 * halfWidth / viewSize, 0, 0, 2 * halfHeight / viewSize,
        halfWidth * (1 + 2 * posX / viewSize),
        halfHeight * (1 + 2 * posY / viewSize));
    ctx.lineWidth = viewSize / (halfWidth + halfHeight);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    this.graph = new Graph();
    this.graph.newPlanarGraph(size);
    canvas.addEventListener('mousedown', e => {
      this.graph.onClickDown(
          (e.offsetX / canvas.width - 0.5) * viewSize,
          (e.offsetY / canvas.height - 0.5) * viewSize,
          nodeSize);
    });
    canvas.addEventListener('mousemove', e => {
      this.graph.onClickMove(
          (e.offsetX / canvas.width - 0.5) * viewSize,
          (e.offsetY / canvas.height - 0.5) * viewSize);
    });
    canvas.addEventListener('mouseout', e => this.graph.onClickUp());
    canvas.addEventListener('mouseup', e => this.graph.onClickUp());

    const drawCircle = (px, py, r, clr) => {
      ctx.fillStyle = clr;
      ctx.beginPath();
      ctx.ellipse(px, py, r, r, 0, 0, tau);
      ctx.fill();
    };

    const drawNode = (px, py, clr) => drawCircle(px, py, nodeSize, clr);

    const drawLine = (px, py, qx, qy, clr) => {
      ctx.strokeStyle = clr;
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.lineTo(qx, qy);
      ctx.stroke();
    };

    const update = () => {
      if (this.graph == null) {
        // Game is over.
        return;
      }

      this.graph.update();

      // Clear to black.
      ctx.fillStyle = '#000';
      ctx.fillRect(-2 * viewSize, -2 * viewSize, 4 * viewSize, 4 * viewSize);

      this.graph.draw(drawLine, drawNode);
      window.requestAnimationFrame(update);
    }
    update();

    const maybeDoEndTransition = status => {
      if (status == -1) return false;
      update();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.font = '50px monospace';
      ctx.fillStyle = '#FFF';
      ctx.fillText(`${status == 1 ? 'Phil' : 'Emmy'} wins!!!`, 400, 400);
      window.setTimeout(() => {
        this.graph = null;
        this.transitionToSetup();
      }, 5000);
      return true;
    };

    let onTurn = null;
    const onMove = (isPhil, move) => {
      this.graph.doMove(move);
      if (!maybeDoEndTransition(this.graph.getStatus())) {
        (isPhil ? philUi : emmyUi).classList.add('hidden');
        (isPhil ? emmyUi : philUi).classList.remove('hidden');
        onTurn(isPhil);
      }
    };
    this.philCtrl = this.makeCtrl(phil, true, philUi, m => onMove(true, m));
    this.emmyCtrl = this.makeCtrl(emmy, false, emmyUi, m => onMove(false, m));
    onTurn = (isPhil) => (isPhil ? this.emmyCtrl : this.philCtrl).onTurn();
    this.philCtrl.onTurn();
  }
}

</script>
<style>
body {
  background-color: #212121;
  margin: 0;
}
#head {
  background-color: #424242;
  width: 100%;
  display: flex;
  justify-content: space-around;
  margin-bottom: 16px;
}
h1, #index {
  color: #ffc107;
  text-align: center;
  font-family: monospace;
  font-size: 42px;
  flex-grow: 1;
  padding: 16px;
  margin: 0;
}
#index {
  color: #ff5722;
  text-decoration: none;
  flex-grow: 0;
}
h2 {
  color: #ff5722;
  font-family: monospace;
}
a {
  color: #ffc107;
  font-family: monospace;
  font-size: 16px;
  cursor: pointer;
  text-decoration: underline;
}
#wrap {
  padding: 0 16px;
  color: #f5f5f5;
  font-family: monospace;
  font-size: 16px;
}
#game {
  display: flex;
  flex-direction: column;
  align-items: center;
}
.game-setup-row {
  display: flex;
  flex-direction: row;
  margin-top: 16px;
}
.game-heading {
  font-size: 24px;
  color: #ffc107;
}
.game-setup-name {
  margin-right: 16px;
}
.game-setup-slider-number {
  margin-right: 8px;
}
.game-setup-play-button {
  margin-top: 16px;
  cursor: pointer;
  font-size: 20px;
  color: #ff5722;
}
.game-wrapper {
  display: flex;
  flex-direction: row;
  gap: 16px;
}
.game-ui {
  width: 300px;
  display: flex;
  flex-direction: column;
}
.game-status {
  color: #ffc107;
  font-size: 20px;
}
.game-ctrl-clr-row {
  margin: 8px;
  display: flex;
  flex-direction: row;
  gap: 12px;
  flex-wrap: wrap;
}
.game-ctrl-clr {
  width: 32px;
  height: 32px;
  border-radius: 10px;
  cursor: pointer;
}
.game-ctrl-clr.selected {
  width: 24px;
  height: 24px;
  border: 4px solid white;
}
.game-ctrl-row {
  display: flex;
  flex-direction: row;
  gap: 8px;
}
.game-ctrl-fill {
  color: #f44336;
}
.game-ctrl-fill {
  cursor: pointer;
  color: #ff5722;
}
.game-ctrl-error {
  color: #f44336;
}
.hidden {
  display: none;
}
</style>
</head>
<body>
<div id="head">
  <a id="index" href="index.html">&lt;</a>
  <h1>Graph Coloring Game (Prototype)</h1>
</div>
<div id="wrap">
  Two players, Phil and Emmy, take turns coloring nodes of a graph. Connected
  nodes must always be different colors. The game continues until no more nodes
  can be colored. Phil wins if all the nodes are filled, and Emmy wins if some
  of the nodes are empty.
  <br/><br/>
  <div id="game"></div>
</div>
</body>
</html>
