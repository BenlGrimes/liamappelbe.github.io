<!DOCTYPE html>
<html>
<head>
<title>Graph Game</title>
<link rel="icon" href="res/favicon.ico">
<script type="text/javascript">

// Config
const kLinkFactor = 0.5;
const kFastFreeze = true;
const kRepelForce = kFastFreeze ? -0.001 : -0.0001;
const kAttractForce = kFastFreeze ? 0.1 : 0.01;
const kDamping = kFastFreeze ? 0.5 : 0.2;
const kUpdateItrs = kFastFreeze ? 10 : 1;
const kFreezeThreshold = kFastFreeze ? 1e-4 : 1e-6;

const tau = 2 * Math.PI;

function randInt(n) {
  return Math.floor(n * Math.random());
}

function randPos() {
  return 2 * Math.random() - 1;
}

function swap(a, i, j) {
  const x = a[i];
  a[i] = a[j];
  a[j] = x;
}

function randPermutation(n) {
  const a = [];
  for (let i = 0; i < n; ++i) a.push(i);
  for (let i = 0; i < n; ++i) {
    swap(a, i, randInt(n - i) + i);
  }
  return a;
}

function fclamp(x, hi = 1, lo = 0) {
  return x <= lo ? lo : x >= hi ? hi : x;
}

function fmod(x, y = 1) {
  const z = x / y;
  return (z - Math.floor(z)) * y;
}

function popSwap(a, i) {
  const x = a[i];
  const y = a.pop();
  if (i < a.length) a[i] = y;
  return x;
}

function rgb2str(r, g, b) {
  const ch = x => {
    const s = Math.floor(fclamp(x * 256, 255)).toString(16);
    if (s.length > 2) return 'ff';
    if (s.length == 0) return '00';
    if (s.length == 1) return '0' + s;
    return s;
  }
  return `#${ch(r)}${ch(g)}${ch(b)}ff`;
}

function hsv2rgb(h, s = 1, v = 1) {
  const i = fmod(h) * 6.0;
  const c = v * s;
  const m = v - c;
  const x = c * (1 - Math.abs(fmod(i, 2) - 1)) + m;
  const d = c + m;
  if (i < 1) return rgb2str(d, x, m);
  if (i < 2) return rgb2str(x, d, m);
  if (i < 3) return rgb2str(m, d, x);
  if (i < 4) return rgb2str(m, x, d);
  if (i < 5) return rgb2str(x, m, d);
  return rgb2str(d, m, x);
}

function newElement(type, parent, classes = [], text = null) {
  const n = document.createElement(type);
  if (text != null) n.innerText = text;
  for (const cls of classes) n.classList.add(cls);
  if (parent != null) parent.appendChild(n);
  return n;
}

function newDiv(parent, classes = [], text = null) {
  return newElement('div', parent, classes, text);
}

function newSelect(parent, classes = [], options = []) {
  const sel = newElement('select', parent, classes);
  for (const opt of options) {
    newElement('option', sel, [], opt).setAttribute('value', opt);
  }
  return sel;
}

function newSlider(parent, classes = [], min = 0, max = 100, step = 1) {
  const slider = newElement('input', parent, classes);
  slider.setAttribute('type', 'range');
  slider.setAttribute('min', min);
  slider.setAttribute('max', max);
  slider.setAttribute('step', step);
  slider.setAttribute('value', min);
  return slider;
}

function newCanvas(parent, classes = [], width = 100, height = 100) {
  const slider = newElement('canvas', parent, classes);
  slider.setAttribute('width', width);
  slider.setAttribute('height', height);
  return slider;
}

function newBtn(
    parent, classes = [], text = null, onclick = null) {
  const btn = newDiv(parent, classes, text);
  if (onclick != null) btn.addEventListener('click', onclick);
  return btn;
}

function emptyDiv(n) {
  while (n.hasChildNodes()) n.removeChild(n.lastChild);
}

let game = null;
function onLoad() {
  game = new Game(document.getElementById('game'));
  game.transitionToSetup();
}
window.addEventListener('load', onLoad);

class Move {
  constructor(nodeId, color) {
    this.nodeId = nodeId;
    this.color = color;
  }
}

class HumanCtrl {
  constructor(graph, isPhil, ui, onMove) {
    newDiv(ui, ['game-status'], `It's ${isPhil ? 'Phil' : 'Emmy'}'s turn`);
    newDiv(ui, [], '1) Choose a color ⮟');
    const clrRow = newDiv(ui, ['game-ctrl-clr-row']);
    const clrBtns = [];
    let selectedClr = null;
    const setClr = i => {
      for (const btn of clrBtns) btn.classList.remove('selected');
      selectedClr = (selectedClr == i) ? null : i;
      if (selectedClr != null) clrBtns[selectedClr].classList.add('selected');
    };
    for (let i = 0; i < graph.colors.length; ++i) {
      const btn = newBtn(clrRow, ['game-ctrl-clr'], null, () => setClr(i));
      btn.style.backgroundColor = graph.colors[i];
      clrBtns.push(btn);
    }
    newDiv(ui, [], '2) Choose an empty node ⮞');
    const applyRow = newDiv(ui, ['game-ctrl-row']);
    newDiv(applyRow, [], '3)');
    let error = null;
    const fillBtn = newBtn(applyRow, ['game-ctrl-fill'], '[FILL NODE]', () => {
      error.innerText = '';
      if (selectedClr == null) {
        error.innerText = 'You have to choose a color first.';
      } else if (graph.selectedNode == null) {
        error.innerText = 'You have to choose a node first.';
      } else {
        const move = new Move(graph.selectedNode, selectedClr);
        if (!graph.isValidMove(move)) {
          error.innerText =
              'The node must be a different color to all its neighbors.';
        } else {
          setClr(null);
          onMove(move);
        }
      }
    });
    error = newDiv(ui, ['game-ctrl-error']);
  }
}

class AiCtrl {
  constructor(graph, isPhil, ui, onMove) {
    newDiv(ui, ['game-status'], `${isPhil ? 'Phil' : 'Emmy'} is thinking...`);
    newDiv(ui, [], 'AI is not implemented yet :P');
    // TODO: Implement AI.
  }
}

class GraphNode {
  constructor(id, total) {
    this.id = id;
    this.color = -1;
    this.links = new Set();
    this.resetPos(total);
  }

  resetPos(total) {
    const t = tau * this.id / total;
    this.px = Math.cos(t);
    this.py = Math.sin(t);
    // this.px = randPos();
    // this.py = randPos();
    this.vx = 0;
    this.vy = 0;
  }

  link(other) {
    if (this == other) return false;
    if (this.links.has(other)) return false;
    this.links.add(other);
    other.links.add(this);
    return true;
  }
}

class Graph {
  constructor(ctx, size) {
    this.zoom = 1;
    this.camx = 0;
    this.camy = 0;
    this.heldNode = null;
    this.selectedNode = null;

    // Generate graph.
    this.newPlanarGraph(size);
  }

  newGraph(size) {
    // Straigtforward random graph generator.
    while (true) {
      // Create nodes.
      this.nodes = [];
      for (let i = 0; i < size; ++i) this.nodes.push(new GraphNode(i, size));

      // Calculate number of links to create.
      const minLinks = size - 1;
      const maxLinks = size * (size - 1) / 2;
      let remainingLinks = kLinkFactor * (maxLinks - minLinks) + minLinks;

      const randLink = from => {
        let to = from;
        while (to == from) to = randInt(size);
        if (this.nodes[from].link(this.nodes[to])) {
          --remainingLinks;
        }
      };

      // Start by creating one link from each node.
      for (let i = 0; i < size; ++i) randLink(i);

      // Then continue generating random links until we've made the right number.
      while (remainingLinks > 0) randLink(randInt(size));

      // If we have any disconnected components, start over.
      const visited = new Set();
      this.dfs(this.nodes[0], visited);
      if (visited.size == this.nodes.length) break;
    }

    // Calculate the number of colors we want.
    let maxLinksPerNode = 0;
    for (const n of this.nodes) {
      maxLinksPerNode = Math.max(maxLinksPerNode, n.links.size);
    }
    // TODO: Tune this heuristic. It's probably an overestimate at higher sizes.
    const numColors = maxLinksPerNode + 1;
    this.colors = [];
    const offset = Math.random();
    for (let i = 0; i < numColors; ++i) {
      this.colors.push(hsv2rgb(offset + i / numColors));
    }
    this.frozen = false;
  }

  newPlanarGraph(size) {
    // A region is defined by the ordered list of points that bound it. The
    // order of the list matters because the edges that bound the region are
    // between each adjacent node in the list, and the first and last node too.
    // Start with a single point.
    const regions = [[0]];
    // const nodePos = [[1, 0]];

    // Create new nodes by subdividing the regions.
    for (let i = 1; i < size; ++i) {
      // Pick a random region, and pull it out of the list.
      const r = popSwap(regions, randInt(regions.length));

      // Place the new node in the center of the region.
      /*if (i <= 2) {
        nodePos.push([-0.5, i == 1 ? 0.707 : -0.707]);
      } else {
        // Find the center.
        let cx = 1e-6 * randPos();
        let cy = 1e-6 * randPos();
        for (const i of r) {
          cx += nodePos[i][0];
          cy += nodePos[i][1];
        }
        nodePos.push([cx / r.length, cy / r.length]);
      }*/

      // We're going to add a node inside this region, and connect it to a
      // random number of the surrounding nodes (at least 1).
      const p = randPermutation(r.length);
      p.length = 1 + randInt(r.length);
      p.sort();
      for (let j = 0; j < p.length; ++j) {
        const k0 = p[j];
        const k1 = p[(j + 1) % p.length];

        // Cut r from r[k0] to r[k1].
        const s = [r[k1], i, r[k0]];
        let k = k0;
        while (true) {
          k = (k + 1) % r.length;
          s.push(r[k]);
          if (k == k1) break;
        }
        regions.push(s);
      }
    }

    // Create nodes.
    this.nodes = [];
    for (let i = 0; i < size; ++i) {
      this.nodes.push(new GraphNode(i, size));
      // this.nodes[i].px = nodePos[i][0];
      // this.nodes[i].py = nodePos[i][1];
    }

    // Turn the region set into links.
    for (const r of regions) {
      for (let i = 0; i < r.length; ++i) {
        const k0 = r[i];
        const k1 = r[(i + 1) % r.length];
        this.nodes[k0].link(this.nodes[k1]);
      }
    }

    // Define colors.
    const numColors = 4;
    this.colors = [];
    const offset = Math.random();
    for (let i = 0; i < numColors; ++i) {
      this.colors.push(hsv2rgb(offset + i / numColors));
    }
    this.frozen = false;
  }

  dfs(node, visited, fn = null) {
    if (visited.has(node)) return;
    visited.add(node);
    if (fn) fn(node);
    for (const m of node.links) this.dfs(m, visited);
  }

  resetPos() {
    this.frozen = false;
    for (const n of this.nodes) n.resetPos(this.nodes.length);
  }

  update() {
    for (let i = 0; i < kUpdateItrs; ++i) {
      // Stop updating if we've reached equilibrium.
      if (this.frozen) return;
      this.updateImpl();
    }
  }

  updateImpl() {
    // Calculate the forces.
    this.frozen = true;
    const size = this.nodes.length;
    for (let i = 0; i < size; ++i) {
      const n = this.nodes[i];

      // Apply a weak spring force towards the origin.
      const dist = Math.sqrt(n.px * n.px + n.py * n.py);
      const ux = n.px / dist;
      const uy = n.py / dist;
      const fa = -kAttractForce * Math.sqrt(dist);
      n.vx += fa * ux;
      n.vy += fa * uy;

      for (let j = 0; j < size; ++j) {
        if (i == j) continue;
        const m = this.nodes[j];
        const dx = m.px - n.px;
        const dy = m.py - n.py;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const ux = dx / dist;
        const uy = dy / dist;

        // Push the nodes apart, as if they're same pole magnets.
        const fr = kRepelForce / (dist * dist);
        n.vx += fr * ux;
        n.vy += fr * uy;

        if (n.links.has(m)) {
          // Pull the nodes together, as if they're joined by springs.
          const fa = kAttractForce * dist;
          n.vx += fa * ux;
          n.vy += fa * uy;
        }
      }

      // Damping.
      n.vx *= 1 - kDamping;
      n.vy *= 1 - kDamping;

      // Check if we've reached equilibrium.
      if (n.vx > kFreezeThreshold || n.vy > kFreezeThreshold) {
        this.frozen = false;
      }
    }

    // Apply the forces, and calculate the bounding box.
    let minx = Infinity;
    let maxx = -Infinity;
    let miny = Infinity;
    let maxy = -Infinity;
    for (let i = 0; i < size; ++i) {
      const n = this.nodes[i];
      n.px += n.vx;
      n.py += n.vy;
      minx = Math.min(minx, n.px);
      maxx = Math.max(maxx, n.px);
      miny = Math.min(miny, n.py);
      maxy = Math.max(maxy, n.py);
    }

    // Zoom and center.
    this.zoom = 0.52 * Math.max(maxx - minx, maxy - miny);
    this.camx = 0.5 * (minx + maxx);
    this.camy = 0.5 * (miny + maxy);

    if (this.frozen) console.log('FREEZE!', this.zoom);
  }

  draw(drawLink, drawNode) {
    // Draw all the links.
    const tx = x => (x - this.camx) / this.zoom;
    const ty = y => (y - this.camy) / this.zoom;
    const size = this.nodes.length;
    for (let i = 1; i < size; ++i) {
      const n = this.nodes[i];
      for (let j = 0; j < i; ++j) {
        const m = this.nodes[j];
        if (n.links.has(m)) {
          const clr = (this.selectedNode == i || this.selectedNode == j) ?
              '#FFF' : '#222';
          drawLink(tx(n.px), ty(n.py), tx(m.px), ty(m.py), clr);
        }
      }
    }

    // Draw all the nodes.
    for (let i = 0; i < size; ++i) {
      const n = this.nodes[i];
      const c = (this.selectedNode == i) ? '#FFF' :
          (n.color == -1) ? '#222' : this.colors[n.color];
      drawNode(tx(n.px), ty(n.py), c);
    }
  }

  onClickDown(rawx, rawy, hitrad) {
    const px = this.camx + rawx * this.zoom;
    const py = this.camy + rawy * this.zoom;
    let minr = Infinity;
    let mini = -1;
    for (let i = 0; i < this.nodes.length; ++i) {
      const n = this.nodes[i];
      const dx = px - n.px;
      const dy = py - n.py;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < minr) {
        minr = dist;
        mini = i;
      }
    }
    if (minr < hitrad * this.zoom) {
      this.heldNode = mini;
      this.selectedNode = (this.nodes[mini].color != -1) ? mini : null;
    } else {
      this.heldNode = null;
      this.selectedNode = null;
    }
  }

  onClickMove(rawx, rawy) {
    if (this.heldNode == null) return;
    const px = this.camx + rawx * this.zoom;
    const py = this.camy + rawy * this.zoom;
    this.nodes[this.heldNode].px = px;
    this.nodes[this.heldNode].py = py;
  }

  onClickUp() {
    this.heldNode = null;
  }

  isValidMove(move) {
    // Move is valid if the target node is empty and all its neighbors have a
    // different color to the target color.
    const n = this.nodes[move.nodeId];
    if (n.color != -1) return false;
    for (const m of n.links) {
      if (m.color == move.color) return false;
    }
    return true;
  }

  // Returns -1 if game is not over, 0 if Emmy won, and 1 if Phil won.
  doMove(move) {
    console.log(move, this.selectedNode);
    this.selectedNode = null;
    this.nodes[move.nodeId].color = move.color;

    // If all nodes are filled, Phil has won. Otherwise, if there are no valid
    // moves left, Emmy has won.
    let anyEmpty = false;
    let anyMoves = false;
    for (const n of this.nodes) {
      if (n.color == -1) {
        anyEmpty = true;

        // Are there any colors not used by the neighbors?
        const usedColors = new Set();
        for (const m of n.links) {
          if (m.color != -1) usedColors.add(m.color);
        }
        if (usedColors.size < this.colors.length) {
          anyMoves = true;
          break;
        }
      }
    }
    if (!anyEmpty) return 1;
    if (!anyMoves) return 0;
    return -1;
  }
}

class Game {
  constructor(div) {
    this.div = div;
    this.graph = null;
    this.philCtrl = null;
    this.emmyCtrl = null;
  }

  transitionToSetup() {
    emptyDiv(this.div);
    newDiv(this.div, ['game-heading'], 'New Game');
    const makeRow = name => {
      const row = newDiv(this.div, ['game-setup-row']);
      newDiv(row, ['game-setup-name'], name);
      return row;
    };
    const makePlayerSelect = name =>
        newSelect(makeRow(name), ['game-setup-player-select'], ['Human', 'AI']);
    const phil = makePlayerSelect('Phil');
    const emmy = makePlayerSelect('Emmy');
    const makeSlider = (name, min, max) => {
      const row = makeRow(name);
      const number = newDiv(row, ['game-setup-slider-number']);
      const slider = newSlider(row, ['game-setup-slider'], min, max);
      number.innerText = slider.value = 7;
      slider.addEventListener('change', () => number.innerText = slider.value);
      return slider;
    };
    const size = makeSlider('Nodes', 4, 20);
    newBtn(this.div, ['game-setup-play-button'], '[PLAY]', () =>
      this.transitionToGame(phil.value, emmy.value, parseInt(size.value)));
  }

  makeCtrl(kind, isPhil, ui, onMove) {
    return kind == 'AI' ? new AiCtrl(this.graph, isPhil, ui, onMove) :
                          new HumanCtrl(this.graph, isPhil, ui, onMove);
  }

  transitionToGame(phil, emmy, size) {
    emptyDiv(this.div);
    const wrap = newDiv(this.div, ['game-wrapper']);
    const ui = newDiv(wrap, ['game-ui']);
    const philUi = newDiv(ui, []);
    const emmyUi = newDiv(ui, ['hidden']);
    const view = newDiv(wrap, ['game-view']);

    const canvas = newCanvas(view, [], 800, 800);
    const ctx = canvas.getContext('2d');
    const halfWidth = canvas.width / 2;
    const halfHeight = canvas.height / 2;
    const viewSize = 2.5;
    const nodeSize = 0.03 * viewSize;
    const posX = 0;
    const posY = 0;
    ctx.setTransform(
        2 * halfWidth / viewSize, 0, 0, 2 * halfHeight / viewSize,
        halfWidth * (1 + 2 * posX / viewSize),
        halfHeight * (1 + 2 * posY / viewSize));
    ctx.lineWidth = viewSize / (halfWidth + halfHeight);

    this.graph = new Graph(ctx, size);
    canvas.addEventListener('mousedown', e => {
      this.graph.onClickDown(
          (e.offsetX / canvas.width - 0.5) * viewSize,
          (e.offsetY / canvas.height - 0.5) * viewSize,
          nodeSize);
    });
    canvas.addEventListener('mousemove', e => {
      this.graph.onClickMove(
          (e.offsetX / canvas.width - 0.5) * viewSize,
          (e.offsetY / canvas.height - 0.5) * viewSize);
    });
    canvas.addEventListener('mouseout', e => this.graph.onClickUp());
    canvas.addEventListener('mouseup', e => this.graph.onClickUp());

    const drawCircle = (px, py, r, clr) => {
      ctx.fillStyle = clr;
      ctx.beginPath();
      ctx.ellipse(px, py, r, r, 0, 0, tau);
      ctx.fill();
    };

    const drawNode = (px, py, clr) => drawCircle(px, py, nodeSize, clr);

    const drawLine = (px, py, qx, qy, clr) => {
      ctx.strokeStyle = clr;
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.lineTo(qx, qy);
      ctx.stroke();
    };

    const update = () => {
      if (this.graph == null) {
        // Game is over.
        return;
      }

      this.graph.update();

      // Clear to black.
      ctx.fillStyle = '#000';
      ctx.fillRect(-2 * viewSize, -2 * viewSize, 4 * viewSize, 4 * viewSize);

      this.graph.draw(drawLine, drawNode);
      window.requestAnimationFrame(update);
    }
    update();

    const maybeDoEndTransition = status => {
      if (status == -1) return false;
      console.log('TODO: Implement game over', status);
      this.graph = null;
      this.transitionToSetup();
      return true;
    };

    const onMove = (move) => {
      philUi.classList.toggle('hidden');
      emmyUi.classList.toggle('hidden');
      maybeDoEndTransition(this.graph.doMove(move));
    };
    this.philCtrl = this.makeCtrl(phil, true, philUi, onMove);
    this.emmyCtrl = this.makeCtrl(emmy, false, emmyUi, onMove);
  }
}

</script>
<style>
body {
  background-color: #212121;
  margin: 0;
}
#head {
  background-color: #424242;
  width: 100%;
  display: flex;
  justify-content: space-around;
  margin-bottom: 16px;
}
h1, #index {
  color: #ffc107;
  text-align: center;
  font-family: monospace;
  font-size: 42px;
  flex-grow: 1;
  padding: 16px;
  margin: 0;
}
#index {
  color: #ff5722;
  text-decoration: none;
  flex-grow: 0;
}
h2 {
  color: #ff5722;
  font-family: monospace;
}
a {
  color: #ffc107;
  font-family: monospace;
  font-size: 16px;
  cursor: pointer;
  text-decoration: underline;
}
#wrap {
  padding: 0 16px;
  color: #f5f5f5;
  font-family: monospace;
  font-size: 16px;
}
#game {
  display: flex;
  flex-direction: column;
  align-items: center;
}
.game-setup-row {
  display: flex;
  flex-direction: row;
  margin-top: 16px;
}
.game-heading {
  font-size: 24px;
  color: #ffc107;
}
.game-setup-name {
  margin-right: 16px;
}
.game-setup-slider-number {
  margin-right: 8px;
}
.game-setup-play-button {
  margin-top: 16px;
  cursor: pointer;
  font-size: 20px;
  color: #ff5722;
}
.game-wrapper {
  display: flex;
  flex-direction: row;
  gap: 16px;
}
.game-ui {
  width: 300px;
  display: flex;
  flex-direction: column;
}
.game-status {
  color: #ffc107;
  font-size: 20px;
}
.game-ctrl-clr-row {
  margin: 8px;
  display: flex;
  flex-direction: row;
  gap: 12px;
  flex-wrap: wrap;
}
.game-ctrl-clr {
  width: 32px;
  height: 32px;
  border-radius: 10px;
  cursor: pointer;
}
.game-ctrl-clr.selected {
  width: 24px;
  height: 24px;
  border: 4px solid white;
}
.game-ctrl-row {
  display: flex;
  flex-direction: row;
  gap: 8px;
}
.game-ctrl-fill {
  color: #f44336;
}
.game-ctrl-fill {
  cursor: pointer;
  color: #ff5722;
}
.game-ctrl-error {
  color: #f44336;
}
.hidden {
  display: none;
}
</style>
</head>
<body>
<div id="head">
  <a id="index" href="index.html">&lt;</a>
  <h1>Graph Coloring Game (Prototype)</h1>
</div>
<div id="wrap">
  Two players, Phil and Emmy, take turns coloring nodes of a graph. Connected
  nodes must always be different colors. The game continues until no more nodes
  can be colored. Phil wins if all the nodes are filled, and Emmy wins if some
  of the nodes are empty.
  <br/><br/>
  <div id="game"></div>
</div>
</body>
</html>
